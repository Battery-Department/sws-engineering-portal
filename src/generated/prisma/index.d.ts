
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model ChatSession
 * 
 */
export type ChatSession = $Result.DefaultSelection<Prisma.$ChatSessionPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model SessionTag
 * 
 */
export type SessionTag = $Result.DefaultSelection<Prisma.$SessionTagPayload>
/**
 * Model MondaySync
 * 
 */
export type MondaySync = $Result.DefaultSelection<Prisma.$MondaySyncPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model OrderItem
 * 
 */
export type OrderItem = $Result.DefaultSelection<Prisma.$OrderItemPayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model SubscriptionPlan
 * 
 */
export type SubscriptionPlan = $Result.DefaultSelection<Prisma.$SubscriptionPlanPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model PaymentMethod
 * 
 */
export type PaymentMethod = $Result.DefaultSelection<Prisma.$PaymentMethodPayload>
/**
 * Model Inventory
 * 
 */
export type Inventory = $Result.DefaultSelection<Prisma.$InventoryPayload>
/**
 * Model Cart
 * 
 */
export type Cart = $Result.DefaultSelection<Prisma.$CartPayload>
/**
 * Model CartItem
 * 
 */
export type CartItem = $Result.DefaultSelection<Prisma.$CartItemPayload>
/**
 * Model PriceHistory
 * 
 */
export type PriceHistory = $Result.DefaultSelection<Prisma.$PriceHistoryPayload>
/**
 * Model SystemHealth
 * 
 */
export type SystemHealth = $Result.DefaultSelection<Prisma.$SystemHealthPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model AnalyticsEvent
 * 
 */
export type AnalyticsEvent = $Result.DefaultSelection<Prisma.$AnalyticsEventPayload>
/**
 * Model AnalyticsSession
 * 
 */
export type AnalyticsSession = $Result.DefaultSelection<Prisma.$AnalyticsSessionPayload>
/**
 * Model AnalyticsMetric
 * 
 */
export type AnalyticsMetric = $Result.DefaultSelection<Prisma.$AnalyticsMetricPayload>
/**
 * Model AnalyticsCohort
 * 
 */
export type AnalyticsCohort = $Result.DefaultSelection<Prisma.$AnalyticsCohortPayload>
/**
 * Model AnalyticsFunnel
 * 
 */
export type AnalyticsFunnel = $Result.DefaultSelection<Prisma.$AnalyticsFunnelPayload>
/**
 * Model AnalyticsAttribution
 * 
 */
export type AnalyticsAttribution = $Result.DefaultSelection<Prisma.$AnalyticsAttributionPayload>
/**
 * Model AnalyticsSegment
 * 
 */
export type AnalyticsSegment = $Result.DefaultSelection<Prisma.$AnalyticsSegmentPayload>
/**
 * Model AnalyticsReport
 * 
 */
export type AnalyticsReport = $Result.DefaultSelection<Prisma.$AnalyticsReportPayload>
/**
 * Model QuizSession
 * 
 */
export type QuizSession = $Result.DefaultSelection<Prisma.$QuizSessionPayload>
/**
 * Model QuizResponse
 * 
 */
export type QuizResponse = $Result.DefaultSelection<Prisma.$QuizResponsePayload>
/**
 * Model BehavioralInteraction
 * 
 */
export type BehavioralInteraction = $Result.DefaultSelection<Prisma.$BehavioralInteractionPayload>
/**
 * Model QuizConversion
 * 
 */
export type QuizConversion = $Result.DefaultSelection<Prisma.$QuizConversionPayload>
/**
 * Model ABTestExperiment
 * 
 */
export type ABTestExperiment = $Result.DefaultSelection<Prisma.$ABTestExperimentPayload>
/**
 * Model QuizBrand
 * 
 */
export type QuizBrand = $Result.DefaultSelection<Prisma.$QuizBrandPayload>
/**
 * Model QuizRoutingRule
 * 
 */
export type QuizRoutingRule = $Result.DefaultSelection<Prisma.$QuizRoutingRulePayload>
/**
 * Model QuizIntervention
 * 
 */
export type QuizIntervention = $Result.DefaultSelection<Prisma.$QuizInterventionPayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model ProjectStage
 * 
 */
export type ProjectStage = $Result.DefaultSelection<Prisma.$ProjectStagePayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model DocumentGeneration
 * 
 */
export type DocumentGeneration = $Result.DefaultSelection<Prisma.$DocumentGenerationPayload>
/**
 * Model Quote
 * 
 */
export type Quote = $Result.DefaultSelection<Prisma.$QuotePayload>
/**
 * Model MaterialCost
 * 
 */
export type MaterialCost = $Result.DefaultSelection<Prisma.$MaterialCostPayload>
/**
 * Model SupplierInvoice
 * 
 */
export type SupplierInvoice = $Result.DefaultSelection<Prisma.$SupplierInvoicePayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatSession`: Exposes CRUD operations for the **ChatSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatSessions
    * const chatSessions = await prisma.chatSession.findMany()
    * ```
    */
  get chatSession(): Prisma.ChatSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sessionTag`: Exposes CRUD operations for the **SessionTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SessionTags
    * const sessionTags = await prisma.sessionTag.findMany()
    * ```
    */
  get sessionTag(): Prisma.SessionTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mondaySync`: Exposes CRUD operations for the **MondaySync** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MondaySyncs
    * const mondaySyncs = await prisma.mondaySync.findMany()
    * ```
    */
  get mondaySync(): Prisma.MondaySyncDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItem.findMany()
    * ```
    */
  get orderItem(): Prisma.OrderItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscriptionPlan`: Exposes CRUD operations for the **SubscriptionPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubscriptionPlans
    * const subscriptionPlans = await prisma.subscriptionPlan.findMany()
    * ```
    */
  get subscriptionPlan(): Prisma.SubscriptionPlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentMethod`: Exposes CRUD operations for the **PaymentMethod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentMethods
    * const paymentMethods = await prisma.paymentMethod.findMany()
    * ```
    */
  get paymentMethod(): Prisma.PaymentMethodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventory`: Exposes CRUD operations for the **Inventory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inventories
    * const inventories = await prisma.inventory.findMany()
    * ```
    */
  get inventory(): Prisma.InventoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cart`: Exposes CRUD operations for the **Cart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Carts
    * const carts = await prisma.cart.findMany()
    * ```
    */
  get cart(): Prisma.CartDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cartItem`: Exposes CRUD operations for the **CartItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CartItems
    * const cartItems = await prisma.cartItem.findMany()
    * ```
    */
  get cartItem(): Prisma.CartItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.priceHistory`: Exposes CRUD operations for the **PriceHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PriceHistories
    * const priceHistories = await prisma.priceHistory.findMany()
    * ```
    */
  get priceHistory(): Prisma.PriceHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemHealth`: Exposes CRUD operations for the **SystemHealth** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemHealths
    * const systemHealths = await prisma.systemHealth.findMany()
    * ```
    */
  get systemHealth(): Prisma.SystemHealthDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.analyticsEvent`: Exposes CRUD operations for the **AnalyticsEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnalyticsEvents
    * const analyticsEvents = await prisma.analyticsEvent.findMany()
    * ```
    */
  get analyticsEvent(): Prisma.AnalyticsEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.analyticsSession`: Exposes CRUD operations for the **AnalyticsSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnalyticsSessions
    * const analyticsSessions = await prisma.analyticsSession.findMany()
    * ```
    */
  get analyticsSession(): Prisma.AnalyticsSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.analyticsMetric`: Exposes CRUD operations for the **AnalyticsMetric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnalyticsMetrics
    * const analyticsMetrics = await prisma.analyticsMetric.findMany()
    * ```
    */
  get analyticsMetric(): Prisma.AnalyticsMetricDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.analyticsCohort`: Exposes CRUD operations for the **AnalyticsCohort** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnalyticsCohorts
    * const analyticsCohorts = await prisma.analyticsCohort.findMany()
    * ```
    */
  get analyticsCohort(): Prisma.AnalyticsCohortDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.analyticsFunnel`: Exposes CRUD operations for the **AnalyticsFunnel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnalyticsFunnels
    * const analyticsFunnels = await prisma.analyticsFunnel.findMany()
    * ```
    */
  get analyticsFunnel(): Prisma.AnalyticsFunnelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.analyticsAttribution`: Exposes CRUD operations for the **AnalyticsAttribution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnalyticsAttributions
    * const analyticsAttributions = await prisma.analyticsAttribution.findMany()
    * ```
    */
  get analyticsAttribution(): Prisma.AnalyticsAttributionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.analyticsSegment`: Exposes CRUD operations for the **AnalyticsSegment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnalyticsSegments
    * const analyticsSegments = await prisma.analyticsSegment.findMany()
    * ```
    */
  get analyticsSegment(): Prisma.AnalyticsSegmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.analyticsReport`: Exposes CRUD operations for the **AnalyticsReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnalyticsReports
    * const analyticsReports = await prisma.analyticsReport.findMany()
    * ```
    */
  get analyticsReport(): Prisma.AnalyticsReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quizSession`: Exposes CRUD operations for the **QuizSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizSessions
    * const quizSessions = await prisma.quizSession.findMany()
    * ```
    */
  get quizSession(): Prisma.QuizSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quizResponse`: Exposes CRUD operations for the **QuizResponse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizResponses
    * const quizResponses = await prisma.quizResponse.findMany()
    * ```
    */
  get quizResponse(): Prisma.QuizResponseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.behavioralInteraction`: Exposes CRUD operations for the **BehavioralInteraction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BehavioralInteractions
    * const behavioralInteractions = await prisma.behavioralInteraction.findMany()
    * ```
    */
  get behavioralInteraction(): Prisma.BehavioralInteractionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quizConversion`: Exposes CRUD operations for the **QuizConversion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizConversions
    * const quizConversions = await prisma.quizConversion.findMany()
    * ```
    */
  get quizConversion(): Prisma.QuizConversionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aBTestExperiment`: Exposes CRUD operations for the **ABTestExperiment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ABTestExperiments
    * const aBTestExperiments = await prisma.aBTestExperiment.findMany()
    * ```
    */
  get aBTestExperiment(): Prisma.ABTestExperimentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quizBrand`: Exposes CRUD operations for the **QuizBrand** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizBrands
    * const quizBrands = await prisma.quizBrand.findMany()
    * ```
    */
  get quizBrand(): Prisma.QuizBrandDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quizRoutingRule`: Exposes CRUD operations for the **QuizRoutingRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizRoutingRules
    * const quizRoutingRules = await prisma.quizRoutingRule.findMany()
    * ```
    */
  get quizRoutingRule(): Prisma.QuizRoutingRuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quizIntervention`: Exposes CRUD operations for the **QuizIntervention** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizInterventions
    * const quizInterventions = await prisma.quizIntervention.findMany()
    * ```
    */
  get quizIntervention(): Prisma.QuizInterventionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectStage`: Exposes CRUD operations for the **ProjectStage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectStages
    * const projectStages = await prisma.projectStage.findMany()
    * ```
    */
  get projectStage(): Prisma.ProjectStageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.documentGeneration`: Exposes CRUD operations for the **DocumentGeneration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentGenerations
    * const documentGenerations = await prisma.documentGeneration.findMany()
    * ```
    */
  get documentGeneration(): Prisma.DocumentGenerationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quote`: Exposes CRUD operations for the **Quote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quotes
    * const quotes = await prisma.quote.findMany()
    * ```
    */
  get quote(): Prisma.QuoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.materialCost`: Exposes CRUD operations for the **MaterialCost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MaterialCosts
    * const materialCosts = await prisma.materialCost.findMany()
    * ```
    */
  get materialCost(): Prisma.MaterialCostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supplierInvoice`: Exposes CRUD operations for the **SupplierInvoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SupplierInvoices
    * const supplierInvoices = await prisma.supplierInvoice.findMany()
    * ```
    */
  get supplierInvoice(): Prisma.SupplierInvoiceDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.2
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    ChatSession: 'ChatSession',
    Message: 'Message',
    SessionTag: 'SessionTag',
    MondaySync: 'MondaySync',
    Customer: 'Customer',
    Product: 'Product',
    Order: 'Order',
    OrderItem: 'OrderItem',
    Subscription: 'Subscription',
    SubscriptionPlan: 'SubscriptionPlan',
    Invoice: 'Invoice',
    PaymentMethod: 'PaymentMethod',
    Inventory: 'Inventory',
    Cart: 'Cart',
    CartItem: 'CartItem',
    PriceHistory: 'PriceHistory',
    SystemHealth: 'SystemHealth',
    Notification: 'Notification',
    AnalyticsEvent: 'AnalyticsEvent',
    AnalyticsSession: 'AnalyticsSession',
    AnalyticsMetric: 'AnalyticsMetric',
    AnalyticsCohort: 'AnalyticsCohort',
    AnalyticsFunnel: 'AnalyticsFunnel',
    AnalyticsAttribution: 'AnalyticsAttribution',
    AnalyticsSegment: 'AnalyticsSegment',
    AnalyticsReport: 'AnalyticsReport',
    QuizSession: 'QuizSession',
    QuizResponse: 'QuizResponse',
    BehavioralInteraction: 'BehavioralInteraction',
    QuizConversion: 'QuizConversion',
    ABTestExperiment: 'ABTestExperiment',
    QuizBrand: 'QuizBrand',
    QuizRoutingRule: 'QuizRoutingRule',
    QuizIntervention: 'QuizIntervention',
    Service: 'Service',
    Project: 'Project',
    ProjectStage: 'ProjectStage',
    Document: 'Document',
    DocumentGeneration: 'DocumentGeneration',
    Quote: 'Quote',
    MaterialCost: 'MaterialCost',
    SupplierInvoice: 'SupplierInvoice'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "chatSession" | "message" | "sessionTag" | "mondaySync" | "customer" | "product" | "order" | "orderItem" | "subscription" | "subscriptionPlan" | "invoice" | "paymentMethod" | "inventory" | "cart" | "cartItem" | "priceHistory" | "systemHealth" | "notification" | "analyticsEvent" | "analyticsSession" | "analyticsMetric" | "analyticsCohort" | "analyticsFunnel" | "analyticsAttribution" | "analyticsSegment" | "analyticsReport" | "quizSession" | "quizResponse" | "behavioralInteraction" | "quizConversion" | "aBTestExperiment" | "quizBrand" | "quizRoutingRule" | "quizIntervention" | "service" | "project" | "projectStage" | "document" | "documentGeneration" | "quote" | "materialCost" | "supplierInvoice"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      ChatSession: {
        payload: Prisma.$ChatSessionPayload<ExtArgs>
        fields: Prisma.ChatSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>
          }
          findFirst: {
            args: Prisma.ChatSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>
          }
          findMany: {
            args: Prisma.ChatSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>[]
          }
          create: {
            args: Prisma.ChatSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>
          }
          createMany: {
            args: Prisma.ChatSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>[]
          }
          delete: {
            args: Prisma.ChatSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>
          }
          update: {
            args: Prisma.ChatSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>
          }
          deleteMany: {
            args: Prisma.ChatSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChatSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>[]
          }
          upsert: {
            args: Prisma.ChatSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>
          }
          aggregate: {
            args: Prisma.ChatSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatSession>
          }
          groupBy: {
            args: Prisma.ChatSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatSessionCountArgs<ExtArgs>
            result: $Utils.Optional<ChatSessionCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      SessionTag: {
        payload: Prisma.$SessionTagPayload<ExtArgs>
        fields: Prisma.SessionTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionTagPayload>
          }
          findFirst: {
            args: Prisma.SessionTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionTagPayload>
          }
          findMany: {
            args: Prisma.SessionTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionTagPayload>[]
          }
          create: {
            args: Prisma.SessionTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionTagPayload>
          }
          createMany: {
            args: Prisma.SessionTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionTagPayload>[]
          }
          delete: {
            args: Prisma.SessionTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionTagPayload>
          }
          update: {
            args: Prisma.SessionTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionTagPayload>
          }
          deleteMany: {
            args: Prisma.SessionTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionTagPayload>[]
          }
          upsert: {
            args: Prisma.SessionTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionTagPayload>
          }
          aggregate: {
            args: Prisma.SessionTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessionTag>
          }
          groupBy: {
            args: Prisma.SessionTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionTagCountArgs<ExtArgs>
            result: $Utils.Optional<SessionTagCountAggregateOutputType> | number
          }
        }
      }
      MondaySync: {
        payload: Prisma.$MondaySyncPayload<ExtArgs>
        fields: Prisma.MondaySyncFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MondaySyncFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MondaySyncPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MondaySyncFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MondaySyncPayload>
          }
          findFirst: {
            args: Prisma.MondaySyncFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MondaySyncPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MondaySyncFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MondaySyncPayload>
          }
          findMany: {
            args: Prisma.MondaySyncFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MondaySyncPayload>[]
          }
          create: {
            args: Prisma.MondaySyncCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MondaySyncPayload>
          }
          createMany: {
            args: Prisma.MondaySyncCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MondaySyncCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MondaySyncPayload>[]
          }
          delete: {
            args: Prisma.MondaySyncDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MondaySyncPayload>
          }
          update: {
            args: Prisma.MondaySyncUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MondaySyncPayload>
          }
          deleteMany: {
            args: Prisma.MondaySyncDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MondaySyncUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MondaySyncUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MondaySyncPayload>[]
          }
          upsert: {
            args: Prisma.MondaySyncUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MondaySyncPayload>
          }
          aggregate: {
            args: Prisma.MondaySyncAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMondaySync>
          }
          groupBy: {
            args: Prisma.MondaySyncGroupByArgs<ExtArgs>
            result: $Utils.Optional<MondaySyncGroupByOutputType>[]
          }
          count: {
            args: Prisma.MondaySyncCountArgs<ExtArgs>
            result: $Utils.Optional<MondaySyncCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      OrderItem: {
        payload: Prisma.$OrderItemPayload<ExtArgs>
        fields: Prisma.OrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findFirst: {
            args: Prisma.OrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findMany: {
            args: Prisma.OrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          create: {
            args: Prisma.OrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          createMany: {
            args: Prisma.OrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          delete: {
            args: Prisma.OrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          update: {
            args: Prisma.OrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          upsert: {
            args: Prisma.OrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          aggregate: {
            args: Prisma.OrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderItem>
          }
          groupBy: {
            args: Prisma.OrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<OrderItemCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      SubscriptionPlan: {
        payload: Prisma.$SubscriptionPlanPayload<ExtArgs>
        fields: Prisma.SubscriptionPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          findMany: {
            args: Prisma.SubscriptionPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>[]
          }
          create: {
            args: Prisma.SubscriptionPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          createMany: {
            args: Prisma.SubscriptionPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          update: {
            args: Prisma.SubscriptionPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionPlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscriptionPlan>
          }
          groupBy: {
            args: Prisma.SubscriptionPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionPlanCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionPlanCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      PaymentMethod: {
        payload: Prisma.$PaymentMethodPayload<ExtArgs>
        fields: Prisma.PaymentMethodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentMethodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentMethodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          findFirst: {
            args: Prisma.PaymentMethodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentMethodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          findMany: {
            args: Prisma.PaymentMethodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          create: {
            args: Prisma.PaymentMethodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          createMany: {
            args: Prisma.PaymentMethodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentMethodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          delete: {
            args: Prisma.PaymentMethodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          update: {
            args: Prisma.PaymentMethodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          deleteMany: {
            args: Prisma.PaymentMethodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentMethodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentMethodUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          upsert: {
            args: Prisma.PaymentMethodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          aggregate: {
            args: Prisma.PaymentMethodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentMethod>
          }
          groupBy: {
            args: Prisma.PaymentMethodGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentMethodGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentMethodCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentMethodCountAggregateOutputType> | number
          }
        }
      }
      Inventory: {
        payload: Prisma.$InventoryPayload<ExtArgs>
        fields: Prisma.InventoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          findFirst: {
            args: Prisma.InventoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          findMany: {
            args: Prisma.InventoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>[]
          }
          create: {
            args: Prisma.InventoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          createMany: {
            args: Prisma.InventoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>[]
          }
          delete: {
            args: Prisma.InventoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          update: {
            args: Prisma.InventoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          deleteMany: {
            args: Prisma.InventoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InventoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>[]
          }
          upsert: {
            args: Prisma.InventoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          aggregate: {
            args: Prisma.InventoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventory>
          }
          groupBy: {
            args: Prisma.InventoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryCountAggregateOutputType> | number
          }
        }
      }
      Cart: {
        payload: Prisma.$CartPayload<ExtArgs>
        fields: Prisma.CartFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CartFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CartFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          findFirst: {
            args: Prisma.CartFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CartFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          findMany: {
            args: Prisma.CartFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>[]
          }
          create: {
            args: Prisma.CartCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          createMany: {
            args: Prisma.CartCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CartCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>[]
          }
          delete: {
            args: Prisma.CartDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          update: {
            args: Prisma.CartUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          deleteMany: {
            args: Prisma.CartDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CartUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CartUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>[]
          }
          upsert: {
            args: Prisma.CartUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          aggregate: {
            args: Prisma.CartAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCart>
          }
          groupBy: {
            args: Prisma.CartGroupByArgs<ExtArgs>
            result: $Utils.Optional<CartGroupByOutputType>[]
          }
          count: {
            args: Prisma.CartCountArgs<ExtArgs>
            result: $Utils.Optional<CartCountAggregateOutputType> | number
          }
        }
      }
      CartItem: {
        payload: Prisma.$CartItemPayload<ExtArgs>
        fields: Prisma.CartItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CartItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CartItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          findFirst: {
            args: Prisma.CartItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CartItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          findMany: {
            args: Prisma.CartItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>[]
          }
          create: {
            args: Prisma.CartItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          createMany: {
            args: Prisma.CartItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CartItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>[]
          }
          delete: {
            args: Prisma.CartItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          update: {
            args: Prisma.CartItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          deleteMany: {
            args: Prisma.CartItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CartItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CartItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>[]
          }
          upsert: {
            args: Prisma.CartItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          aggregate: {
            args: Prisma.CartItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCartItem>
          }
          groupBy: {
            args: Prisma.CartItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<CartItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.CartItemCountArgs<ExtArgs>
            result: $Utils.Optional<CartItemCountAggregateOutputType> | number
          }
        }
      }
      PriceHistory: {
        payload: Prisma.$PriceHistoryPayload<ExtArgs>
        fields: Prisma.PriceHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PriceHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PriceHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>
          }
          findFirst: {
            args: Prisma.PriceHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PriceHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>
          }
          findMany: {
            args: Prisma.PriceHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>[]
          }
          create: {
            args: Prisma.PriceHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>
          }
          createMany: {
            args: Prisma.PriceHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PriceHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>[]
          }
          delete: {
            args: Prisma.PriceHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>
          }
          update: {
            args: Prisma.PriceHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>
          }
          deleteMany: {
            args: Prisma.PriceHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PriceHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PriceHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>[]
          }
          upsert: {
            args: Prisma.PriceHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>
          }
          aggregate: {
            args: Prisma.PriceHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePriceHistory>
          }
          groupBy: {
            args: Prisma.PriceHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<PriceHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.PriceHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<PriceHistoryCountAggregateOutputType> | number
          }
        }
      }
      SystemHealth: {
        payload: Prisma.$SystemHealthPayload<ExtArgs>
        fields: Prisma.SystemHealthFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemHealthFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemHealthPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemHealthFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemHealthPayload>
          }
          findFirst: {
            args: Prisma.SystemHealthFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemHealthPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemHealthFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemHealthPayload>
          }
          findMany: {
            args: Prisma.SystemHealthFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemHealthPayload>[]
          }
          create: {
            args: Prisma.SystemHealthCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemHealthPayload>
          }
          createMany: {
            args: Prisma.SystemHealthCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemHealthCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemHealthPayload>[]
          }
          delete: {
            args: Prisma.SystemHealthDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemHealthPayload>
          }
          update: {
            args: Prisma.SystemHealthUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemHealthPayload>
          }
          deleteMany: {
            args: Prisma.SystemHealthDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemHealthUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemHealthUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemHealthPayload>[]
          }
          upsert: {
            args: Prisma.SystemHealthUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemHealthPayload>
          }
          aggregate: {
            args: Prisma.SystemHealthAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemHealth>
          }
          groupBy: {
            args: Prisma.SystemHealthGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemHealthGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemHealthCountArgs<ExtArgs>
            result: $Utils.Optional<SystemHealthCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      AnalyticsEvent: {
        payload: Prisma.$AnalyticsEventPayload<ExtArgs>
        fields: Prisma.AnalyticsEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnalyticsEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnalyticsEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          findFirst: {
            args: Prisma.AnalyticsEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnalyticsEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          findMany: {
            args: Prisma.AnalyticsEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>[]
          }
          create: {
            args: Prisma.AnalyticsEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          createMany: {
            args: Prisma.AnalyticsEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnalyticsEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>[]
          }
          delete: {
            args: Prisma.AnalyticsEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          update: {
            args: Prisma.AnalyticsEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          deleteMany: {
            args: Prisma.AnalyticsEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnalyticsEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnalyticsEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>[]
          }
          upsert: {
            args: Prisma.AnalyticsEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          aggregate: {
            args: Prisma.AnalyticsEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnalyticsEvent>
          }
          groupBy: {
            args: Prisma.AnalyticsEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnalyticsEventCountArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsEventCountAggregateOutputType> | number
          }
        }
      }
      AnalyticsSession: {
        payload: Prisma.$AnalyticsSessionPayload<ExtArgs>
        fields: Prisma.AnalyticsSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnalyticsSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnalyticsSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsSessionPayload>
          }
          findFirst: {
            args: Prisma.AnalyticsSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnalyticsSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsSessionPayload>
          }
          findMany: {
            args: Prisma.AnalyticsSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsSessionPayload>[]
          }
          create: {
            args: Prisma.AnalyticsSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsSessionPayload>
          }
          createMany: {
            args: Prisma.AnalyticsSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnalyticsSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsSessionPayload>[]
          }
          delete: {
            args: Prisma.AnalyticsSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsSessionPayload>
          }
          update: {
            args: Prisma.AnalyticsSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsSessionPayload>
          }
          deleteMany: {
            args: Prisma.AnalyticsSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnalyticsSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnalyticsSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsSessionPayload>[]
          }
          upsert: {
            args: Prisma.AnalyticsSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsSessionPayload>
          }
          aggregate: {
            args: Prisma.AnalyticsSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnalyticsSession>
          }
          groupBy: {
            args: Prisma.AnalyticsSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnalyticsSessionCountArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsSessionCountAggregateOutputType> | number
          }
        }
      }
      AnalyticsMetric: {
        payload: Prisma.$AnalyticsMetricPayload<ExtArgs>
        fields: Prisma.AnalyticsMetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnalyticsMetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsMetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnalyticsMetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsMetricPayload>
          }
          findFirst: {
            args: Prisma.AnalyticsMetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsMetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnalyticsMetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsMetricPayload>
          }
          findMany: {
            args: Prisma.AnalyticsMetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsMetricPayload>[]
          }
          create: {
            args: Prisma.AnalyticsMetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsMetricPayload>
          }
          createMany: {
            args: Prisma.AnalyticsMetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnalyticsMetricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsMetricPayload>[]
          }
          delete: {
            args: Prisma.AnalyticsMetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsMetricPayload>
          }
          update: {
            args: Prisma.AnalyticsMetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsMetricPayload>
          }
          deleteMany: {
            args: Prisma.AnalyticsMetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnalyticsMetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnalyticsMetricUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsMetricPayload>[]
          }
          upsert: {
            args: Prisma.AnalyticsMetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsMetricPayload>
          }
          aggregate: {
            args: Prisma.AnalyticsMetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnalyticsMetric>
          }
          groupBy: {
            args: Prisma.AnalyticsMetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsMetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnalyticsMetricCountArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsMetricCountAggregateOutputType> | number
          }
        }
      }
      AnalyticsCohort: {
        payload: Prisma.$AnalyticsCohortPayload<ExtArgs>
        fields: Prisma.AnalyticsCohortFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnalyticsCohortFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsCohortPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnalyticsCohortFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsCohortPayload>
          }
          findFirst: {
            args: Prisma.AnalyticsCohortFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsCohortPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnalyticsCohortFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsCohortPayload>
          }
          findMany: {
            args: Prisma.AnalyticsCohortFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsCohortPayload>[]
          }
          create: {
            args: Prisma.AnalyticsCohortCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsCohortPayload>
          }
          createMany: {
            args: Prisma.AnalyticsCohortCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnalyticsCohortCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsCohortPayload>[]
          }
          delete: {
            args: Prisma.AnalyticsCohortDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsCohortPayload>
          }
          update: {
            args: Prisma.AnalyticsCohortUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsCohortPayload>
          }
          deleteMany: {
            args: Prisma.AnalyticsCohortDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnalyticsCohortUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnalyticsCohortUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsCohortPayload>[]
          }
          upsert: {
            args: Prisma.AnalyticsCohortUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsCohortPayload>
          }
          aggregate: {
            args: Prisma.AnalyticsCohortAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnalyticsCohort>
          }
          groupBy: {
            args: Prisma.AnalyticsCohortGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsCohortGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnalyticsCohortCountArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsCohortCountAggregateOutputType> | number
          }
        }
      }
      AnalyticsFunnel: {
        payload: Prisma.$AnalyticsFunnelPayload<ExtArgs>
        fields: Prisma.AnalyticsFunnelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnalyticsFunnelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsFunnelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnalyticsFunnelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsFunnelPayload>
          }
          findFirst: {
            args: Prisma.AnalyticsFunnelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsFunnelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnalyticsFunnelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsFunnelPayload>
          }
          findMany: {
            args: Prisma.AnalyticsFunnelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsFunnelPayload>[]
          }
          create: {
            args: Prisma.AnalyticsFunnelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsFunnelPayload>
          }
          createMany: {
            args: Prisma.AnalyticsFunnelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnalyticsFunnelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsFunnelPayload>[]
          }
          delete: {
            args: Prisma.AnalyticsFunnelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsFunnelPayload>
          }
          update: {
            args: Prisma.AnalyticsFunnelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsFunnelPayload>
          }
          deleteMany: {
            args: Prisma.AnalyticsFunnelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnalyticsFunnelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnalyticsFunnelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsFunnelPayload>[]
          }
          upsert: {
            args: Prisma.AnalyticsFunnelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsFunnelPayload>
          }
          aggregate: {
            args: Prisma.AnalyticsFunnelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnalyticsFunnel>
          }
          groupBy: {
            args: Prisma.AnalyticsFunnelGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsFunnelGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnalyticsFunnelCountArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsFunnelCountAggregateOutputType> | number
          }
        }
      }
      AnalyticsAttribution: {
        payload: Prisma.$AnalyticsAttributionPayload<ExtArgs>
        fields: Prisma.AnalyticsAttributionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnalyticsAttributionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsAttributionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnalyticsAttributionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsAttributionPayload>
          }
          findFirst: {
            args: Prisma.AnalyticsAttributionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsAttributionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnalyticsAttributionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsAttributionPayload>
          }
          findMany: {
            args: Prisma.AnalyticsAttributionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsAttributionPayload>[]
          }
          create: {
            args: Prisma.AnalyticsAttributionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsAttributionPayload>
          }
          createMany: {
            args: Prisma.AnalyticsAttributionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnalyticsAttributionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsAttributionPayload>[]
          }
          delete: {
            args: Prisma.AnalyticsAttributionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsAttributionPayload>
          }
          update: {
            args: Prisma.AnalyticsAttributionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsAttributionPayload>
          }
          deleteMany: {
            args: Prisma.AnalyticsAttributionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnalyticsAttributionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnalyticsAttributionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsAttributionPayload>[]
          }
          upsert: {
            args: Prisma.AnalyticsAttributionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsAttributionPayload>
          }
          aggregate: {
            args: Prisma.AnalyticsAttributionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnalyticsAttribution>
          }
          groupBy: {
            args: Prisma.AnalyticsAttributionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsAttributionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnalyticsAttributionCountArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsAttributionCountAggregateOutputType> | number
          }
        }
      }
      AnalyticsSegment: {
        payload: Prisma.$AnalyticsSegmentPayload<ExtArgs>
        fields: Prisma.AnalyticsSegmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnalyticsSegmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsSegmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnalyticsSegmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsSegmentPayload>
          }
          findFirst: {
            args: Prisma.AnalyticsSegmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsSegmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnalyticsSegmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsSegmentPayload>
          }
          findMany: {
            args: Prisma.AnalyticsSegmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsSegmentPayload>[]
          }
          create: {
            args: Prisma.AnalyticsSegmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsSegmentPayload>
          }
          createMany: {
            args: Prisma.AnalyticsSegmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnalyticsSegmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsSegmentPayload>[]
          }
          delete: {
            args: Prisma.AnalyticsSegmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsSegmentPayload>
          }
          update: {
            args: Prisma.AnalyticsSegmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsSegmentPayload>
          }
          deleteMany: {
            args: Prisma.AnalyticsSegmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnalyticsSegmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnalyticsSegmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsSegmentPayload>[]
          }
          upsert: {
            args: Prisma.AnalyticsSegmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsSegmentPayload>
          }
          aggregate: {
            args: Prisma.AnalyticsSegmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnalyticsSegment>
          }
          groupBy: {
            args: Prisma.AnalyticsSegmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsSegmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnalyticsSegmentCountArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsSegmentCountAggregateOutputType> | number
          }
        }
      }
      AnalyticsReport: {
        payload: Prisma.$AnalyticsReportPayload<ExtArgs>
        fields: Prisma.AnalyticsReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnalyticsReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnalyticsReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsReportPayload>
          }
          findFirst: {
            args: Prisma.AnalyticsReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnalyticsReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsReportPayload>
          }
          findMany: {
            args: Prisma.AnalyticsReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsReportPayload>[]
          }
          create: {
            args: Prisma.AnalyticsReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsReportPayload>
          }
          createMany: {
            args: Prisma.AnalyticsReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnalyticsReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsReportPayload>[]
          }
          delete: {
            args: Prisma.AnalyticsReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsReportPayload>
          }
          update: {
            args: Prisma.AnalyticsReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsReportPayload>
          }
          deleteMany: {
            args: Prisma.AnalyticsReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnalyticsReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnalyticsReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsReportPayload>[]
          }
          upsert: {
            args: Prisma.AnalyticsReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsReportPayload>
          }
          aggregate: {
            args: Prisma.AnalyticsReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnalyticsReport>
          }
          groupBy: {
            args: Prisma.AnalyticsReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnalyticsReportCountArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsReportCountAggregateOutputType> | number
          }
        }
      }
      QuizSession: {
        payload: Prisma.$QuizSessionPayload<ExtArgs>
        fields: Prisma.QuizSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSessionPayload>
          }
          findFirst: {
            args: Prisma.QuizSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSessionPayload>
          }
          findMany: {
            args: Prisma.QuizSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSessionPayload>[]
          }
          create: {
            args: Prisma.QuizSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSessionPayload>
          }
          createMany: {
            args: Prisma.QuizSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSessionPayload>[]
          }
          delete: {
            args: Prisma.QuizSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSessionPayload>
          }
          update: {
            args: Prisma.QuizSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSessionPayload>
          }
          deleteMany: {
            args: Prisma.QuizSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSessionPayload>[]
          }
          upsert: {
            args: Prisma.QuizSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSessionPayload>
          }
          aggregate: {
            args: Prisma.QuizSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizSession>
          }
          groupBy: {
            args: Prisma.QuizSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizSessionCountArgs<ExtArgs>
            result: $Utils.Optional<QuizSessionCountAggregateOutputType> | number
          }
        }
      }
      QuizResponse: {
        payload: Prisma.$QuizResponsePayload<ExtArgs>
        fields: Prisma.QuizResponseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizResponseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizResponsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizResponseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizResponsePayload>
          }
          findFirst: {
            args: Prisma.QuizResponseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizResponsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizResponseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizResponsePayload>
          }
          findMany: {
            args: Prisma.QuizResponseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizResponsePayload>[]
          }
          create: {
            args: Prisma.QuizResponseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizResponsePayload>
          }
          createMany: {
            args: Prisma.QuizResponseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizResponseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizResponsePayload>[]
          }
          delete: {
            args: Prisma.QuizResponseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizResponsePayload>
          }
          update: {
            args: Prisma.QuizResponseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizResponsePayload>
          }
          deleteMany: {
            args: Prisma.QuizResponseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizResponseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizResponseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizResponsePayload>[]
          }
          upsert: {
            args: Prisma.QuizResponseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizResponsePayload>
          }
          aggregate: {
            args: Prisma.QuizResponseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizResponse>
          }
          groupBy: {
            args: Prisma.QuizResponseGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizResponseGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizResponseCountArgs<ExtArgs>
            result: $Utils.Optional<QuizResponseCountAggregateOutputType> | number
          }
        }
      }
      BehavioralInteraction: {
        payload: Prisma.$BehavioralInteractionPayload<ExtArgs>
        fields: Prisma.BehavioralInteractionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BehavioralInteractionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehavioralInteractionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BehavioralInteractionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehavioralInteractionPayload>
          }
          findFirst: {
            args: Prisma.BehavioralInteractionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehavioralInteractionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BehavioralInteractionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehavioralInteractionPayload>
          }
          findMany: {
            args: Prisma.BehavioralInteractionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehavioralInteractionPayload>[]
          }
          create: {
            args: Prisma.BehavioralInteractionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehavioralInteractionPayload>
          }
          createMany: {
            args: Prisma.BehavioralInteractionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BehavioralInteractionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehavioralInteractionPayload>[]
          }
          delete: {
            args: Prisma.BehavioralInteractionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehavioralInteractionPayload>
          }
          update: {
            args: Prisma.BehavioralInteractionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehavioralInteractionPayload>
          }
          deleteMany: {
            args: Prisma.BehavioralInteractionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BehavioralInteractionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BehavioralInteractionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehavioralInteractionPayload>[]
          }
          upsert: {
            args: Prisma.BehavioralInteractionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehavioralInteractionPayload>
          }
          aggregate: {
            args: Prisma.BehavioralInteractionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBehavioralInteraction>
          }
          groupBy: {
            args: Prisma.BehavioralInteractionGroupByArgs<ExtArgs>
            result: $Utils.Optional<BehavioralInteractionGroupByOutputType>[]
          }
          count: {
            args: Prisma.BehavioralInteractionCountArgs<ExtArgs>
            result: $Utils.Optional<BehavioralInteractionCountAggregateOutputType> | number
          }
        }
      }
      QuizConversion: {
        payload: Prisma.$QuizConversionPayload<ExtArgs>
        fields: Prisma.QuizConversionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizConversionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizConversionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizConversionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizConversionPayload>
          }
          findFirst: {
            args: Prisma.QuizConversionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizConversionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizConversionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizConversionPayload>
          }
          findMany: {
            args: Prisma.QuizConversionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizConversionPayload>[]
          }
          create: {
            args: Prisma.QuizConversionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizConversionPayload>
          }
          createMany: {
            args: Prisma.QuizConversionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizConversionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizConversionPayload>[]
          }
          delete: {
            args: Prisma.QuizConversionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizConversionPayload>
          }
          update: {
            args: Prisma.QuizConversionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizConversionPayload>
          }
          deleteMany: {
            args: Prisma.QuizConversionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizConversionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizConversionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizConversionPayload>[]
          }
          upsert: {
            args: Prisma.QuizConversionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizConversionPayload>
          }
          aggregate: {
            args: Prisma.QuizConversionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizConversion>
          }
          groupBy: {
            args: Prisma.QuizConversionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizConversionGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizConversionCountArgs<ExtArgs>
            result: $Utils.Optional<QuizConversionCountAggregateOutputType> | number
          }
        }
      }
      ABTestExperiment: {
        payload: Prisma.$ABTestExperimentPayload<ExtArgs>
        fields: Prisma.ABTestExperimentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ABTestExperimentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABTestExperimentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ABTestExperimentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABTestExperimentPayload>
          }
          findFirst: {
            args: Prisma.ABTestExperimentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABTestExperimentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ABTestExperimentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABTestExperimentPayload>
          }
          findMany: {
            args: Prisma.ABTestExperimentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABTestExperimentPayload>[]
          }
          create: {
            args: Prisma.ABTestExperimentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABTestExperimentPayload>
          }
          createMany: {
            args: Prisma.ABTestExperimentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ABTestExperimentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABTestExperimentPayload>[]
          }
          delete: {
            args: Prisma.ABTestExperimentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABTestExperimentPayload>
          }
          update: {
            args: Prisma.ABTestExperimentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABTestExperimentPayload>
          }
          deleteMany: {
            args: Prisma.ABTestExperimentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ABTestExperimentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ABTestExperimentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABTestExperimentPayload>[]
          }
          upsert: {
            args: Prisma.ABTestExperimentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABTestExperimentPayload>
          }
          aggregate: {
            args: Prisma.ABTestExperimentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateABTestExperiment>
          }
          groupBy: {
            args: Prisma.ABTestExperimentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ABTestExperimentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ABTestExperimentCountArgs<ExtArgs>
            result: $Utils.Optional<ABTestExperimentCountAggregateOutputType> | number
          }
        }
      }
      QuizBrand: {
        payload: Prisma.$QuizBrandPayload<ExtArgs>
        fields: Prisma.QuizBrandFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizBrandFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizBrandPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizBrandFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizBrandPayload>
          }
          findFirst: {
            args: Prisma.QuizBrandFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizBrandPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizBrandFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizBrandPayload>
          }
          findMany: {
            args: Prisma.QuizBrandFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizBrandPayload>[]
          }
          create: {
            args: Prisma.QuizBrandCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizBrandPayload>
          }
          createMany: {
            args: Prisma.QuizBrandCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizBrandCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizBrandPayload>[]
          }
          delete: {
            args: Prisma.QuizBrandDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizBrandPayload>
          }
          update: {
            args: Prisma.QuizBrandUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizBrandPayload>
          }
          deleteMany: {
            args: Prisma.QuizBrandDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizBrandUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizBrandUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizBrandPayload>[]
          }
          upsert: {
            args: Prisma.QuizBrandUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizBrandPayload>
          }
          aggregate: {
            args: Prisma.QuizBrandAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizBrand>
          }
          groupBy: {
            args: Prisma.QuizBrandGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizBrandGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizBrandCountArgs<ExtArgs>
            result: $Utils.Optional<QuizBrandCountAggregateOutputType> | number
          }
        }
      }
      QuizRoutingRule: {
        payload: Prisma.$QuizRoutingRulePayload<ExtArgs>
        fields: Prisma.QuizRoutingRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizRoutingRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizRoutingRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizRoutingRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizRoutingRulePayload>
          }
          findFirst: {
            args: Prisma.QuizRoutingRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizRoutingRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizRoutingRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizRoutingRulePayload>
          }
          findMany: {
            args: Prisma.QuizRoutingRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizRoutingRulePayload>[]
          }
          create: {
            args: Prisma.QuizRoutingRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizRoutingRulePayload>
          }
          createMany: {
            args: Prisma.QuizRoutingRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizRoutingRuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizRoutingRulePayload>[]
          }
          delete: {
            args: Prisma.QuizRoutingRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizRoutingRulePayload>
          }
          update: {
            args: Prisma.QuizRoutingRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizRoutingRulePayload>
          }
          deleteMany: {
            args: Prisma.QuizRoutingRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizRoutingRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizRoutingRuleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizRoutingRulePayload>[]
          }
          upsert: {
            args: Prisma.QuizRoutingRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizRoutingRulePayload>
          }
          aggregate: {
            args: Prisma.QuizRoutingRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizRoutingRule>
          }
          groupBy: {
            args: Prisma.QuizRoutingRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizRoutingRuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizRoutingRuleCountArgs<ExtArgs>
            result: $Utils.Optional<QuizRoutingRuleCountAggregateOutputType> | number
          }
        }
      }
      QuizIntervention: {
        payload: Prisma.$QuizInterventionPayload<ExtArgs>
        fields: Prisma.QuizInterventionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizInterventionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizInterventionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizInterventionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizInterventionPayload>
          }
          findFirst: {
            args: Prisma.QuizInterventionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizInterventionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizInterventionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizInterventionPayload>
          }
          findMany: {
            args: Prisma.QuizInterventionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizInterventionPayload>[]
          }
          create: {
            args: Prisma.QuizInterventionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizInterventionPayload>
          }
          createMany: {
            args: Prisma.QuizInterventionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizInterventionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizInterventionPayload>[]
          }
          delete: {
            args: Prisma.QuizInterventionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizInterventionPayload>
          }
          update: {
            args: Prisma.QuizInterventionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizInterventionPayload>
          }
          deleteMany: {
            args: Prisma.QuizInterventionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizInterventionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizInterventionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizInterventionPayload>[]
          }
          upsert: {
            args: Prisma.QuizInterventionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizInterventionPayload>
          }
          aggregate: {
            args: Prisma.QuizInterventionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizIntervention>
          }
          groupBy: {
            args: Prisma.QuizInterventionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizInterventionGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizInterventionCountArgs<ExtArgs>
            result: $Utils.Optional<QuizInterventionCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      ProjectStage: {
        payload: Prisma.$ProjectStagePayload<ExtArgs>
        fields: Prisma.ProjectStageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectStageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectStageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStagePayload>
          }
          findFirst: {
            args: Prisma.ProjectStageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectStageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStagePayload>
          }
          findMany: {
            args: Prisma.ProjectStageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStagePayload>[]
          }
          create: {
            args: Prisma.ProjectStageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStagePayload>
          }
          createMany: {
            args: Prisma.ProjectStageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectStageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStagePayload>[]
          }
          delete: {
            args: Prisma.ProjectStageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStagePayload>
          }
          update: {
            args: Prisma.ProjectStageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStagePayload>
          }
          deleteMany: {
            args: Prisma.ProjectStageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectStageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectStageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStagePayload>[]
          }
          upsert: {
            args: Prisma.ProjectStageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStagePayload>
          }
          aggregate: {
            args: Prisma.ProjectStageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectStage>
          }
          groupBy: {
            args: Prisma.ProjectStageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectStageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectStageCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectStageCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      DocumentGeneration: {
        payload: Prisma.$DocumentGenerationPayload<ExtArgs>
        fields: Prisma.DocumentGenerationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentGenerationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentGenerationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentGenerationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentGenerationPayload>
          }
          findFirst: {
            args: Prisma.DocumentGenerationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentGenerationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentGenerationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentGenerationPayload>
          }
          findMany: {
            args: Prisma.DocumentGenerationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentGenerationPayload>[]
          }
          create: {
            args: Prisma.DocumentGenerationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentGenerationPayload>
          }
          createMany: {
            args: Prisma.DocumentGenerationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentGenerationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentGenerationPayload>[]
          }
          delete: {
            args: Prisma.DocumentGenerationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentGenerationPayload>
          }
          update: {
            args: Prisma.DocumentGenerationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentGenerationPayload>
          }
          deleteMany: {
            args: Prisma.DocumentGenerationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentGenerationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentGenerationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentGenerationPayload>[]
          }
          upsert: {
            args: Prisma.DocumentGenerationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentGenerationPayload>
          }
          aggregate: {
            args: Prisma.DocumentGenerationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumentGeneration>
          }
          groupBy: {
            args: Prisma.DocumentGenerationGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGenerationGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentGenerationCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentGenerationCountAggregateOutputType> | number
          }
        }
      }
      Quote: {
        payload: Prisma.$QuotePayload<ExtArgs>
        fields: Prisma.QuoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          findFirst: {
            args: Prisma.QuoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          findMany: {
            args: Prisma.QuoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>[]
          }
          create: {
            args: Prisma.QuoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          createMany: {
            args: Prisma.QuoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>[]
          }
          delete: {
            args: Prisma.QuoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          update: {
            args: Prisma.QuoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          deleteMany: {
            args: Prisma.QuoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>[]
          }
          upsert: {
            args: Prisma.QuoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          aggregate: {
            args: Prisma.QuoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuote>
          }
          groupBy: {
            args: Prisma.QuoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuoteCountArgs<ExtArgs>
            result: $Utils.Optional<QuoteCountAggregateOutputType> | number
          }
        }
      }
      MaterialCost: {
        payload: Prisma.$MaterialCostPayload<ExtArgs>
        fields: Prisma.MaterialCostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaterialCostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialCostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaterialCostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialCostPayload>
          }
          findFirst: {
            args: Prisma.MaterialCostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialCostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaterialCostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialCostPayload>
          }
          findMany: {
            args: Prisma.MaterialCostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialCostPayload>[]
          }
          create: {
            args: Prisma.MaterialCostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialCostPayload>
          }
          createMany: {
            args: Prisma.MaterialCostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaterialCostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialCostPayload>[]
          }
          delete: {
            args: Prisma.MaterialCostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialCostPayload>
          }
          update: {
            args: Prisma.MaterialCostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialCostPayload>
          }
          deleteMany: {
            args: Prisma.MaterialCostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaterialCostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MaterialCostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialCostPayload>[]
          }
          upsert: {
            args: Prisma.MaterialCostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialCostPayload>
          }
          aggregate: {
            args: Prisma.MaterialCostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaterialCost>
          }
          groupBy: {
            args: Prisma.MaterialCostGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaterialCostGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaterialCostCountArgs<ExtArgs>
            result: $Utils.Optional<MaterialCostCountAggregateOutputType> | number
          }
        }
      }
      SupplierInvoice: {
        payload: Prisma.$SupplierInvoicePayload<ExtArgs>
        fields: Prisma.SupplierInvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierInvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierInvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierInvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierInvoicePayload>
          }
          findFirst: {
            args: Prisma.SupplierInvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierInvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierInvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierInvoicePayload>
          }
          findMany: {
            args: Prisma.SupplierInvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierInvoicePayload>[]
          }
          create: {
            args: Prisma.SupplierInvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierInvoicePayload>
          }
          createMany: {
            args: Prisma.SupplierInvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupplierInvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierInvoicePayload>[]
          }
          delete: {
            args: Prisma.SupplierInvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierInvoicePayload>
          }
          update: {
            args: Prisma.SupplierInvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierInvoicePayload>
          }
          deleteMany: {
            args: Prisma.SupplierInvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierInvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SupplierInvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierInvoicePayload>[]
          }
          upsert: {
            args: Prisma.SupplierInvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierInvoicePayload>
          }
          aggregate: {
            args: Prisma.SupplierInvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplierInvoice>
          }
          groupBy: {
            args: Prisma.SupplierInvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplierInvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierInvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<SupplierInvoiceCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    chatSession?: ChatSessionOmit
    message?: MessageOmit
    sessionTag?: SessionTagOmit
    mondaySync?: MondaySyncOmit
    customer?: CustomerOmit
    product?: ProductOmit
    order?: OrderOmit
    orderItem?: OrderItemOmit
    subscription?: SubscriptionOmit
    subscriptionPlan?: SubscriptionPlanOmit
    invoice?: InvoiceOmit
    paymentMethod?: PaymentMethodOmit
    inventory?: InventoryOmit
    cart?: CartOmit
    cartItem?: CartItemOmit
    priceHistory?: PriceHistoryOmit
    systemHealth?: SystemHealthOmit
    notification?: NotificationOmit
    analyticsEvent?: AnalyticsEventOmit
    analyticsSession?: AnalyticsSessionOmit
    analyticsMetric?: AnalyticsMetricOmit
    analyticsCohort?: AnalyticsCohortOmit
    analyticsFunnel?: AnalyticsFunnelOmit
    analyticsAttribution?: AnalyticsAttributionOmit
    analyticsSegment?: AnalyticsSegmentOmit
    analyticsReport?: AnalyticsReportOmit
    quizSession?: QuizSessionOmit
    quizResponse?: QuizResponseOmit
    behavioralInteraction?: BehavioralInteractionOmit
    quizConversion?: QuizConversionOmit
    aBTestExperiment?: ABTestExperimentOmit
    quizBrand?: QuizBrandOmit
    quizRoutingRule?: QuizRoutingRuleOmit
    quizIntervention?: QuizInterventionOmit
    service?: ServiceOmit
    project?: ProjectOmit
    projectStage?: ProjectStageOmit
    document?: DocumentOmit
    documentGeneration?: DocumentGenerationOmit
    quote?: QuoteOmit
    materialCost?: MaterialCostOmit
    supplierInvoice?: SupplierInvoiceOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sessions: number
    messages: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    messages?: boolean | UserCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Count Type ChatSessionCountOutputType
   */

  export type ChatSessionCountOutputType = {
    messages: number
    tags: number
  }

  export type ChatSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ChatSessionCountOutputTypeCountMessagesArgs
    tags?: boolean | ChatSessionCountOutputTypeCountTagsArgs
  }

  // Custom InputTypes
  /**
   * ChatSessionCountOutputType without action
   */
  export type ChatSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSessionCountOutputType
     */
    select?: ChatSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChatSessionCountOutputType without action
   */
  export type ChatSessionCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * ChatSessionCountOutputType without action
   */
  export type ChatSessionCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionTagWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    paymentMethods: number
    orders: number
    subscriptions: number
    invoices: number
    projects: number
    quotes: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paymentMethods?: boolean | CustomerCountOutputTypeCountPaymentMethodsArgs
    orders?: boolean | CustomerCountOutputTypeCountOrdersArgs
    subscriptions?: boolean | CustomerCountOutputTypeCountSubscriptionsArgs
    invoices?: boolean | CustomerCountOutputTypeCountInvoicesArgs
    projects?: boolean | CustomerCountOutputTypeCountProjectsArgs
    quotes?: boolean | CustomerCountOutputTypeCountQuotesArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountPaymentMethodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentMethodWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountQuotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    inventoryItems: number
    orderItems: number
    cartItems: number
    priceHistory: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryItems?: boolean | ProductCountOutputTypeCountInventoryItemsArgs
    orderItems?: boolean | ProductCountOutputTypeCountOrderItemsArgs
    cartItems?: boolean | ProductCountOutputTypeCountCartItemsArgs
    priceHistory?: boolean | ProductCountOutputTypeCountPriceHistoryArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountInventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountCartItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountPriceHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PriceHistoryWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    items: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | OrderCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }


  /**
   * Count Type SubscriptionCountOutputType
   */

  export type SubscriptionCountOutputType = {
    invoices: number
  }

  export type SubscriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | SubscriptionCountOutputTypeCountInvoicesArgs
  }

  // Custom InputTypes
  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionCountOutputType
     */
    select?: SubscriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }


  /**
   * Count Type SubscriptionPlanCountOutputType
   */

  export type SubscriptionPlanCountOutputType = {
    subscriptions: number
  }

  export type SubscriptionPlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | SubscriptionPlanCountOutputTypeCountSubscriptionsArgs
  }

  // Custom InputTypes
  /**
   * SubscriptionPlanCountOutputType without action
   */
  export type SubscriptionPlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlanCountOutputType
     */
    select?: SubscriptionPlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubscriptionPlanCountOutputType without action
   */
  export type SubscriptionPlanCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }


  /**
   * Count Type CartCountOutputType
   */

  export type CartCountOutputType = {
    items: number
  }

  export type CartCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | CartCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * CartCountOutputType without action
   */
  export type CartCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartCountOutputType
     */
    select?: CartCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CartCountOutputType without action
   */
  export type CartCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartItemWhereInput
  }


  /**
   * Count Type QuizSessionCountOutputType
   */

  export type QuizSessionCountOutputType = {
    responses: number
    interactions: number
    conversions: number
  }

  export type QuizSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responses?: boolean | QuizSessionCountOutputTypeCountResponsesArgs
    interactions?: boolean | QuizSessionCountOutputTypeCountInteractionsArgs
    conversions?: boolean | QuizSessionCountOutputTypeCountConversionsArgs
  }

  // Custom InputTypes
  /**
   * QuizSessionCountOutputType without action
   */
  export type QuizSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSessionCountOutputType
     */
    select?: QuizSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuizSessionCountOutputType without action
   */
  export type QuizSessionCountOutputTypeCountResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizResponseWhereInput
  }

  /**
   * QuizSessionCountOutputType without action
   */
  export type QuizSessionCountOutputTypeCountInteractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BehavioralInteractionWhereInput
  }

  /**
   * QuizSessionCountOutputType without action
   */
  export type QuizSessionCountOutputTypeCountConversionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizConversionWhereInput
  }


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    projects: number
    quotes: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | ServiceCountOutputTypeCountProjectsArgs
    quotes?: boolean | ServiceCountOutputTypeCountQuotesArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountQuotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    documents: number
    stages: number
    costs: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documents?: boolean | ProjectCountOutputTypeCountDocumentsArgs
    stages?: boolean | ProjectCountOutputTypeCountStagesArgs
    costs?: boolean | ProjectCountOutputTypeCountCostsArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountStagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectStageWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountCostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialCostWhereInput
  }


  /**
   * Count Type DocumentCountOutputType
   */

  export type DocumentCountOutputType = {
    generations: number
  }

  export type DocumentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    generations?: boolean | DocumentCountOutputTypeCountGenerationsArgs
  }

  // Custom InputTypes
  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentCountOutputType
     */
    select?: DocumentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeCountGenerationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentGenerationWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    role: string | null
    externalId: string | null
    mondayUserId: string | null
    copilotUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    role: string | null
    externalId: string | null
    mondayUserId: string | null
    copilotUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    password: number
    role: number
    externalId: number
    mondayUserId: number
    copilotUserId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    role?: true
    externalId?: true
    mondayUserId?: true
    copilotUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    role?: true
    externalId?: true
    mondayUserId?: true
    copilotUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    role?: true
    externalId?: true
    mondayUserId?: true
    copilotUserId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string | null
    name: string | null
    password: string | null
    role: string
    externalId: string | null
    mondayUserId: string | null
    copilotUserId: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    role?: boolean
    externalId?: boolean
    mondayUserId?: boolean
    copilotUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    messages?: boolean | User$messagesArgs<ExtArgs>
    customer?: boolean | User$customerArgs<ExtArgs>
    cart?: boolean | User$cartArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    role?: boolean
    externalId?: boolean
    mondayUserId?: boolean
    copilotUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    role?: boolean
    externalId?: boolean
    mondayUserId?: boolean
    copilotUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    role?: boolean
    externalId?: boolean
    mondayUserId?: boolean
    copilotUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "password" | "role" | "externalId" | "mondayUserId" | "copilotUserId" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    messages?: boolean | User$messagesArgs<ExtArgs>
    customer?: boolean | User$customerArgs<ExtArgs>
    cart?: boolean | User$cartArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      sessions: Prisma.$ChatSessionPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      cart: Prisma.$CartPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string | null
      name: string | null
      password: string | null
      role: string
      externalId: string | null
      mondayUserId: string | null
      copilotUserId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages<T extends User$messagesArgs<ExtArgs> = {}>(args?: Subset<T, User$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customer<T extends User$customerArgs<ExtArgs> = {}>(args?: Subset<T, User$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    cart<T extends User$cartArgs<ExtArgs> = {}>(args?: Subset<T, User$cartArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly externalId: FieldRef<"User", 'String'>
    readonly mondayUserId: FieldRef<"User", 'String'>
    readonly copilotUserId: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    where?: ChatSessionWhereInput
    orderBy?: ChatSessionOrderByWithRelationInput | ChatSessionOrderByWithRelationInput[]
    cursor?: ChatSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatSessionScalarFieldEnum | ChatSessionScalarFieldEnum[]
  }

  /**
   * User.messages
   */
  export type User$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.customer
   */
  export type User$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * User.cart
   */
  export type User$cartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    where?: CartWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model ChatSession
   */

  export type AggregateChatSession = {
    _count: ChatSessionCountAggregateOutputType | null
    _min: ChatSessionMinAggregateOutputType | null
    _max: ChatSessionMaxAggregateOutputType | null
  }

  export type ChatSessionMinAggregateOutputType = {
    id: string | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
    systemPrompt: string | null
    isActive: boolean | null
    userId: string | null
    userName: string | null
    userEmail: string | null
    ipAddress: string | null
    location: string | null
    source: string | null
    category: string | null
    mondayItemId: string | null
    mondaySynced: boolean | null
    copilotSynced: boolean | null
    databaseSynced: boolean | null
    lastMondaySync: Date | null
    lastCopilotSync: Date | null
  }

  export type ChatSessionMaxAggregateOutputType = {
    id: string | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
    systemPrompt: string | null
    isActive: boolean | null
    userId: string | null
    userName: string | null
    userEmail: string | null
    ipAddress: string | null
    location: string | null
    source: string | null
    category: string | null
    mondayItemId: string | null
    mondaySynced: boolean | null
    copilotSynced: boolean | null
    databaseSynced: boolean | null
    lastMondaySync: Date | null
    lastCopilotSync: Date | null
  }

  export type ChatSessionCountAggregateOutputType = {
    id: number
    title: number
    createdAt: number
    updatedAt: number
    systemPrompt: number
    isActive: number
    userId: number
    userName: number
    userEmail: number
    ipAddress: number
    location: number
    source: number
    category: number
    mondayItemId: number
    mondaySynced: number
    copilotSynced: number
    databaseSynced: number
    lastMondaySync: number
    lastCopilotSync: number
    _all: number
  }


  export type ChatSessionMinAggregateInputType = {
    id?: true
    title?: true
    createdAt?: true
    updatedAt?: true
    systemPrompt?: true
    isActive?: true
    userId?: true
    userName?: true
    userEmail?: true
    ipAddress?: true
    location?: true
    source?: true
    category?: true
    mondayItemId?: true
    mondaySynced?: true
    copilotSynced?: true
    databaseSynced?: true
    lastMondaySync?: true
    lastCopilotSync?: true
  }

  export type ChatSessionMaxAggregateInputType = {
    id?: true
    title?: true
    createdAt?: true
    updatedAt?: true
    systemPrompt?: true
    isActive?: true
    userId?: true
    userName?: true
    userEmail?: true
    ipAddress?: true
    location?: true
    source?: true
    category?: true
    mondayItemId?: true
    mondaySynced?: true
    copilotSynced?: true
    databaseSynced?: true
    lastMondaySync?: true
    lastCopilotSync?: true
  }

  export type ChatSessionCountAggregateInputType = {
    id?: true
    title?: true
    createdAt?: true
    updatedAt?: true
    systemPrompt?: true
    isActive?: true
    userId?: true
    userName?: true
    userEmail?: true
    ipAddress?: true
    location?: true
    source?: true
    category?: true
    mondayItemId?: true
    mondaySynced?: true
    copilotSynced?: true
    databaseSynced?: true
    lastMondaySync?: true
    lastCopilotSync?: true
    _all?: true
  }

  export type ChatSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatSession to aggregate.
     */
    where?: ChatSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatSessions to fetch.
     */
    orderBy?: ChatSessionOrderByWithRelationInput | ChatSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatSessions
    **/
    _count?: true | ChatSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatSessionMaxAggregateInputType
  }

  export type GetChatSessionAggregateType<T extends ChatSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateChatSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatSession[P]>
      : GetScalarType<T[P], AggregateChatSession[P]>
  }




  export type ChatSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatSessionWhereInput
    orderBy?: ChatSessionOrderByWithAggregationInput | ChatSessionOrderByWithAggregationInput[]
    by: ChatSessionScalarFieldEnum[] | ChatSessionScalarFieldEnum
    having?: ChatSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatSessionCountAggregateInputType | true
    _min?: ChatSessionMinAggregateInputType
    _max?: ChatSessionMaxAggregateInputType
  }

  export type ChatSessionGroupByOutputType = {
    id: string
    title: string
    createdAt: Date
    updatedAt: Date
    systemPrompt: string | null
    isActive: boolean
    userId: string | null
    userName: string | null
    userEmail: string | null
    ipAddress: string | null
    location: string | null
    source: string | null
    category: string | null
    mondayItemId: string | null
    mondaySynced: boolean
    copilotSynced: boolean
    databaseSynced: boolean
    lastMondaySync: Date | null
    lastCopilotSync: Date | null
    _count: ChatSessionCountAggregateOutputType | null
    _min: ChatSessionMinAggregateOutputType | null
    _max: ChatSessionMaxAggregateOutputType | null
  }

  type GetChatSessionGroupByPayload<T extends ChatSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatSessionGroupByOutputType[P]>
            : GetScalarType<T[P], ChatSessionGroupByOutputType[P]>
        }
      >
    >


  export type ChatSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    systemPrompt?: boolean
    isActive?: boolean
    userId?: boolean
    userName?: boolean
    userEmail?: boolean
    ipAddress?: boolean
    location?: boolean
    source?: boolean
    category?: boolean
    mondayItemId?: boolean
    mondaySynced?: boolean
    copilotSynced?: boolean
    databaseSynced?: boolean
    lastMondaySync?: boolean
    lastCopilotSync?: boolean
    user?: boolean | ChatSession$userArgs<ExtArgs>
    messages?: boolean | ChatSession$messagesArgs<ExtArgs>
    tags?: boolean | ChatSession$tagsArgs<ExtArgs>
    _count?: boolean | ChatSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatSession"]>

  export type ChatSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    systemPrompt?: boolean
    isActive?: boolean
    userId?: boolean
    userName?: boolean
    userEmail?: boolean
    ipAddress?: boolean
    location?: boolean
    source?: boolean
    category?: boolean
    mondayItemId?: boolean
    mondaySynced?: boolean
    copilotSynced?: boolean
    databaseSynced?: boolean
    lastMondaySync?: boolean
    lastCopilotSync?: boolean
    user?: boolean | ChatSession$userArgs<ExtArgs>
  }, ExtArgs["result"]["chatSession"]>

  export type ChatSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    systemPrompt?: boolean
    isActive?: boolean
    userId?: boolean
    userName?: boolean
    userEmail?: boolean
    ipAddress?: boolean
    location?: boolean
    source?: boolean
    category?: boolean
    mondayItemId?: boolean
    mondaySynced?: boolean
    copilotSynced?: boolean
    databaseSynced?: boolean
    lastMondaySync?: boolean
    lastCopilotSync?: boolean
    user?: boolean | ChatSession$userArgs<ExtArgs>
  }, ExtArgs["result"]["chatSession"]>

  export type ChatSessionSelectScalar = {
    id?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    systemPrompt?: boolean
    isActive?: boolean
    userId?: boolean
    userName?: boolean
    userEmail?: boolean
    ipAddress?: boolean
    location?: boolean
    source?: boolean
    category?: boolean
    mondayItemId?: boolean
    mondaySynced?: boolean
    copilotSynced?: boolean
    databaseSynced?: boolean
    lastMondaySync?: boolean
    lastCopilotSync?: boolean
  }

  export type ChatSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "createdAt" | "updatedAt" | "systemPrompt" | "isActive" | "userId" | "userName" | "userEmail" | "ipAddress" | "location" | "source" | "category" | "mondayItemId" | "mondaySynced" | "copilotSynced" | "databaseSynced" | "lastMondaySync" | "lastCopilotSync", ExtArgs["result"]["chatSession"]>
  export type ChatSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ChatSession$userArgs<ExtArgs>
    messages?: boolean | ChatSession$messagesArgs<ExtArgs>
    tags?: boolean | ChatSession$tagsArgs<ExtArgs>
    _count?: boolean | ChatSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChatSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ChatSession$userArgs<ExtArgs>
  }
  export type ChatSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ChatSession$userArgs<ExtArgs>
  }

  export type $ChatSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      messages: Prisma.$MessagePayload<ExtArgs>[]
      tags: Prisma.$SessionTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      createdAt: Date
      updatedAt: Date
      systemPrompt: string | null
      isActive: boolean
      userId: string | null
      userName: string | null
      userEmail: string | null
      ipAddress: string | null
      location: string | null
      source: string | null
      category: string | null
      mondayItemId: string | null
      mondaySynced: boolean
      copilotSynced: boolean
      databaseSynced: boolean
      lastMondaySync: Date | null
      lastCopilotSync: Date | null
    }, ExtArgs["result"]["chatSession"]>
    composites: {}
  }

  type ChatSessionGetPayload<S extends boolean | null | undefined | ChatSessionDefaultArgs> = $Result.GetResult<Prisma.$ChatSessionPayload, S>

  type ChatSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatSessionCountAggregateInputType | true
    }

  export interface ChatSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatSession'], meta: { name: 'ChatSession' } }
    /**
     * Find zero or one ChatSession that matches the filter.
     * @param {ChatSessionFindUniqueArgs} args - Arguments to find a ChatSession
     * @example
     * // Get one ChatSession
     * const chatSession = await prisma.chatSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatSessionFindUniqueArgs>(args: SelectSubset<T, ChatSessionFindUniqueArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChatSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatSessionFindUniqueOrThrowArgs} args - Arguments to find a ChatSession
     * @example
     * // Get one ChatSession
     * const chatSession = await prisma.chatSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionFindFirstArgs} args - Arguments to find a ChatSession
     * @example
     * // Get one ChatSession
     * const chatSession = await prisma.chatSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatSessionFindFirstArgs>(args?: SelectSubset<T, ChatSessionFindFirstArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionFindFirstOrThrowArgs} args - Arguments to find a ChatSession
     * @example
     * // Get one ChatSession
     * const chatSession = await prisma.chatSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChatSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatSessions
     * const chatSessions = await prisma.chatSession.findMany()
     * 
     * // Get first 10 ChatSessions
     * const chatSessions = await prisma.chatSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatSessionWithIdOnly = await prisma.chatSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatSessionFindManyArgs>(args?: SelectSubset<T, ChatSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChatSession.
     * @param {ChatSessionCreateArgs} args - Arguments to create a ChatSession.
     * @example
     * // Create one ChatSession
     * const ChatSession = await prisma.chatSession.create({
     *   data: {
     *     // ... data to create a ChatSession
     *   }
     * })
     * 
     */
    create<T extends ChatSessionCreateArgs>(args: SelectSubset<T, ChatSessionCreateArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChatSessions.
     * @param {ChatSessionCreateManyArgs} args - Arguments to create many ChatSessions.
     * @example
     * // Create many ChatSessions
     * const chatSession = await prisma.chatSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatSessionCreateManyArgs>(args?: SelectSubset<T, ChatSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatSessions and returns the data saved in the database.
     * @param {ChatSessionCreateManyAndReturnArgs} args - Arguments to create many ChatSessions.
     * @example
     * // Create many ChatSessions
     * const chatSession = await prisma.chatSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatSessions and only return the `id`
     * const chatSessionWithIdOnly = await prisma.chatSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChatSession.
     * @param {ChatSessionDeleteArgs} args - Arguments to delete one ChatSession.
     * @example
     * // Delete one ChatSession
     * const ChatSession = await prisma.chatSession.delete({
     *   where: {
     *     // ... filter to delete one ChatSession
     *   }
     * })
     * 
     */
    delete<T extends ChatSessionDeleteArgs>(args: SelectSubset<T, ChatSessionDeleteArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChatSession.
     * @param {ChatSessionUpdateArgs} args - Arguments to update one ChatSession.
     * @example
     * // Update one ChatSession
     * const chatSession = await prisma.chatSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatSessionUpdateArgs>(args: SelectSubset<T, ChatSessionUpdateArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChatSessions.
     * @param {ChatSessionDeleteManyArgs} args - Arguments to filter ChatSessions to delete.
     * @example
     * // Delete a few ChatSessions
     * const { count } = await prisma.chatSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatSessionDeleteManyArgs>(args?: SelectSubset<T, ChatSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatSessions
     * const chatSession = await prisma.chatSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatSessionUpdateManyArgs>(args: SelectSubset<T, ChatSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatSessions and returns the data updated in the database.
     * @param {ChatSessionUpdateManyAndReturnArgs} args - Arguments to update many ChatSessions.
     * @example
     * // Update many ChatSessions
     * const chatSession = await prisma.chatSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChatSessions and only return the `id`
     * const chatSessionWithIdOnly = await prisma.chatSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChatSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, ChatSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChatSession.
     * @param {ChatSessionUpsertArgs} args - Arguments to update or create a ChatSession.
     * @example
     * // Update or create a ChatSession
     * const chatSession = await prisma.chatSession.upsert({
     *   create: {
     *     // ... data to create a ChatSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatSession we want to update
     *   }
     * })
     */
    upsert<T extends ChatSessionUpsertArgs>(args: SelectSubset<T, ChatSessionUpsertArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChatSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionCountArgs} args - Arguments to filter ChatSessions to count.
     * @example
     * // Count the number of ChatSessions
     * const count = await prisma.chatSession.count({
     *   where: {
     *     // ... the filter for the ChatSessions we want to count
     *   }
     * })
    **/
    count<T extends ChatSessionCountArgs>(
      args?: Subset<T, ChatSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatSessionAggregateArgs>(args: Subset<T, ChatSessionAggregateArgs>): Prisma.PrismaPromise<GetChatSessionAggregateType<T>>

    /**
     * Group by ChatSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatSessionGroupByArgs['orderBy'] }
        : { orderBy?: ChatSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatSession model
   */
  readonly fields: ChatSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends ChatSession$userArgs<ExtArgs> = {}>(args?: Subset<T, ChatSession$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    messages<T extends ChatSession$messagesArgs<ExtArgs> = {}>(args?: Subset<T, ChatSession$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends ChatSession$tagsArgs<ExtArgs> = {}>(args?: Subset<T, ChatSession$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatSession model
   */
  interface ChatSessionFieldRefs {
    readonly id: FieldRef<"ChatSession", 'String'>
    readonly title: FieldRef<"ChatSession", 'String'>
    readonly createdAt: FieldRef<"ChatSession", 'DateTime'>
    readonly updatedAt: FieldRef<"ChatSession", 'DateTime'>
    readonly systemPrompt: FieldRef<"ChatSession", 'String'>
    readonly isActive: FieldRef<"ChatSession", 'Boolean'>
    readonly userId: FieldRef<"ChatSession", 'String'>
    readonly userName: FieldRef<"ChatSession", 'String'>
    readonly userEmail: FieldRef<"ChatSession", 'String'>
    readonly ipAddress: FieldRef<"ChatSession", 'String'>
    readonly location: FieldRef<"ChatSession", 'String'>
    readonly source: FieldRef<"ChatSession", 'String'>
    readonly category: FieldRef<"ChatSession", 'String'>
    readonly mondayItemId: FieldRef<"ChatSession", 'String'>
    readonly mondaySynced: FieldRef<"ChatSession", 'Boolean'>
    readonly copilotSynced: FieldRef<"ChatSession", 'Boolean'>
    readonly databaseSynced: FieldRef<"ChatSession", 'Boolean'>
    readonly lastMondaySync: FieldRef<"ChatSession", 'DateTime'>
    readonly lastCopilotSync: FieldRef<"ChatSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChatSession findUnique
   */
  export type ChatSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * Filter, which ChatSession to fetch.
     */
    where: ChatSessionWhereUniqueInput
  }

  /**
   * ChatSession findUniqueOrThrow
   */
  export type ChatSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * Filter, which ChatSession to fetch.
     */
    where: ChatSessionWhereUniqueInput
  }

  /**
   * ChatSession findFirst
   */
  export type ChatSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * Filter, which ChatSession to fetch.
     */
    where?: ChatSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatSessions to fetch.
     */
    orderBy?: ChatSessionOrderByWithRelationInput | ChatSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatSessions.
     */
    cursor?: ChatSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatSessions.
     */
    distinct?: ChatSessionScalarFieldEnum | ChatSessionScalarFieldEnum[]
  }

  /**
   * ChatSession findFirstOrThrow
   */
  export type ChatSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * Filter, which ChatSession to fetch.
     */
    where?: ChatSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatSessions to fetch.
     */
    orderBy?: ChatSessionOrderByWithRelationInput | ChatSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatSessions.
     */
    cursor?: ChatSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatSessions.
     */
    distinct?: ChatSessionScalarFieldEnum | ChatSessionScalarFieldEnum[]
  }

  /**
   * ChatSession findMany
   */
  export type ChatSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * Filter, which ChatSessions to fetch.
     */
    where?: ChatSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatSessions to fetch.
     */
    orderBy?: ChatSessionOrderByWithRelationInput | ChatSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatSessions.
     */
    cursor?: ChatSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatSessions.
     */
    skip?: number
    distinct?: ChatSessionScalarFieldEnum | ChatSessionScalarFieldEnum[]
  }

  /**
   * ChatSession create
   */
  export type ChatSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatSession.
     */
    data: XOR<ChatSessionCreateInput, ChatSessionUncheckedCreateInput>
  }

  /**
   * ChatSession createMany
   */
  export type ChatSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatSessions.
     */
    data: ChatSessionCreateManyInput | ChatSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatSession createManyAndReturn
   */
  export type ChatSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * The data used to create many ChatSessions.
     */
    data: ChatSessionCreateManyInput | ChatSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatSession update
   */
  export type ChatSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatSession.
     */
    data: XOR<ChatSessionUpdateInput, ChatSessionUncheckedUpdateInput>
    /**
     * Choose, which ChatSession to update.
     */
    where: ChatSessionWhereUniqueInput
  }

  /**
   * ChatSession updateMany
   */
  export type ChatSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatSessions.
     */
    data: XOR<ChatSessionUpdateManyMutationInput, ChatSessionUncheckedUpdateManyInput>
    /**
     * Filter which ChatSessions to update
     */
    where?: ChatSessionWhereInput
    /**
     * Limit how many ChatSessions to update.
     */
    limit?: number
  }

  /**
   * ChatSession updateManyAndReturn
   */
  export type ChatSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * The data used to update ChatSessions.
     */
    data: XOR<ChatSessionUpdateManyMutationInput, ChatSessionUncheckedUpdateManyInput>
    /**
     * Filter which ChatSessions to update
     */
    where?: ChatSessionWhereInput
    /**
     * Limit how many ChatSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatSession upsert
   */
  export type ChatSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatSession to update in case it exists.
     */
    where: ChatSessionWhereUniqueInput
    /**
     * In case the ChatSession found by the `where` argument doesn't exist, create a new ChatSession with this data.
     */
    create: XOR<ChatSessionCreateInput, ChatSessionUncheckedCreateInput>
    /**
     * In case the ChatSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatSessionUpdateInput, ChatSessionUncheckedUpdateInput>
  }

  /**
   * ChatSession delete
   */
  export type ChatSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * Filter which ChatSession to delete.
     */
    where: ChatSessionWhereUniqueInput
  }

  /**
   * ChatSession deleteMany
   */
  export type ChatSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatSessions to delete
     */
    where?: ChatSessionWhereInput
    /**
     * Limit how many ChatSessions to delete.
     */
    limit?: number
  }

  /**
   * ChatSession.user
   */
  export type ChatSession$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ChatSession.messages
   */
  export type ChatSession$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * ChatSession.tags
   */
  export type ChatSession$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTag
     */
    select?: SessionTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTag
     */
    omit?: SessionTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTagInclude<ExtArgs> | null
    where?: SessionTagWhereInput
    orderBy?: SessionTagOrderByWithRelationInput | SessionTagOrderByWithRelationInput[]
    cursor?: SessionTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionTagScalarFieldEnum | SessionTagScalarFieldEnum[]
  }

  /**
   * ChatSession without action
   */
  export type ChatSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    role: string | null
    content: string | null
    timestamp: Date | null
    isError: boolean | null
    userId: string | null
    functionName: string | null
    functionArgs: string | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    role: string | null
    content: string | null
    timestamp: Date | null
    isError: boolean | null
    userId: string | null
    functionName: string | null
    functionArgs: string | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    sessionId: number
    role: number
    content: number
    timestamp: number
    isError: number
    userId: number
    functionName: number
    functionArgs: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    sessionId?: true
    role?: true
    content?: true
    timestamp?: true
    isError?: true
    userId?: true
    functionName?: true
    functionArgs?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    sessionId?: true
    role?: true
    content?: true
    timestamp?: true
    isError?: true
    userId?: true
    functionName?: true
    functionArgs?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    sessionId?: true
    role?: true
    content?: true
    timestamp?: true
    isError?: true
    userId?: true
    functionName?: true
    functionArgs?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    sessionId: string
    role: string
    content: string
    timestamp: Date
    isError: boolean | null
    userId: string | null
    functionName: string | null
    functionArgs: string | null
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    role?: boolean
    content?: boolean
    timestamp?: boolean
    isError?: boolean
    userId?: boolean
    functionName?: boolean
    functionArgs?: boolean
    session?: boolean | ChatSessionDefaultArgs<ExtArgs>
    user?: boolean | Message$userArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    role?: boolean
    content?: boolean
    timestamp?: boolean
    isError?: boolean
    userId?: boolean
    functionName?: boolean
    functionArgs?: boolean
    session?: boolean | ChatSessionDefaultArgs<ExtArgs>
    user?: boolean | Message$userArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    role?: boolean
    content?: boolean
    timestamp?: boolean
    isError?: boolean
    userId?: boolean
    functionName?: boolean
    functionArgs?: boolean
    session?: boolean | ChatSessionDefaultArgs<ExtArgs>
    user?: boolean | Message$userArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    sessionId?: boolean
    role?: boolean
    content?: boolean
    timestamp?: boolean
    isError?: boolean
    userId?: boolean
    functionName?: boolean
    functionArgs?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "role" | "content" | "timestamp" | "isError" | "userId" | "functionName" | "functionArgs", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | ChatSessionDefaultArgs<ExtArgs>
    user?: boolean | Message$userArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | ChatSessionDefaultArgs<ExtArgs>
    user?: boolean | Message$userArgs<ExtArgs>
  }
  export type MessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | ChatSessionDefaultArgs<ExtArgs>
    user?: boolean | Message$userArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      session: Prisma.$ChatSessionPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      role: string
      content: string
      timestamp: Date
      isError: boolean | null
      userId: string | null
      functionName: string | null
      functionArgs: string | null
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends ChatSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChatSessionDefaultArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends Message$userArgs<ExtArgs> = {}>(args?: Subset<T, Message$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly sessionId: FieldRef<"Message", 'String'>
    readonly role: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly timestamp: FieldRef<"Message", 'DateTime'>
    readonly isError: FieldRef<"Message", 'Boolean'>
    readonly userId: FieldRef<"Message", 'String'>
    readonly functionName: FieldRef<"Message", 'String'>
    readonly functionArgs: FieldRef<"Message", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message.user
   */
  export type Message$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model SessionTag
   */

  export type AggregateSessionTag = {
    _count: SessionTagCountAggregateOutputType | null
    _min: SessionTagMinAggregateOutputType | null
    _max: SessionTagMaxAggregateOutputType | null
  }

  export type SessionTagMinAggregateOutputType = {
    id: string | null
    name: string | null
    sessionId: string | null
  }

  export type SessionTagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    sessionId: string | null
  }

  export type SessionTagCountAggregateOutputType = {
    id: number
    name: number
    sessionId: number
    _all: number
  }


  export type SessionTagMinAggregateInputType = {
    id?: true
    name?: true
    sessionId?: true
  }

  export type SessionTagMaxAggregateInputType = {
    id?: true
    name?: true
    sessionId?: true
  }

  export type SessionTagCountAggregateInputType = {
    id?: true
    name?: true
    sessionId?: true
    _all?: true
  }

  export type SessionTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionTag to aggregate.
     */
    where?: SessionTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionTags to fetch.
     */
    orderBy?: SessionTagOrderByWithRelationInput | SessionTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SessionTags
    **/
    _count?: true | SessionTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionTagMaxAggregateInputType
  }

  export type GetSessionTagAggregateType<T extends SessionTagAggregateArgs> = {
        [P in keyof T & keyof AggregateSessionTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessionTag[P]>
      : GetScalarType<T[P], AggregateSessionTag[P]>
  }




  export type SessionTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionTagWhereInput
    orderBy?: SessionTagOrderByWithAggregationInput | SessionTagOrderByWithAggregationInput[]
    by: SessionTagScalarFieldEnum[] | SessionTagScalarFieldEnum
    having?: SessionTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionTagCountAggregateInputType | true
    _min?: SessionTagMinAggregateInputType
    _max?: SessionTagMaxAggregateInputType
  }

  export type SessionTagGroupByOutputType = {
    id: string
    name: string
    sessionId: string
    _count: SessionTagCountAggregateOutputType | null
    _min: SessionTagMinAggregateOutputType | null
    _max: SessionTagMaxAggregateOutputType | null
  }

  type GetSessionTagGroupByPayload<T extends SessionTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionTagGroupByOutputType[P]>
            : GetScalarType<T[P], SessionTagGroupByOutputType[P]>
        }
      >
    >


  export type SessionTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    sessionId?: boolean
    session?: boolean | ChatSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionTag"]>

  export type SessionTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    sessionId?: boolean
    session?: boolean | ChatSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionTag"]>

  export type SessionTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    sessionId?: boolean
    session?: boolean | ChatSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionTag"]>

  export type SessionTagSelectScalar = {
    id?: boolean
    name?: boolean
    sessionId?: boolean
  }

  export type SessionTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "sessionId", ExtArgs["result"]["sessionTag"]>
  export type SessionTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | ChatSessionDefaultArgs<ExtArgs>
  }
  export type SessionTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | ChatSessionDefaultArgs<ExtArgs>
  }
  export type SessionTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | ChatSessionDefaultArgs<ExtArgs>
  }

  export type $SessionTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SessionTag"
    objects: {
      session: Prisma.$ChatSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      sessionId: string
    }, ExtArgs["result"]["sessionTag"]>
    composites: {}
  }

  type SessionTagGetPayload<S extends boolean | null | undefined | SessionTagDefaultArgs> = $Result.GetResult<Prisma.$SessionTagPayload, S>

  type SessionTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionTagCountAggregateInputType | true
    }

  export interface SessionTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SessionTag'], meta: { name: 'SessionTag' } }
    /**
     * Find zero or one SessionTag that matches the filter.
     * @param {SessionTagFindUniqueArgs} args - Arguments to find a SessionTag
     * @example
     * // Get one SessionTag
     * const sessionTag = await prisma.sessionTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionTagFindUniqueArgs>(args: SelectSubset<T, SessionTagFindUniqueArgs<ExtArgs>>): Prisma__SessionTagClient<$Result.GetResult<Prisma.$SessionTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SessionTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionTagFindUniqueOrThrowArgs} args - Arguments to find a SessionTag
     * @example
     * // Get one SessionTag
     * const sessionTag = await prisma.sessionTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionTagFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionTagClient<$Result.GetResult<Prisma.$SessionTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SessionTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionTagFindFirstArgs} args - Arguments to find a SessionTag
     * @example
     * // Get one SessionTag
     * const sessionTag = await prisma.sessionTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionTagFindFirstArgs>(args?: SelectSubset<T, SessionTagFindFirstArgs<ExtArgs>>): Prisma__SessionTagClient<$Result.GetResult<Prisma.$SessionTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SessionTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionTagFindFirstOrThrowArgs} args - Arguments to find a SessionTag
     * @example
     * // Get one SessionTag
     * const sessionTag = await prisma.sessionTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionTagFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionTagClient<$Result.GetResult<Prisma.$SessionTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SessionTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SessionTags
     * const sessionTags = await prisma.sessionTag.findMany()
     * 
     * // Get first 10 SessionTags
     * const sessionTags = await prisma.sessionTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionTagWithIdOnly = await prisma.sessionTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionTagFindManyArgs>(args?: SelectSubset<T, SessionTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SessionTag.
     * @param {SessionTagCreateArgs} args - Arguments to create a SessionTag.
     * @example
     * // Create one SessionTag
     * const SessionTag = await prisma.sessionTag.create({
     *   data: {
     *     // ... data to create a SessionTag
     *   }
     * })
     * 
     */
    create<T extends SessionTagCreateArgs>(args: SelectSubset<T, SessionTagCreateArgs<ExtArgs>>): Prisma__SessionTagClient<$Result.GetResult<Prisma.$SessionTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SessionTags.
     * @param {SessionTagCreateManyArgs} args - Arguments to create many SessionTags.
     * @example
     * // Create many SessionTags
     * const sessionTag = await prisma.sessionTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionTagCreateManyArgs>(args?: SelectSubset<T, SessionTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SessionTags and returns the data saved in the database.
     * @param {SessionTagCreateManyAndReturnArgs} args - Arguments to create many SessionTags.
     * @example
     * // Create many SessionTags
     * const sessionTag = await prisma.sessionTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SessionTags and only return the `id`
     * const sessionTagWithIdOnly = await prisma.sessionTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionTagCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SessionTag.
     * @param {SessionTagDeleteArgs} args - Arguments to delete one SessionTag.
     * @example
     * // Delete one SessionTag
     * const SessionTag = await prisma.sessionTag.delete({
     *   where: {
     *     // ... filter to delete one SessionTag
     *   }
     * })
     * 
     */
    delete<T extends SessionTagDeleteArgs>(args: SelectSubset<T, SessionTagDeleteArgs<ExtArgs>>): Prisma__SessionTagClient<$Result.GetResult<Prisma.$SessionTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SessionTag.
     * @param {SessionTagUpdateArgs} args - Arguments to update one SessionTag.
     * @example
     * // Update one SessionTag
     * const sessionTag = await prisma.sessionTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionTagUpdateArgs>(args: SelectSubset<T, SessionTagUpdateArgs<ExtArgs>>): Prisma__SessionTagClient<$Result.GetResult<Prisma.$SessionTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SessionTags.
     * @param {SessionTagDeleteManyArgs} args - Arguments to filter SessionTags to delete.
     * @example
     * // Delete a few SessionTags
     * const { count } = await prisma.sessionTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionTagDeleteManyArgs>(args?: SelectSubset<T, SessionTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SessionTags
     * const sessionTag = await prisma.sessionTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionTagUpdateManyArgs>(args: SelectSubset<T, SessionTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionTags and returns the data updated in the database.
     * @param {SessionTagUpdateManyAndReturnArgs} args - Arguments to update many SessionTags.
     * @example
     * // Update many SessionTags
     * const sessionTag = await prisma.sessionTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SessionTags and only return the `id`
     * const sessionTagWithIdOnly = await prisma.sessionTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionTagUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SessionTag.
     * @param {SessionTagUpsertArgs} args - Arguments to update or create a SessionTag.
     * @example
     * // Update or create a SessionTag
     * const sessionTag = await prisma.sessionTag.upsert({
     *   create: {
     *     // ... data to create a SessionTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SessionTag we want to update
     *   }
     * })
     */
    upsert<T extends SessionTagUpsertArgs>(args: SelectSubset<T, SessionTagUpsertArgs<ExtArgs>>): Prisma__SessionTagClient<$Result.GetResult<Prisma.$SessionTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SessionTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionTagCountArgs} args - Arguments to filter SessionTags to count.
     * @example
     * // Count the number of SessionTags
     * const count = await prisma.sessionTag.count({
     *   where: {
     *     // ... the filter for the SessionTags we want to count
     *   }
     * })
    **/
    count<T extends SessionTagCountArgs>(
      args?: Subset<T, SessionTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SessionTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionTagAggregateArgs>(args: Subset<T, SessionTagAggregateArgs>): Prisma.PrismaPromise<GetSessionTagAggregateType<T>>

    /**
     * Group by SessionTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionTagGroupByArgs['orderBy'] }
        : { orderBy?: SessionTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SessionTag model
   */
  readonly fields: SessionTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SessionTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends ChatSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChatSessionDefaultArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SessionTag model
   */
  interface SessionTagFieldRefs {
    readonly id: FieldRef<"SessionTag", 'String'>
    readonly name: FieldRef<"SessionTag", 'String'>
    readonly sessionId: FieldRef<"SessionTag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SessionTag findUnique
   */
  export type SessionTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTag
     */
    select?: SessionTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTag
     */
    omit?: SessionTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTagInclude<ExtArgs> | null
    /**
     * Filter, which SessionTag to fetch.
     */
    where: SessionTagWhereUniqueInput
  }

  /**
   * SessionTag findUniqueOrThrow
   */
  export type SessionTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTag
     */
    select?: SessionTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTag
     */
    omit?: SessionTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTagInclude<ExtArgs> | null
    /**
     * Filter, which SessionTag to fetch.
     */
    where: SessionTagWhereUniqueInput
  }

  /**
   * SessionTag findFirst
   */
  export type SessionTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTag
     */
    select?: SessionTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTag
     */
    omit?: SessionTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTagInclude<ExtArgs> | null
    /**
     * Filter, which SessionTag to fetch.
     */
    where?: SessionTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionTags to fetch.
     */
    orderBy?: SessionTagOrderByWithRelationInput | SessionTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionTags.
     */
    cursor?: SessionTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionTags.
     */
    distinct?: SessionTagScalarFieldEnum | SessionTagScalarFieldEnum[]
  }

  /**
   * SessionTag findFirstOrThrow
   */
  export type SessionTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTag
     */
    select?: SessionTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTag
     */
    omit?: SessionTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTagInclude<ExtArgs> | null
    /**
     * Filter, which SessionTag to fetch.
     */
    where?: SessionTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionTags to fetch.
     */
    orderBy?: SessionTagOrderByWithRelationInput | SessionTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionTags.
     */
    cursor?: SessionTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionTags.
     */
    distinct?: SessionTagScalarFieldEnum | SessionTagScalarFieldEnum[]
  }

  /**
   * SessionTag findMany
   */
  export type SessionTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTag
     */
    select?: SessionTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTag
     */
    omit?: SessionTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTagInclude<ExtArgs> | null
    /**
     * Filter, which SessionTags to fetch.
     */
    where?: SessionTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionTags to fetch.
     */
    orderBy?: SessionTagOrderByWithRelationInput | SessionTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SessionTags.
     */
    cursor?: SessionTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionTags.
     */
    skip?: number
    distinct?: SessionTagScalarFieldEnum | SessionTagScalarFieldEnum[]
  }

  /**
   * SessionTag create
   */
  export type SessionTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTag
     */
    select?: SessionTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTag
     */
    omit?: SessionTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTagInclude<ExtArgs> | null
    /**
     * The data needed to create a SessionTag.
     */
    data: XOR<SessionTagCreateInput, SessionTagUncheckedCreateInput>
  }

  /**
   * SessionTag createMany
   */
  export type SessionTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SessionTags.
     */
    data: SessionTagCreateManyInput | SessionTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SessionTag createManyAndReturn
   */
  export type SessionTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTag
     */
    select?: SessionTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTag
     */
    omit?: SessionTagOmit<ExtArgs> | null
    /**
     * The data used to create many SessionTags.
     */
    data: SessionTagCreateManyInput | SessionTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionTag update
   */
  export type SessionTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTag
     */
    select?: SessionTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTag
     */
    omit?: SessionTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTagInclude<ExtArgs> | null
    /**
     * The data needed to update a SessionTag.
     */
    data: XOR<SessionTagUpdateInput, SessionTagUncheckedUpdateInput>
    /**
     * Choose, which SessionTag to update.
     */
    where: SessionTagWhereUniqueInput
  }

  /**
   * SessionTag updateMany
   */
  export type SessionTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SessionTags.
     */
    data: XOR<SessionTagUpdateManyMutationInput, SessionTagUncheckedUpdateManyInput>
    /**
     * Filter which SessionTags to update
     */
    where?: SessionTagWhereInput
    /**
     * Limit how many SessionTags to update.
     */
    limit?: number
  }

  /**
   * SessionTag updateManyAndReturn
   */
  export type SessionTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTag
     */
    select?: SessionTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTag
     */
    omit?: SessionTagOmit<ExtArgs> | null
    /**
     * The data used to update SessionTags.
     */
    data: XOR<SessionTagUpdateManyMutationInput, SessionTagUncheckedUpdateManyInput>
    /**
     * Filter which SessionTags to update
     */
    where?: SessionTagWhereInput
    /**
     * Limit how many SessionTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionTag upsert
   */
  export type SessionTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTag
     */
    select?: SessionTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTag
     */
    omit?: SessionTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTagInclude<ExtArgs> | null
    /**
     * The filter to search for the SessionTag to update in case it exists.
     */
    where: SessionTagWhereUniqueInput
    /**
     * In case the SessionTag found by the `where` argument doesn't exist, create a new SessionTag with this data.
     */
    create: XOR<SessionTagCreateInput, SessionTagUncheckedCreateInput>
    /**
     * In case the SessionTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionTagUpdateInput, SessionTagUncheckedUpdateInput>
  }

  /**
   * SessionTag delete
   */
  export type SessionTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTag
     */
    select?: SessionTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTag
     */
    omit?: SessionTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTagInclude<ExtArgs> | null
    /**
     * Filter which SessionTag to delete.
     */
    where: SessionTagWhereUniqueInput
  }

  /**
   * SessionTag deleteMany
   */
  export type SessionTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionTags to delete
     */
    where?: SessionTagWhereInput
    /**
     * Limit how many SessionTags to delete.
     */
    limit?: number
  }

  /**
   * SessionTag without action
   */
  export type SessionTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTag
     */
    select?: SessionTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTag
     */
    omit?: SessionTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTagInclude<ExtArgs> | null
  }


  /**
   * Model MondaySync
   */

  export type AggregateMondaySync = {
    _count: MondaySyncCountAggregateOutputType | null
    _min: MondaySyncMinAggregateOutputType | null
    _max: MondaySyncMaxAggregateOutputType | null
  }

  export type MondaySyncMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    itemId: string | null
    boardId: string | null
    lastSynced: Date | null
  }

  export type MondaySyncMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    itemId: string | null
    boardId: string | null
    lastSynced: Date | null
  }

  export type MondaySyncCountAggregateOutputType = {
    id: number
    sessionId: number
    itemId: number
    boardId: number
    lastSynced: number
    _all: number
  }


  export type MondaySyncMinAggregateInputType = {
    id?: true
    sessionId?: true
    itemId?: true
    boardId?: true
    lastSynced?: true
  }

  export type MondaySyncMaxAggregateInputType = {
    id?: true
    sessionId?: true
    itemId?: true
    boardId?: true
    lastSynced?: true
  }

  export type MondaySyncCountAggregateInputType = {
    id?: true
    sessionId?: true
    itemId?: true
    boardId?: true
    lastSynced?: true
    _all?: true
  }

  export type MondaySyncAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MondaySync to aggregate.
     */
    where?: MondaySyncWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MondaySyncs to fetch.
     */
    orderBy?: MondaySyncOrderByWithRelationInput | MondaySyncOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MondaySyncWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MondaySyncs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MondaySyncs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MondaySyncs
    **/
    _count?: true | MondaySyncCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MondaySyncMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MondaySyncMaxAggregateInputType
  }

  export type GetMondaySyncAggregateType<T extends MondaySyncAggregateArgs> = {
        [P in keyof T & keyof AggregateMondaySync]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMondaySync[P]>
      : GetScalarType<T[P], AggregateMondaySync[P]>
  }




  export type MondaySyncGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MondaySyncWhereInput
    orderBy?: MondaySyncOrderByWithAggregationInput | MondaySyncOrderByWithAggregationInput[]
    by: MondaySyncScalarFieldEnum[] | MondaySyncScalarFieldEnum
    having?: MondaySyncScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MondaySyncCountAggregateInputType | true
    _min?: MondaySyncMinAggregateInputType
    _max?: MondaySyncMaxAggregateInputType
  }

  export type MondaySyncGroupByOutputType = {
    id: string
    sessionId: string
    itemId: string
    boardId: string
    lastSynced: Date
    _count: MondaySyncCountAggregateOutputType | null
    _min: MondaySyncMinAggregateOutputType | null
    _max: MondaySyncMaxAggregateOutputType | null
  }

  type GetMondaySyncGroupByPayload<T extends MondaySyncGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MondaySyncGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MondaySyncGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MondaySyncGroupByOutputType[P]>
            : GetScalarType<T[P], MondaySyncGroupByOutputType[P]>
        }
      >
    >


  export type MondaySyncSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    itemId?: boolean
    boardId?: boolean
    lastSynced?: boolean
  }, ExtArgs["result"]["mondaySync"]>

  export type MondaySyncSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    itemId?: boolean
    boardId?: boolean
    lastSynced?: boolean
  }, ExtArgs["result"]["mondaySync"]>

  export type MondaySyncSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    itemId?: boolean
    boardId?: boolean
    lastSynced?: boolean
  }, ExtArgs["result"]["mondaySync"]>

  export type MondaySyncSelectScalar = {
    id?: boolean
    sessionId?: boolean
    itemId?: boolean
    boardId?: boolean
    lastSynced?: boolean
  }

  export type MondaySyncOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "itemId" | "boardId" | "lastSynced", ExtArgs["result"]["mondaySync"]>

  export type $MondaySyncPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MondaySync"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      itemId: string
      boardId: string
      lastSynced: Date
    }, ExtArgs["result"]["mondaySync"]>
    composites: {}
  }

  type MondaySyncGetPayload<S extends boolean | null | undefined | MondaySyncDefaultArgs> = $Result.GetResult<Prisma.$MondaySyncPayload, S>

  type MondaySyncCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MondaySyncFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MondaySyncCountAggregateInputType | true
    }

  export interface MondaySyncDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MondaySync'], meta: { name: 'MondaySync' } }
    /**
     * Find zero or one MondaySync that matches the filter.
     * @param {MondaySyncFindUniqueArgs} args - Arguments to find a MondaySync
     * @example
     * // Get one MondaySync
     * const mondaySync = await prisma.mondaySync.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MondaySyncFindUniqueArgs>(args: SelectSubset<T, MondaySyncFindUniqueArgs<ExtArgs>>): Prisma__MondaySyncClient<$Result.GetResult<Prisma.$MondaySyncPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MondaySync that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MondaySyncFindUniqueOrThrowArgs} args - Arguments to find a MondaySync
     * @example
     * // Get one MondaySync
     * const mondaySync = await prisma.mondaySync.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MondaySyncFindUniqueOrThrowArgs>(args: SelectSubset<T, MondaySyncFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MondaySyncClient<$Result.GetResult<Prisma.$MondaySyncPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MondaySync that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MondaySyncFindFirstArgs} args - Arguments to find a MondaySync
     * @example
     * // Get one MondaySync
     * const mondaySync = await prisma.mondaySync.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MondaySyncFindFirstArgs>(args?: SelectSubset<T, MondaySyncFindFirstArgs<ExtArgs>>): Prisma__MondaySyncClient<$Result.GetResult<Prisma.$MondaySyncPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MondaySync that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MondaySyncFindFirstOrThrowArgs} args - Arguments to find a MondaySync
     * @example
     * // Get one MondaySync
     * const mondaySync = await prisma.mondaySync.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MondaySyncFindFirstOrThrowArgs>(args?: SelectSubset<T, MondaySyncFindFirstOrThrowArgs<ExtArgs>>): Prisma__MondaySyncClient<$Result.GetResult<Prisma.$MondaySyncPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MondaySyncs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MondaySyncFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MondaySyncs
     * const mondaySyncs = await prisma.mondaySync.findMany()
     * 
     * // Get first 10 MondaySyncs
     * const mondaySyncs = await prisma.mondaySync.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mondaySyncWithIdOnly = await prisma.mondaySync.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MondaySyncFindManyArgs>(args?: SelectSubset<T, MondaySyncFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MondaySyncPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MondaySync.
     * @param {MondaySyncCreateArgs} args - Arguments to create a MondaySync.
     * @example
     * // Create one MondaySync
     * const MondaySync = await prisma.mondaySync.create({
     *   data: {
     *     // ... data to create a MondaySync
     *   }
     * })
     * 
     */
    create<T extends MondaySyncCreateArgs>(args: SelectSubset<T, MondaySyncCreateArgs<ExtArgs>>): Prisma__MondaySyncClient<$Result.GetResult<Prisma.$MondaySyncPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MondaySyncs.
     * @param {MondaySyncCreateManyArgs} args - Arguments to create many MondaySyncs.
     * @example
     * // Create many MondaySyncs
     * const mondaySync = await prisma.mondaySync.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MondaySyncCreateManyArgs>(args?: SelectSubset<T, MondaySyncCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MondaySyncs and returns the data saved in the database.
     * @param {MondaySyncCreateManyAndReturnArgs} args - Arguments to create many MondaySyncs.
     * @example
     * // Create many MondaySyncs
     * const mondaySync = await prisma.mondaySync.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MondaySyncs and only return the `id`
     * const mondaySyncWithIdOnly = await prisma.mondaySync.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MondaySyncCreateManyAndReturnArgs>(args?: SelectSubset<T, MondaySyncCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MondaySyncPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MondaySync.
     * @param {MondaySyncDeleteArgs} args - Arguments to delete one MondaySync.
     * @example
     * // Delete one MondaySync
     * const MondaySync = await prisma.mondaySync.delete({
     *   where: {
     *     // ... filter to delete one MondaySync
     *   }
     * })
     * 
     */
    delete<T extends MondaySyncDeleteArgs>(args: SelectSubset<T, MondaySyncDeleteArgs<ExtArgs>>): Prisma__MondaySyncClient<$Result.GetResult<Prisma.$MondaySyncPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MondaySync.
     * @param {MondaySyncUpdateArgs} args - Arguments to update one MondaySync.
     * @example
     * // Update one MondaySync
     * const mondaySync = await prisma.mondaySync.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MondaySyncUpdateArgs>(args: SelectSubset<T, MondaySyncUpdateArgs<ExtArgs>>): Prisma__MondaySyncClient<$Result.GetResult<Prisma.$MondaySyncPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MondaySyncs.
     * @param {MondaySyncDeleteManyArgs} args - Arguments to filter MondaySyncs to delete.
     * @example
     * // Delete a few MondaySyncs
     * const { count } = await prisma.mondaySync.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MondaySyncDeleteManyArgs>(args?: SelectSubset<T, MondaySyncDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MondaySyncs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MondaySyncUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MondaySyncs
     * const mondaySync = await prisma.mondaySync.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MondaySyncUpdateManyArgs>(args: SelectSubset<T, MondaySyncUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MondaySyncs and returns the data updated in the database.
     * @param {MondaySyncUpdateManyAndReturnArgs} args - Arguments to update many MondaySyncs.
     * @example
     * // Update many MondaySyncs
     * const mondaySync = await prisma.mondaySync.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MondaySyncs and only return the `id`
     * const mondaySyncWithIdOnly = await prisma.mondaySync.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MondaySyncUpdateManyAndReturnArgs>(args: SelectSubset<T, MondaySyncUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MondaySyncPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MondaySync.
     * @param {MondaySyncUpsertArgs} args - Arguments to update or create a MondaySync.
     * @example
     * // Update or create a MondaySync
     * const mondaySync = await prisma.mondaySync.upsert({
     *   create: {
     *     // ... data to create a MondaySync
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MondaySync we want to update
     *   }
     * })
     */
    upsert<T extends MondaySyncUpsertArgs>(args: SelectSubset<T, MondaySyncUpsertArgs<ExtArgs>>): Prisma__MondaySyncClient<$Result.GetResult<Prisma.$MondaySyncPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MondaySyncs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MondaySyncCountArgs} args - Arguments to filter MondaySyncs to count.
     * @example
     * // Count the number of MondaySyncs
     * const count = await prisma.mondaySync.count({
     *   where: {
     *     // ... the filter for the MondaySyncs we want to count
     *   }
     * })
    **/
    count<T extends MondaySyncCountArgs>(
      args?: Subset<T, MondaySyncCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MondaySyncCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MondaySync.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MondaySyncAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MondaySyncAggregateArgs>(args: Subset<T, MondaySyncAggregateArgs>): Prisma.PrismaPromise<GetMondaySyncAggregateType<T>>

    /**
     * Group by MondaySync.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MondaySyncGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MondaySyncGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MondaySyncGroupByArgs['orderBy'] }
        : { orderBy?: MondaySyncGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MondaySyncGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMondaySyncGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MondaySync model
   */
  readonly fields: MondaySyncFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MondaySync.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MondaySyncClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MondaySync model
   */
  interface MondaySyncFieldRefs {
    readonly id: FieldRef<"MondaySync", 'String'>
    readonly sessionId: FieldRef<"MondaySync", 'String'>
    readonly itemId: FieldRef<"MondaySync", 'String'>
    readonly boardId: FieldRef<"MondaySync", 'String'>
    readonly lastSynced: FieldRef<"MondaySync", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MondaySync findUnique
   */
  export type MondaySyncFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MondaySync
     */
    select?: MondaySyncSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MondaySync
     */
    omit?: MondaySyncOmit<ExtArgs> | null
    /**
     * Filter, which MondaySync to fetch.
     */
    where: MondaySyncWhereUniqueInput
  }

  /**
   * MondaySync findUniqueOrThrow
   */
  export type MondaySyncFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MondaySync
     */
    select?: MondaySyncSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MondaySync
     */
    omit?: MondaySyncOmit<ExtArgs> | null
    /**
     * Filter, which MondaySync to fetch.
     */
    where: MondaySyncWhereUniqueInput
  }

  /**
   * MondaySync findFirst
   */
  export type MondaySyncFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MondaySync
     */
    select?: MondaySyncSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MondaySync
     */
    omit?: MondaySyncOmit<ExtArgs> | null
    /**
     * Filter, which MondaySync to fetch.
     */
    where?: MondaySyncWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MondaySyncs to fetch.
     */
    orderBy?: MondaySyncOrderByWithRelationInput | MondaySyncOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MondaySyncs.
     */
    cursor?: MondaySyncWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MondaySyncs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MondaySyncs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MondaySyncs.
     */
    distinct?: MondaySyncScalarFieldEnum | MondaySyncScalarFieldEnum[]
  }

  /**
   * MondaySync findFirstOrThrow
   */
  export type MondaySyncFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MondaySync
     */
    select?: MondaySyncSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MondaySync
     */
    omit?: MondaySyncOmit<ExtArgs> | null
    /**
     * Filter, which MondaySync to fetch.
     */
    where?: MondaySyncWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MondaySyncs to fetch.
     */
    orderBy?: MondaySyncOrderByWithRelationInput | MondaySyncOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MondaySyncs.
     */
    cursor?: MondaySyncWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MondaySyncs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MondaySyncs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MondaySyncs.
     */
    distinct?: MondaySyncScalarFieldEnum | MondaySyncScalarFieldEnum[]
  }

  /**
   * MondaySync findMany
   */
  export type MondaySyncFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MondaySync
     */
    select?: MondaySyncSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MondaySync
     */
    omit?: MondaySyncOmit<ExtArgs> | null
    /**
     * Filter, which MondaySyncs to fetch.
     */
    where?: MondaySyncWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MondaySyncs to fetch.
     */
    orderBy?: MondaySyncOrderByWithRelationInput | MondaySyncOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MondaySyncs.
     */
    cursor?: MondaySyncWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MondaySyncs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MondaySyncs.
     */
    skip?: number
    distinct?: MondaySyncScalarFieldEnum | MondaySyncScalarFieldEnum[]
  }

  /**
   * MondaySync create
   */
  export type MondaySyncCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MondaySync
     */
    select?: MondaySyncSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MondaySync
     */
    omit?: MondaySyncOmit<ExtArgs> | null
    /**
     * The data needed to create a MondaySync.
     */
    data: XOR<MondaySyncCreateInput, MondaySyncUncheckedCreateInput>
  }

  /**
   * MondaySync createMany
   */
  export type MondaySyncCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MondaySyncs.
     */
    data: MondaySyncCreateManyInput | MondaySyncCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MondaySync createManyAndReturn
   */
  export type MondaySyncCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MondaySync
     */
    select?: MondaySyncSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MondaySync
     */
    omit?: MondaySyncOmit<ExtArgs> | null
    /**
     * The data used to create many MondaySyncs.
     */
    data: MondaySyncCreateManyInput | MondaySyncCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MondaySync update
   */
  export type MondaySyncUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MondaySync
     */
    select?: MondaySyncSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MondaySync
     */
    omit?: MondaySyncOmit<ExtArgs> | null
    /**
     * The data needed to update a MondaySync.
     */
    data: XOR<MondaySyncUpdateInput, MondaySyncUncheckedUpdateInput>
    /**
     * Choose, which MondaySync to update.
     */
    where: MondaySyncWhereUniqueInput
  }

  /**
   * MondaySync updateMany
   */
  export type MondaySyncUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MondaySyncs.
     */
    data: XOR<MondaySyncUpdateManyMutationInput, MondaySyncUncheckedUpdateManyInput>
    /**
     * Filter which MondaySyncs to update
     */
    where?: MondaySyncWhereInput
    /**
     * Limit how many MondaySyncs to update.
     */
    limit?: number
  }

  /**
   * MondaySync updateManyAndReturn
   */
  export type MondaySyncUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MondaySync
     */
    select?: MondaySyncSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MondaySync
     */
    omit?: MondaySyncOmit<ExtArgs> | null
    /**
     * The data used to update MondaySyncs.
     */
    data: XOR<MondaySyncUpdateManyMutationInput, MondaySyncUncheckedUpdateManyInput>
    /**
     * Filter which MondaySyncs to update
     */
    where?: MondaySyncWhereInput
    /**
     * Limit how many MondaySyncs to update.
     */
    limit?: number
  }

  /**
   * MondaySync upsert
   */
  export type MondaySyncUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MondaySync
     */
    select?: MondaySyncSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MondaySync
     */
    omit?: MondaySyncOmit<ExtArgs> | null
    /**
     * The filter to search for the MondaySync to update in case it exists.
     */
    where: MondaySyncWhereUniqueInput
    /**
     * In case the MondaySync found by the `where` argument doesn't exist, create a new MondaySync with this data.
     */
    create: XOR<MondaySyncCreateInput, MondaySyncUncheckedCreateInput>
    /**
     * In case the MondaySync was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MondaySyncUpdateInput, MondaySyncUncheckedUpdateInput>
  }

  /**
   * MondaySync delete
   */
  export type MondaySyncDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MondaySync
     */
    select?: MondaySyncSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MondaySync
     */
    omit?: MondaySyncOmit<ExtArgs> | null
    /**
     * Filter which MondaySync to delete.
     */
    where: MondaySyncWhereUniqueInput
  }

  /**
   * MondaySync deleteMany
   */
  export type MondaySyncDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MondaySyncs to delete
     */
    where?: MondaySyncWhereInput
    /**
     * Limit how many MondaySyncs to delete.
     */
    limit?: number
  }

  /**
   * MondaySync without action
   */
  export type MondaySyncDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MondaySync
     */
    select?: MondaySyncSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MondaySync
     */
    omit?: MondaySyncOmit<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    userId: string | null
    companyName: string | null
    taxId: string | null
    phoneNumber: string | null
    stripeCustomerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    companyName: string | null
    taxId: string | null
    phoneNumber: string | null
    stripeCustomerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    userId: number
    companyName: number
    billingAddress: number
    shippingAddress: number
    taxId: number
    phoneNumber: number
    stripeCustomerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerMinAggregateInputType = {
    id?: true
    userId?: true
    companyName?: true
    taxId?: true
    phoneNumber?: true
    stripeCustomerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    userId?: true
    companyName?: true
    taxId?: true
    phoneNumber?: true
    stripeCustomerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    userId?: true
    companyName?: true
    billingAddress?: true
    shippingAddress?: true
    taxId?: true
    phoneNumber?: true
    stripeCustomerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    userId: string
    companyName: string | null
    billingAddress: JsonValue | null
    shippingAddress: JsonValue | null
    taxId: string | null
    phoneNumber: string | null
    stripeCustomerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyName?: boolean
    billingAddress?: boolean
    shippingAddress?: boolean
    taxId?: boolean
    phoneNumber?: boolean
    stripeCustomerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    paymentMethods?: boolean | Customer$paymentMethodsArgs<ExtArgs>
    orders?: boolean | Customer$ordersArgs<ExtArgs>
    subscriptions?: boolean | Customer$subscriptionsArgs<ExtArgs>
    invoices?: boolean | Customer$invoicesArgs<ExtArgs>
    projects?: boolean | Customer$projectsArgs<ExtArgs>
    quotes?: boolean | Customer$quotesArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyName?: boolean
    billingAddress?: boolean
    shippingAddress?: boolean
    taxId?: boolean
    phoneNumber?: boolean
    stripeCustomerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyName?: boolean
    billingAddress?: boolean
    shippingAddress?: boolean
    taxId?: boolean
    phoneNumber?: boolean
    stripeCustomerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    userId?: boolean
    companyName?: boolean
    billingAddress?: boolean
    shippingAddress?: boolean
    taxId?: boolean
    phoneNumber?: boolean
    stripeCustomerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "companyName" | "billingAddress" | "shippingAddress" | "taxId" | "phoneNumber" | "stripeCustomerId" | "createdAt" | "updatedAt", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    paymentMethods?: boolean | Customer$paymentMethodsArgs<ExtArgs>
    orders?: boolean | Customer$ordersArgs<ExtArgs>
    subscriptions?: boolean | Customer$subscriptionsArgs<ExtArgs>
    invoices?: boolean | Customer$invoicesArgs<ExtArgs>
    projects?: boolean | Customer$projectsArgs<ExtArgs>
    quotes?: boolean | Customer$quotesArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      paymentMethods: Prisma.$PaymentMethodPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
      subscriptions: Prisma.$SubscriptionPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      projects: Prisma.$ProjectPayload<ExtArgs>[]
      quotes: Prisma.$QuotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      companyName: string | null
      billingAddress: Prisma.JsonValue | null
      shippingAddress: Prisma.JsonValue | null
      taxId: string | null
      phoneNumber: string | null
      stripeCustomerId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {CustomerUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    paymentMethods<T extends Customer$paymentMethodsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$paymentMethodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders<T extends Customer$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Customer$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscriptions<T extends Customer$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends Customer$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projects<T extends Customer$projectsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quotes<T extends Customer$quotesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$quotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly userId: FieldRef<"Customer", 'String'>
    readonly companyName: FieldRef<"Customer", 'String'>
    readonly billingAddress: FieldRef<"Customer", 'Json'>
    readonly shippingAddress: FieldRef<"Customer", 'Json'>
    readonly taxId: FieldRef<"Customer", 'String'>
    readonly phoneNumber: FieldRef<"Customer", 'String'>
    readonly stripeCustomerId: FieldRef<"Customer", 'String'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
    readonly updatedAt: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer updateManyAndReturn
   */
  export type CustomerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.paymentMethods
   */
  export type Customer$paymentMethodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    where?: PaymentMethodWhereInput
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    cursor?: PaymentMethodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * Customer.orders
   */
  export type Customer$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Customer.subscriptions
   */
  export type Customer$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Customer.invoices
   */
  export type Customer$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Customer.projects
   */
  export type Customer$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Customer.quotes
   */
  export type Customer$quotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    where?: QuoteWhereInput
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    cursor?: QuoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    basePrice: number | null
  }

  export type ProductSumAggregateOutputType = {
    basePrice: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    sku: string | null
    name: string | null
    description: string | null
    category: string | null
    basePrice: number | null
    currency: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    sku: string | null
    name: string | null
    description: string | null
    category: string | null
    basePrice: number | null
    currency: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    sku: number
    name: number
    description: number
    category: number
    basePrice: number
    currency: number
    specifications: number
    images: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    basePrice?: true
  }

  export type ProductSumAggregateInputType = {
    basePrice?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    sku?: true
    name?: true
    description?: true
    category?: true
    basePrice?: true
    currency?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    sku?: true
    name?: true
    description?: true
    category?: true
    basePrice?: true
    currency?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    sku?: true
    name?: true
    description?: true
    category?: true
    basePrice?: true
    currency?: true
    specifications?: true
    images?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    sku: string
    name: string
    description: string | null
    category: string
    basePrice: number
    currency: string
    specifications: JsonValue | null
    images: JsonValue | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    basePrice?: boolean
    currency?: boolean
    specifications?: boolean
    images?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inventoryItems?: boolean | Product$inventoryItemsArgs<ExtArgs>
    orderItems?: boolean | Product$orderItemsArgs<ExtArgs>
    cartItems?: boolean | Product$cartItemsArgs<ExtArgs>
    priceHistory?: boolean | Product$priceHistoryArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    basePrice?: boolean
    currency?: boolean
    specifications?: boolean
    images?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    basePrice?: boolean
    currency?: boolean
    specifications?: boolean
    images?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    basePrice?: boolean
    currency?: boolean
    specifications?: boolean
    images?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sku" | "name" | "description" | "category" | "basePrice" | "currency" | "specifications" | "images" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryItems?: boolean | Product$inventoryItemsArgs<ExtArgs>
    orderItems?: boolean | Product$orderItemsArgs<ExtArgs>
    cartItems?: boolean | Product$cartItemsArgs<ExtArgs>
    priceHistory?: boolean | Product$priceHistoryArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      inventoryItems: Prisma.$InventoryPayload<ExtArgs>[]
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
      cartItems: Prisma.$CartItemPayload<ExtArgs>[]
      priceHistory: Prisma.$PriceHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sku: string
      name: string
      description: string | null
      category: string
      basePrice: number
      currency: string
      specifications: Prisma.JsonValue | null
      images: Prisma.JsonValue | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inventoryItems<T extends Product$inventoryItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$inventoryItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orderItems<T extends Product$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cartItems<T extends Product$cartItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$cartItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    priceHistory<T extends Product$priceHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Product$priceHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly sku: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly category: FieldRef<"Product", 'String'>
    readonly basePrice: FieldRef<"Product", 'Float'>
    readonly currency: FieldRef<"Product", 'String'>
    readonly specifications: FieldRef<"Product", 'Json'>
    readonly images: FieldRef<"Product", 'Json'>
    readonly isActive: FieldRef<"Product", 'Boolean'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.inventoryItems
   */
  export type Product$inventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    where?: InventoryWhereInput
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    cursor?: InventoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Product.orderItems
   */
  export type Product$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Product.cartItems
   */
  export type Product$cartItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    where?: CartItemWhereInput
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    cursor?: CartItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * Product.priceHistory
   */
  export type Product$priceHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceHistory
     */
    omit?: PriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    where?: PriceHistoryWhereInput
    orderBy?: PriceHistoryOrderByWithRelationInput | PriceHistoryOrderByWithRelationInput[]
    cursor?: PriceHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PriceHistoryScalarFieldEnum | PriceHistoryScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    subtotal: number | null
    tax: number | null
    shipping: number | null
    total: number | null
  }

  export type OrderSumAggregateOutputType = {
    subtotal: number | null
    tax: number | null
    shipping: number | null
    total: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    orderNumber: string | null
    customerId: string | null
    status: string | null
    subtotal: number | null
    tax: number | null
    shipping: number | null
    total: number | null
    currency: string | null
    shippingMethod: string | null
    trackingNumber: string | null
    shippedAt: Date | null
    deliveredAt: Date | null
    paymentStatus: string | null
    paymentIntentId: string | null
    paidAt: Date | null
    customerNotes: string | null
    internalNotes: string | null
    invoiceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    orderNumber: string | null
    customerId: string | null
    status: string | null
    subtotal: number | null
    tax: number | null
    shipping: number | null
    total: number | null
    currency: string | null
    shippingMethod: string | null
    trackingNumber: string | null
    shippedAt: Date | null
    deliveredAt: Date | null
    paymentStatus: string | null
    paymentIntentId: string | null
    paidAt: Date | null
    customerNotes: string | null
    internalNotes: string | null
    invoiceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    orderNumber: number
    customerId: number
    status: number
    subtotal: number
    tax: number
    shipping: number
    total: number
    currency: number
    shippingAddress: number
    shippingMethod: number
    trackingNumber: number
    shippedAt: number
    deliveredAt: number
    paymentStatus: number
    paymentIntentId: number
    paidAt: number
    customerNotes: number
    internalNotes: number
    invoiceId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    subtotal?: true
    tax?: true
    shipping?: true
    total?: true
  }

  export type OrderSumAggregateInputType = {
    subtotal?: true
    tax?: true
    shipping?: true
    total?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    orderNumber?: true
    customerId?: true
    status?: true
    subtotal?: true
    tax?: true
    shipping?: true
    total?: true
    currency?: true
    shippingMethod?: true
    trackingNumber?: true
    shippedAt?: true
    deliveredAt?: true
    paymentStatus?: true
    paymentIntentId?: true
    paidAt?: true
    customerNotes?: true
    internalNotes?: true
    invoiceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    orderNumber?: true
    customerId?: true
    status?: true
    subtotal?: true
    tax?: true
    shipping?: true
    total?: true
    currency?: true
    shippingMethod?: true
    trackingNumber?: true
    shippedAt?: true
    deliveredAt?: true
    paymentStatus?: true
    paymentIntentId?: true
    paidAt?: true
    customerNotes?: true
    internalNotes?: true
    invoiceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    orderNumber?: true
    customerId?: true
    status?: true
    subtotal?: true
    tax?: true
    shipping?: true
    total?: true
    currency?: true
    shippingAddress?: true
    shippingMethod?: true
    trackingNumber?: true
    shippedAt?: true
    deliveredAt?: true
    paymentStatus?: true
    paymentIntentId?: true
    paidAt?: true
    customerNotes?: true
    internalNotes?: true
    invoiceId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    orderNumber: string
    customerId: string
    status: string
    subtotal: number
    tax: number
    shipping: number
    total: number
    currency: string
    shippingAddress: JsonValue | null
    shippingMethod: string | null
    trackingNumber: string | null
    shippedAt: Date | null
    deliveredAt: Date | null
    paymentStatus: string
    paymentIntentId: string | null
    paidAt: Date | null
    customerNotes: string | null
    internalNotes: string | null
    invoiceId: string | null
    createdAt: Date
    updatedAt: Date
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    customerId?: boolean
    status?: boolean
    subtotal?: boolean
    tax?: boolean
    shipping?: boolean
    total?: boolean
    currency?: boolean
    shippingAddress?: boolean
    shippingMethod?: boolean
    trackingNumber?: boolean
    shippedAt?: boolean
    deliveredAt?: boolean
    paymentStatus?: boolean
    paymentIntentId?: boolean
    paidAt?: boolean
    customerNotes?: boolean
    internalNotes?: boolean
    invoiceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    items?: boolean | Order$itemsArgs<ExtArgs>
    invoice?: boolean | Order$invoiceArgs<ExtArgs>
    project?: boolean | Order$projectArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    customerId?: boolean
    status?: boolean
    subtotal?: boolean
    tax?: boolean
    shipping?: boolean
    total?: boolean
    currency?: boolean
    shippingAddress?: boolean
    shippingMethod?: boolean
    trackingNumber?: boolean
    shippedAt?: boolean
    deliveredAt?: boolean
    paymentStatus?: boolean
    paymentIntentId?: boolean
    paidAt?: boolean
    customerNotes?: boolean
    internalNotes?: boolean
    invoiceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    invoice?: boolean | Order$invoiceArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    customerId?: boolean
    status?: boolean
    subtotal?: boolean
    tax?: boolean
    shipping?: boolean
    total?: boolean
    currency?: boolean
    shippingAddress?: boolean
    shippingMethod?: boolean
    trackingNumber?: boolean
    shippedAt?: boolean
    deliveredAt?: boolean
    paymentStatus?: boolean
    paymentIntentId?: boolean
    paidAt?: boolean
    customerNotes?: boolean
    internalNotes?: boolean
    invoiceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    invoice?: boolean | Order$invoiceArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    orderNumber?: boolean
    customerId?: boolean
    status?: boolean
    subtotal?: boolean
    tax?: boolean
    shipping?: boolean
    total?: boolean
    currency?: boolean
    shippingAddress?: boolean
    shippingMethod?: boolean
    trackingNumber?: boolean
    shippedAt?: boolean
    deliveredAt?: boolean
    paymentStatus?: boolean
    paymentIntentId?: boolean
    paidAt?: boolean
    customerNotes?: boolean
    internalNotes?: boolean
    invoiceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderNumber" | "customerId" | "status" | "subtotal" | "tax" | "shipping" | "total" | "currency" | "shippingAddress" | "shippingMethod" | "trackingNumber" | "shippedAt" | "deliveredAt" | "paymentStatus" | "paymentIntentId" | "paidAt" | "customerNotes" | "internalNotes" | "invoiceId" | "createdAt" | "updatedAt", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    items?: boolean | Order$itemsArgs<ExtArgs>
    invoice?: boolean | Order$invoiceArgs<ExtArgs>
    project?: boolean | Order$projectArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    invoice?: boolean | Order$invoiceArgs<ExtArgs>
  }
  export type OrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    invoice?: boolean | Order$invoiceArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      items: Prisma.$OrderItemPayload<ExtArgs>[]
      invoice: Prisma.$InvoicePayload<ExtArgs> | null
      project: Prisma.$ProjectPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderNumber: string
      customerId: string
      status: string
      subtotal: number
      tax: number
      shipping: number
      total: number
      currency: string
      shippingAddress: Prisma.JsonValue | null
      shippingMethod: string | null
      trackingNumber: string | null
      shippedAt: Date | null
      deliveredAt: Date | null
      paymentStatus: string
      paymentIntentId: string | null
      paidAt: Date | null
      customerNotes: string | null
      internalNotes: string | null
      invoiceId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {OrderUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends Order$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Order$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoice<T extends Order$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, Order$invoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    project<T extends Order$projectArgs<ExtArgs> = {}>(args?: Subset<T, Order$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly orderNumber: FieldRef<"Order", 'String'>
    readonly customerId: FieldRef<"Order", 'String'>
    readonly status: FieldRef<"Order", 'String'>
    readonly subtotal: FieldRef<"Order", 'Float'>
    readonly tax: FieldRef<"Order", 'Float'>
    readonly shipping: FieldRef<"Order", 'Float'>
    readonly total: FieldRef<"Order", 'Float'>
    readonly currency: FieldRef<"Order", 'String'>
    readonly shippingAddress: FieldRef<"Order", 'Json'>
    readonly shippingMethod: FieldRef<"Order", 'String'>
    readonly trackingNumber: FieldRef<"Order", 'String'>
    readonly shippedAt: FieldRef<"Order", 'DateTime'>
    readonly deliveredAt: FieldRef<"Order", 'DateTime'>
    readonly paymentStatus: FieldRef<"Order", 'String'>
    readonly paymentIntentId: FieldRef<"Order", 'String'>
    readonly paidAt: FieldRef<"Order", 'DateTime'>
    readonly customerNotes: FieldRef<"Order", 'String'>
    readonly internalNotes: FieldRef<"Order", 'String'>
    readonly invoiceId: FieldRef<"Order", 'String'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order updateManyAndReturn
   */
  export type OrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order.items
   */
  export type Order$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Order.invoice
   */
  export type Order$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * Order.project
   */
  export type Order$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model OrderItem
   */

  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  export type OrderItemAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    totalPrice: number | null
  }

  export type OrderItemSumAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    totalPrice: number | null
  }

  export type OrderItemMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    productId: string | null
    quantity: number | null
    unitPrice: number | null
    totalPrice: number | null
    createdAt: Date | null
  }

  export type OrderItemMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    productId: string | null
    quantity: number | null
    unitPrice: number | null
    totalPrice: number | null
    createdAt: Date | null
  }

  export type OrderItemCountAggregateOutputType = {
    id: number
    orderId: number
    productId: number
    quantity: number
    unitPrice: number
    totalPrice: number
    productSnapshot: number
    createdAt: number
    _all: number
  }


  export type OrderItemAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type OrderItemSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type OrderItemMinAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    createdAt?: true
  }

  export type OrderItemMaxAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    createdAt?: true
  }

  export type OrderItemCountAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    productSnapshot?: true
    createdAt?: true
    _all?: true
  }

  export type OrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItem to aggregate.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemMaxAggregateInputType
  }

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>
  }




  export type OrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithAggregationInput | OrderItemOrderByWithAggregationInput[]
    by: OrderItemScalarFieldEnum[] | OrderItemScalarFieldEnum
    having?: OrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemCountAggregateInputType | true
    _avg?: OrderItemAvgAggregateInputType
    _sum?: OrderItemSumAggregateInputType
    _min?: OrderItemMinAggregateInputType
    _max?: OrderItemMaxAggregateInputType
  }

  export type OrderItemGroupByOutputType = {
    id: string
    orderId: string
    productId: string
    quantity: number
    unitPrice: number
    totalPrice: number
    productSnapshot: JsonValue | null
    createdAt: Date
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    productSnapshot?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    productSnapshot?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    productSnapshot?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectScalar = {
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    productSnapshot?: boolean
    createdAt?: boolean
  }

  export type OrderItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "productId" | "quantity" | "unitPrice" | "totalPrice" | "productSnapshot" | "createdAt", ExtArgs["result"]["orderItem"]>
  export type OrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type OrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type OrderItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $OrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItem"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      productId: string
      quantity: number
      unitPrice: number
      totalPrice: number
      productSnapshot: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["orderItem"]>
    composites: {}
  }

  type OrderItemGetPayload<S extends boolean | null | undefined | OrderItemDefaultArgs> = $Result.GetResult<Prisma.$OrderItemPayload, S>

  type OrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderItemCountAggregateInputType | true
    }

  export interface OrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItem'], meta: { name: 'OrderItem' } }
    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemFindUniqueArgs>(args: SelectSubset<T, OrderItemFindUniqueArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemFindFirstArgs>(args?: SelectSubset<T, OrderItemFindFirstArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderItemFindManyArgs>(args?: SelectSubset<T, OrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     * 
     */
    create<T extends OrderItemCreateArgs>(args: SelectSubset<T, OrderItemCreateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderItems.
     * @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderItemCreateManyArgs>(args?: SelectSubset<T, OrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderItems and returns the data saved in the database.
     * @param {OrderItemCreateManyAndReturnArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     * 
     */
    delete<T extends OrderItemDeleteArgs>(args: SelectSubset<T, OrderItemDeleteArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderItemUpdateArgs>(args: SelectSubset<T, OrderItemUpdateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderItemDeleteManyArgs>(args?: SelectSubset<T, OrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderItemUpdateManyArgs>(args: SelectSubset<T, OrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems and returns the data updated in the database.
     * @param {OrderItemUpdateManyAndReturnArgs} args - Arguments to update many OrderItems.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderItemUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemUpsertArgs>(args: SelectSubset<T, OrderItemUpsertArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemAggregateArgs>(args: Subset<T, OrderItemAggregateArgs>): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItem model
   */
  readonly fields: OrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderItem model
   */
  interface OrderItemFieldRefs {
    readonly id: FieldRef<"OrderItem", 'String'>
    readonly orderId: FieldRef<"OrderItem", 'String'>
    readonly productId: FieldRef<"OrderItem", 'String'>
    readonly quantity: FieldRef<"OrderItem", 'Int'>
    readonly unitPrice: FieldRef<"OrderItem", 'Float'>
    readonly totalPrice: FieldRef<"OrderItem", 'Float'>
    readonly productSnapshot: FieldRef<"OrderItem", 'Json'>
    readonly createdAt: FieldRef<"OrderItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrderItem findUnique
   */
  export type OrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findFirst
   */
  export type OrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItem.
     */
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
  }

  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderItem createManyAndReturn
   */
  export type OrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItem.
     */
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
    /**
     * Choose, which OrderItem to update.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
  }

  /**
   * OrderItem updateManyAndReturn
   */
  export type OrderItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItem to update in case it exists.
     */
    where: OrderItemWhereUniqueInput
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     */
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
  }

  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter which OrderItem to delete.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to delete.
     */
    limit?: number
  }

  /**
   * OrderItem without action
   */
  export type OrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    status: string | null
    planId: string | null
    billingCycle: string | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    nextBillingDate: Date | null
    stripeSubscriptionId: string | null
    cancelledAt: Date | null
    cancelReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    status: string | null
    planId: string | null
    billingCycle: string | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    nextBillingDate: Date | null
    stripeSubscriptionId: string | null
    cancelledAt: Date | null
    cancelReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    customerId: number
    status: number
    planId: number
    billingCycle: number
    currentPeriodStart: number
    currentPeriodEnd: number
    nextBillingDate: number
    stripeSubscriptionId: number
    metadata: number
    cancelledAt: number
    cancelReason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionMinAggregateInputType = {
    id?: true
    customerId?: true
    status?: true
    planId?: true
    billingCycle?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    nextBillingDate?: true
    stripeSubscriptionId?: true
    cancelledAt?: true
    cancelReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    customerId?: true
    status?: true
    planId?: true
    billingCycle?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    nextBillingDate?: true
    stripeSubscriptionId?: true
    cancelledAt?: true
    cancelReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    customerId?: true
    status?: true
    planId?: true
    billingCycle?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    nextBillingDate?: true
    stripeSubscriptionId?: true
    metadata?: true
    cancelledAt?: true
    cancelReason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    customerId: string
    status: string
    planId: string
    billingCycle: string
    currentPeriodStart: Date
    currentPeriodEnd: Date
    nextBillingDate: Date
    stripeSubscriptionId: string | null
    metadata: JsonValue | null
    cancelledAt: Date | null
    cancelReason: string | null
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    status?: boolean
    planId?: boolean
    billingCycle?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    nextBillingDate?: boolean
    stripeSubscriptionId?: boolean
    metadata?: boolean
    cancelledAt?: boolean
    cancelReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
    invoices?: boolean | Subscription$invoicesArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    status?: boolean
    planId?: boolean
    billingCycle?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    nextBillingDate?: boolean
    stripeSubscriptionId?: boolean
    metadata?: boolean
    cancelledAt?: boolean
    cancelReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    status?: boolean
    planId?: boolean
    billingCycle?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    nextBillingDate?: boolean
    stripeSubscriptionId?: boolean
    metadata?: boolean
    cancelledAt?: boolean
    cancelReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    customerId?: boolean
    status?: boolean
    planId?: boolean
    billingCycle?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    nextBillingDate?: boolean
    stripeSubscriptionId?: boolean
    metadata?: boolean
    cancelledAt?: boolean
    cancelReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "status" | "planId" | "billingCycle" | "currentPeriodStart" | "currentPeriodEnd" | "nextBillingDate" | "stripeSubscriptionId" | "metadata" | "cancelledAt" | "cancelReason" | "createdAt" | "updatedAt", ExtArgs["result"]["subscription"]>
  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
    invoices?: boolean | Subscription$invoicesArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      plan: Prisma.$SubscriptionPlanPayload<ExtArgs>
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      status: string
      planId: string
      billingCycle: string
      currentPeriodStart: Date
      currentPeriodEnd: Date
      nextBillingDate: Date
      stripeSubscriptionId: string | null
      metadata: Prisma.JsonValue | null
      cancelledAt: Date | null
      cancelReason: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions and returns the data updated in the database.
     * @param {SubscriptionUpdateManyAndReturnArgs} args - Arguments to update many Subscriptions.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    plan<T extends SubscriptionPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionPlanDefaultArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    invoices<T extends Subscription$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'String'>
    readonly customerId: FieldRef<"Subscription", 'String'>
    readonly status: FieldRef<"Subscription", 'String'>
    readonly planId: FieldRef<"Subscription", 'String'>
    readonly billingCycle: FieldRef<"Subscription", 'String'>
    readonly currentPeriodStart: FieldRef<"Subscription", 'DateTime'>
    readonly currentPeriodEnd: FieldRef<"Subscription", 'DateTime'>
    readonly nextBillingDate: FieldRef<"Subscription", 'DateTime'>
    readonly stripeSubscriptionId: FieldRef<"Subscription", 'String'>
    readonly metadata: FieldRef<"Subscription", 'Json'>
    readonly cancelledAt: FieldRef<"Subscription", 'DateTime'>
    readonly cancelReason: FieldRef<"Subscription", 'String'>
    readonly createdAt: FieldRef<"Subscription", 'DateTime'>
    readonly updatedAt: FieldRef<"Subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
  }

  /**
   * Subscription updateManyAndReturn
   */
  export type SubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to delete.
     */
    limit?: number
  }

  /**
   * Subscription.invoices
   */
  export type Subscription$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model SubscriptionPlan
   */

  export type AggregateSubscriptionPlan = {
    _count: SubscriptionPlanCountAggregateOutputType | null
    _avg: SubscriptionPlanAvgAggregateOutputType | null
    _sum: SubscriptionPlanSumAggregateOutputType | null
    _min: SubscriptionPlanMinAggregateOutputType | null
    _max: SubscriptionPlanMaxAggregateOutputType | null
  }

  export type SubscriptionPlanAvgAggregateOutputType = {
    price: number | null
  }

  export type SubscriptionPlanSumAggregateOutputType = {
    price: number | null
  }

  export type SubscriptionPlanMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: number | null
    currency: string | null
    interval: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionPlanMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: number | null
    currency: string | null
    interval: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionPlanCountAggregateOutputType = {
    id: number
    name: number
    description: number
    price: number
    currency: number
    interval: number
    features: number
    limits: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionPlanAvgAggregateInputType = {
    price?: true
  }

  export type SubscriptionPlanSumAggregateInputType = {
    price?: true
  }

  export type SubscriptionPlanMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    currency?: true
    interval?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionPlanMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    currency?: true
    interval?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionPlanCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    currency?: true
    interval?: true
    features?: true
    limits?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionPlan to aggregate.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubscriptionPlans
    **/
    _count?: true | SubscriptionPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionPlanMaxAggregateInputType
  }

  export type GetSubscriptionPlanAggregateType<T extends SubscriptionPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscriptionPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriptionPlan[P]>
      : GetScalarType<T[P], AggregateSubscriptionPlan[P]>
  }




  export type SubscriptionPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionPlanWhereInput
    orderBy?: SubscriptionPlanOrderByWithAggregationInput | SubscriptionPlanOrderByWithAggregationInput[]
    by: SubscriptionPlanScalarFieldEnum[] | SubscriptionPlanScalarFieldEnum
    having?: SubscriptionPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionPlanCountAggregateInputType | true
    _avg?: SubscriptionPlanAvgAggregateInputType
    _sum?: SubscriptionPlanSumAggregateInputType
    _min?: SubscriptionPlanMinAggregateInputType
    _max?: SubscriptionPlanMaxAggregateInputType
  }

  export type SubscriptionPlanGroupByOutputType = {
    id: string
    name: string
    description: string | null
    price: number
    currency: string
    interval: string
    features: JsonValue | null
    limits: JsonValue | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionPlanCountAggregateOutputType | null
    _avg: SubscriptionPlanAvgAggregateOutputType | null
    _sum: SubscriptionPlanSumAggregateOutputType | null
    _min: SubscriptionPlanMinAggregateOutputType | null
    _max: SubscriptionPlanMaxAggregateOutputType | null
  }

  type GetSubscriptionPlanGroupByPayload<T extends SubscriptionPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionPlanGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionPlanGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    interval?: boolean
    features?: boolean
    limits?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscriptions?: boolean | SubscriptionPlan$subscriptionsArgs<ExtArgs>
    _count?: boolean | SubscriptionPlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptionPlan"]>

  export type SubscriptionPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    interval?: boolean
    features?: boolean
    limits?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["subscriptionPlan"]>

  export type SubscriptionPlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    interval?: boolean
    features?: boolean
    limits?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["subscriptionPlan"]>

  export type SubscriptionPlanSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    interval?: boolean
    features?: boolean
    limits?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionPlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "price" | "currency" | "interval" | "features" | "limits" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["subscriptionPlan"]>
  export type SubscriptionPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | SubscriptionPlan$subscriptionsArgs<ExtArgs>
    _count?: boolean | SubscriptionPlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubscriptionPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SubscriptionPlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SubscriptionPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubscriptionPlan"
    objects: {
      subscriptions: Prisma.$SubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      price: number
      currency: string
      interval: string
      features: Prisma.JsonValue | null
      limits: Prisma.JsonValue | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscriptionPlan"]>
    composites: {}
  }

  type SubscriptionPlanGetPayload<S extends boolean | null | undefined | SubscriptionPlanDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPlanPayload, S>

  type SubscriptionPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionPlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionPlanCountAggregateInputType | true
    }

  export interface SubscriptionPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubscriptionPlan'], meta: { name: 'SubscriptionPlan' } }
    /**
     * Find zero or one SubscriptionPlan that matches the filter.
     * @param {SubscriptionPlanFindUniqueArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionPlanFindUniqueArgs>(args: SelectSubset<T, SubscriptionPlanFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubscriptionPlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionPlanFindUniqueOrThrowArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubscriptionPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanFindFirstArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionPlanFindFirstArgs>(args?: SelectSubset<T, SubscriptionPlanFindFirstArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubscriptionPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanFindFirstOrThrowArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubscriptionPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubscriptionPlans
     * const subscriptionPlans = await prisma.subscriptionPlan.findMany()
     * 
     * // Get first 10 SubscriptionPlans
     * const subscriptionPlans = await prisma.subscriptionPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionPlanWithIdOnly = await prisma.subscriptionPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionPlanFindManyArgs>(args?: SelectSubset<T, SubscriptionPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubscriptionPlan.
     * @param {SubscriptionPlanCreateArgs} args - Arguments to create a SubscriptionPlan.
     * @example
     * // Create one SubscriptionPlan
     * const SubscriptionPlan = await prisma.subscriptionPlan.create({
     *   data: {
     *     // ... data to create a SubscriptionPlan
     *   }
     * })
     * 
     */
    create<T extends SubscriptionPlanCreateArgs>(args: SelectSubset<T, SubscriptionPlanCreateArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubscriptionPlans.
     * @param {SubscriptionPlanCreateManyArgs} args - Arguments to create many SubscriptionPlans.
     * @example
     * // Create many SubscriptionPlans
     * const subscriptionPlan = await prisma.subscriptionPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionPlanCreateManyArgs>(args?: SelectSubset<T, SubscriptionPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubscriptionPlans and returns the data saved in the database.
     * @param {SubscriptionPlanCreateManyAndReturnArgs} args - Arguments to create many SubscriptionPlans.
     * @example
     * // Create many SubscriptionPlans
     * const subscriptionPlan = await prisma.subscriptionPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubscriptionPlans and only return the `id`
     * const subscriptionPlanWithIdOnly = await prisma.subscriptionPlan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SubscriptionPlan.
     * @param {SubscriptionPlanDeleteArgs} args - Arguments to delete one SubscriptionPlan.
     * @example
     * // Delete one SubscriptionPlan
     * const SubscriptionPlan = await prisma.subscriptionPlan.delete({
     *   where: {
     *     // ... filter to delete one SubscriptionPlan
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionPlanDeleteArgs>(args: SelectSubset<T, SubscriptionPlanDeleteArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubscriptionPlan.
     * @param {SubscriptionPlanUpdateArgs} args - Arguments to update one SubscriptionPlan.
     * @example
     * // Update one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionPlanUpdateArgs>(args: SelectSubset<T, SubscriptionPlanUpdateArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubscriptionPlans.
     * @param {SubscriptionPlanDeleteManyArgs} args - Arguments to filter SubscriptionPlans to delete.
     * @example
     * // Delete a few SubscriptionPlans
     * const { count } = await prisma.subscriptionPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionPlanDeleteManyArgs>(args?: SelectSubset<T, SubscriptionPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubscriptionPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubscriptionPlans
     * const subscriptionPlan = await prisma.subscriptionPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionPlanUpdateManyArgs>(args: SelectSubset<T, SubscriptionPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubscriptionPlans and returns the data updated in the database.
     * @param {SubscriptionPlanUpdateManyAndReturnArgs} args - Arguments to update many SubscriptionPlans.
     * @example
     * // Update many SubscriptionPlans
     * const subscriptionPlan = await prisma.subscriptionPlan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SubscriptionPlans and only return the `id`
     * const subscriptionPlanWithIdOnly = await prisma.subscriptionPlan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionPlanUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionPlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SubscriptionPlan.
     * @param {SubscriptionPlanUpsertArgs} args - Arguments to update or create a SubscriptionPlan.
     * @example
     * // Update or create a SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.upsert({
     *   create: {
     *     // ... data to create a SubscriptionPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubscriptionPlan we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionPlanUpsertArgs>(args: SelectSubset<T, SubscriptionPlanUpsertArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubscriptionPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanCountArgs} args - Arguments to filter SubscriptionPlans to count.
     * @example
     * // Count the number of SubscriptionPlans
     * const count = await prisma.subscriptionPlan.count({
     *   where: {
     *     // ... the filter for the SubscriptionPlans we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionPlanCountArgs>(
      args?: Subset<T, SubscriptionPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubscriptionPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionPlanAggregateArgs>(args: Subset<T, SubscriptionPlanAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionPlanAggregateType<T>>

    /**
     * Group by SubscriptionPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionPlanGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubscriptionPlan model
   */
  readonly fields: SubscriptionPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubscriptionPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscriptions<T extends SubscriptionPlan$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionPlan$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubscriptionPlan model
   */
  interface SubscriptionPlanFieldRefs {
    readonly id: FieldRef<"SubscriptionPlan", 'String'>
    readonly name: FieldRef<"SubscriptionPlan", 'String'>
    readonly description: FieldRef<"SubscriptionPlan", 'String'>
    readonly price: FieldRef<"SubscriptionPlan", 'Float'>
    readonly currency: FieldRef<"SubscriptionPlan", 'String'>
    readonly interval: FieldRef<"SubscriptionPlan", 'String'>
    readonly features: FieldRef<"SubscriptionPlan", 'Json'>
    readonly limits: FieldRef<"SubscriptionPlan", 'Json'>
    readonly isActive: FieldRef<"SubscriptionPlan", 'Boolean'>
    readonly createdAt: FieldRef<"SubscriptionPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"SubscriptionPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubscriptionPlan findUnique
   */
  export type SubscriptionPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan findUniqueOrThrow
   */
  export type SubscriptionPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan findFirst
   */
  export type SubscriptionPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionPlans.
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionPlans.
     */
    distinct?: SubscriptionPlanScalarFieldEnum | SubscriptionPlanScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan findFirstOrThrow
   */
  export type SubscriptionPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionPlans.
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionPlans.
     */
    distinct?: SubscriptionPlanScalarFieldEnum | SubscriptionPlanScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan findMany
   */
  export type SubscriptionPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlans to fetch.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubscriptionPlans.
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    distinct?: SubscriptionPlanScalarFieldEnum | SubscriptionPlanScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan create
   */
  export type SubscriptionPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a SubscriptionPlan.
     */
    data: XOR<SubscriptionPlanCreateInput, SubscriptionPlanUncheckedCreateInput>
  }

  /**
   * SubscriptionPlan createMany
   */
  export type SubscriptionPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubscriptionPlans.
     */
    data: SubscriptionPlanCreateManyInput | SubscriptionPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubscriptionPlan createManyAndReturn
   */
  export type SubscriptionPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * The data used to create many SubscriptionPlans.
     */
    data: SubscriptionPlanCreateManyInput | SubscriptionPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubscriptionPlan update
   */
  export type SubscriptionPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a SubscriptionPlan.
     */
    data: XOR<SubscriptionPlanUpdateInput, SubscriptionPlanUncheckedUpdateInput>
    /**
     * Choose, which SubscriptionPlan to update.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan updateMany
   */
  export type SubscriptionPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubscriptionPlans.
     */
    data: XOR<SubscriptionPlanUpdateManyMutationInput, SubscriptionPlanUncheckedUpdateManyInput>
    /**
     * Filter which SubscriptionPlans to update
     */
    where?: SubscriptionPlanWhereInput
    /**
     * Limit how many SubscriptionPlans to update.
     */
    limit?: number
  }

  /**
   * SubscriptionPlan updateManyAndReturn
   */
  export type SubscriptionPlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * The data used to update SubscriptionPlans.
     */
    data: XOR<SubscriptionPlanUpdateManyMutationInput, SubscriptionPlanUncheckedUpdateManyInput>
    /**
     * Filter which SubscriptionPlans to update
     */
    where?: SubscriptionPlanWhereInput
    /**
     * Limit how many SubscriptionPlans to update.
     */
    limit?: number
  }

  /**
   * SubscriptionPlan upsert
   */
  export type SubscriptionPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the SubscriptionPlan to update in case it exists.
     */
    where: SubscriptionPlanWhereUniqueInput
    /**
     * In case the SubscriptionPlan found by the `where` argument doesn't exist, create a new SubscriptionPlan with this data.
     */
    create: XOR<SubscriptionPlanCreateInput, SubscriptionPlanUncheckedCreateInput>
    /**
     * In case the SubscriptionPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionPlanUpdateInput, SubscriptionPlanUncheckedUpdateInput>
  }

  /**
   * SubscriptionPlan delete
   */
  export type SubscriptionPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter which SubscriptionPlan to delete.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan deleteMany
   */
  export type SubscriptionPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionPlans to delete
     */
    where?: SubscriptionPlanWhereInput
    /**
     * Limit how many SubscriptionPlans to delete.
     */
    limit?: number
  }

  /**
   * SubscriptionPlan.subscriptions
   */
  export type SubscriptionPlan$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan without action
   */
  export type SubscriptionPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    subtotal: number | null
    tax: number | null
    total: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    subtotal: number | null
    tax: number | null
    total: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    invoiceNumber: string | null
    customerId: string | null
    type: string | null
    subscriptionId: string | null
    subtotal: number | null
    tax: number | null
    total: number | null
    currency: string | null
    status: string | null
    dueDate: Date | null
    paidAt: Date | null
    paymentIntentId: string | null
    paymentMethod: string | null
    pdfUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    invoiceNumber: string | null
    customerId: string | null
    type: string | null
    subscriptionId: string | null
    subtotal: number | null
    tax: number | null
    total: number | null
    currency: string | null
    status: string | null
    dueDate: Date | null
    paidAt: Date | null
    paymentIntentId: string | null
    paymentMethod: string | null
    pdfUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    invoiceNumber: number
    customerId: number
    type: number
    subscriptionId: number
    subtotal: number
    tax: number
    total: number
    currency: number
    status: number
    dueDate: number
    paidAt: number
    paymentIntentId: number
    paymentMethod: number
    pdfUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    subtotal?: true
    tax?: true
    total?: true
  }

  export type InvoiceSumAggregateInputType = {
    subtotal?: true
    tax?: true
    total?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    invoiceNumber?: true
    customerId?: true
    type?: true
    subscriptionId?: true
    subtotal?: true
    tax?: true
    total?: true
    currency?: true
    status?: true
    dueDate?: true
    paidAt?: true
    paymentIntentId?: true
    paymentMethod?: true
    pdfUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    invoiceNumber?: true
    customerId?: true
    type?: true
    subscriptionId?: true
    subtotal?: true
    tax?: true
    total?: true
    currency?: true
    status?: true
    dueDate?: true
    paidAt?: true
    paymentIntentId?: true
    paymentMethod?: true
    pdfUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    invoiceNumber?: true
    customerId?: true
    type?: true
    subscriptionId?: true
    subtotal?: true
    tax?: true
    total?: true
    currency?: true
    status?: true
    dueDate?: true
    paidAt?: true
    paymentIntentId?: true
    paymentMethod?: true
    pdfUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    invoiceNumber: string
    customerId: string
    type: string
    subscriptionId: string | null
    subtotal: number
    tax: number
    total: number
    currency: string
    status: string
    dueDate: Date
    paidAt: Date | null
    paymentIntentId: string | null
    paymentMethod: string | null
    pdfUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    customerId?: boolean
    type?: boolean
    subscriptionId?: boolean
    subtotal?: boolean
    tax?: boolean
    total?: boolean
    currency?: boolean
    status?: boolean
    dueDate?: boolean
    paidAt?: boolean
    paymentIntentId?: boolean
    paymentMethod?: boolean
    pdfUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    order?: boolean | Invoice$orderArgs<ExtArgs>
    subscription?: boolean | Invoice$subscriptionArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    customerId?: boolean
    type?: boolean
    subscriptionId?: boolean
    subtotal?: boolean
    tax?: boolean
    total?: boolean
    currency?: boolean
    status?: boolean
    dueDate?: boolean
    paidAt?: boolean
    paymentIntentId?: boolean
    paymentMethod?: boolean
    pdfUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    subscription?: boolean | Invoice$subscriptionArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    customerId?: boolean
    type?: boolean
    subscriptionId?: boolean
    subtotal?: boolean
    tax?: boolean
    total?: boolean
    currency?: boolean
    status?: boolean
    dueDate?: boolean
    paidAt?: boolean
    paymentIntentId?: boolean
    paymentMethod?: boolean
    pdfUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    subscription?: boolean | Invoice$subscriptionArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    invoiceNumber?: boolean
    customerId?: boolean
    type?: boolean
    subscriptionId?: boolean
    subtotal?: boolean
    tax?: boolean
    total?: boolean
    currency?: boolean
    status?: boolean
    dueDate?: boolean
    paidAt?: boolean
    paymentIntentId?: boolean
    paymentMethod?: boolean
    pdfUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceNumber" | "customerId" | "type" | "subscriptionId" | "subtotal" | "tax" | "total" | "currency" | "status" | "dueDate" | "paidAt" | "paymentIntentId" | "paymentMethod" | "pdfUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["invoice"]>
  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    order?: boolean | Invoice$orderArgs<ExtArgs>
    subscription?: boolean | Invoice$subscriptionArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    subscription?: boolean | Invoice$subscriptionArgs<ExtArgs>
  }
  export type InvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    subscription?: boolean | Invoice$subscriptionArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      order: Prisma.$OrderPayload<ExtArgs> | null
      subscription: Prisma.$SubscriptionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceNumber: string
      customerId: string
      type: string
      subscriptionId: string | null
      subtotal: number
      tax: number
      total: number
      currency: string
      status: string
      dueDate: Date
      paidAt: Date | null
      paymentIntentId: string | null
      paymentMethod: string | null
      pdfUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices and returns the data updated in the database.
     * @param {InvoiceUpdateManyAndReturnArgs} args - Arguments to update many Invoices.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    order<T extends Invoice$orderArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$orderArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subscription<T extends Invoice$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$subscriptionArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly invoiceNumber: FieldRef<"Invoice", 'String'>
    readonly customerId: FieldRef<"Invoice", 'String'>
    readonly type: FieldRef<"Invoice", 'String'>
    readonly subscriptionId: FieldRef<"Invoice", 'String'>
    readonly subtotal: FieldRef<"Invoice", 'Float'>
    readonly tax: FieldRef<"Invoice", 'Float'>
    readonly total: FieldRef<"Invoice", 'Float'>
    readonly currency: FieldRef<"Invoice", 'String'>
    readonly status: FieldRef<"Invoice", 'String'>
    readonly dueDate: FieldRef<"Invoice", 'DateTime'>
    readonly paidAt: FieldRef<"Invoice", 'DateTime'>
    readonly paymentIntentId: FieldRef<"Invoice", 'String'>
    readonly paymentMethod: FieldRef<"Invoice", 'String'>
    readonly pdfUrl: FieldRef<"Invoice", 'String'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice updateManyAndReturn
   */
  export type InvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number
  }

  /**
   * Invoice.order
   */
  export type Invoice$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
  }

  /**
   * Invoice.subscription
   */
  export type Invoice$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model PaymentMethod
   */

  export type AggregatePaymentMethod = {
    _count: PaymentMethodCountAggregateOutputType | null
    _avg: PaymentMethodAvgAggregateOutputType | null
    _sum: PaymentMethodSumAggregateOutputType | null
    _min: PaymentMethodMinAggregateOutputType | null
    _max: PaymentMethodMaxAggregateOutputType | null
  }

  export type PaymentMethodAvgAggregateOutputType = {
    expiryMonth: number | null
    expiryYear: number | null
  }

  export type PaymentMethodSumAggregateOutputType = {
    expiryMonth: number | null
    expiryYear: number | null
  }

  export type PaymentMethodMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    stripePaymentMethodId: string | null
    type: string | null
    last4: string | null
    brand: string | null
    expiryMonth: number | null
    expiryYear: number | null
    isDefault: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMethodMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    stripePaymentMethodId: string | null
    type: string | null
    last4: string | null
    brand: string | null
    expiryMonth: number | null
    expiryYear: number | null
    isDefault: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMethodCountAggregateOutputType = {
    id: number
    customerId: number
    stripePaymentMethodId: number
    type: number
    last4: number
    brand: number
    expiryMonth: number
    expiryYear: number
    isDefault: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentMethodAvgAggregateInputType = {
    expiryMonth?: true
    expiryYear?: true
  }

  export type PaymentMethodSumAggregateInputType = {
    expiryMonth?: true
    expiryYear?: true
  }

  export type PaymentMethodMinAggregateInputType = {
    id?: true
    customerId?: true
    stripePaymentMethodId?: true
    type?: true
    last4?: true
    brand?: true
    expiryMonth?: true
    expiryYear?: true
    isDefault?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMethodMaxAggregateInputType = {
    id?: true
    customerId?: true
    stripePaymentMethodId?: true
    type?: true
    last4?: true
    brand?: true
    expiryMonth?: true
    expiryYear?: true
    isDefault?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMethodCountAggregateInputType = {
    id?: true
    customerId?: true
    stripePaymentMethodId?: true
    type?: true
    last4?: true
    brand?: true
    expiryMonth?: true
    expiryYear?: true
    isDefault?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentMethodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMethod to aggregate.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentMethods
    **/
    _count?: true | PaymentMethodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentMethodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentMethodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMethodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMethodMaxAggregateInputType
  }

  export type GetPaymentMethodAggregateType<T extends PaymentMethodAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentMethod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentMethod[P]>
      : GetScalarType<T[P], AggregatePaymentMethod[P]>
  }




  export type PaymentMethodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentMethodWhereInput
    orderBy?: PaymentMethodOrderByWithAggregationInput | PaymentMethodOrderByWithAggregationInput[]
    by: PaymentMethodScalarFieldEnum[] | PaymentMethodScalarFieldEnum
    having?: PaymentMethodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentMethodCountAggregateInputType | true
    _avg?: PaymentMethodAvgAggregateInputType
    _sum?: PaymentMethodSumAggregateInputType
    _min?: PaymentMethodMinAggregateInputType
    _max?: PaymentMethodMaxAggregateInputType
  }

  export type PaymentMethodGroupByOutputType = {
    id: string
    customerId: string
    stripePaymentMethodId: string
    type: string
    last4: string
    brand: string | null
    expiryMonth: number | null
    expiryYear: number | null
    isDefault: boolean
    createdAt: Date
    updatedAt: Date
    _count: PaymentMethodCountAggregateOutputType | null
    _avg: PaymentMethodAvgAggregateOutputType | null
    _sum: PaymentMethodSumAggregateOutputType | null
    _min: PaymentMethodMinAggregateOutputType | null
    _max: PaymentMethodMaxAggregateOutputType | null
  }

  type GetPaymentMethodGroupByPayload<T extends PaymentMethodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentMethodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentMethodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentMethodGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentMethodGroupByOutputType[P]>
        }
      >
    >


  export type PaymentMethodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    stripePaymentMethodId?: boolean
    type?: boolean
    last4?: boolean
    brand?: boolean
    expiryMonth?: boolean
    expiryYear?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentMethod"]>

  export type PaymentMethodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    stripePaymentMethodId?: boolean
    type?: boolean
    last4?: boolean
    brand?: boolean
    expiryMonth?: boolean
    expiryYear?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentMethod"]>

  export type PaymentMethodSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    stripePaymentMethodId?: boolean
    type?: boolean
    last4?: boolean
    brand?: boolean
    expiryMonth?: boolean
    expiryYear?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentMethod"]>

  export type PaymentMethodSelectScalar = {
    id?: boolean
    customerId?: boolean
    stripePaymentMethodId?: boolean
    type?: boolean
    last4?: boolean
    brand?: boolean
    expiryMonth?: boolean
    expiryYear?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentMethodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "stripePaymentMethodId" | "type" | "last4" | "brand" | "expiryMonth" | "expiryYear" | "isDefault" | "createdAt" | "updatedAt", ExtArgs["result"]["paymentMethod"]>
  export type PaymentMethodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type PaymentMethodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type PaymentMethodIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $PaymentMethodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentMethod"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      stripePaymentMethodId: string
      type: string
      last4: string
      brand: string | null
      expiryMonth: number | null
      expiryYear: number | null
      isDefault: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["paymentMethod"]>
    composites: {}
  }

  type PaymentMethodGetPayload<S extends boolean | null | undefined | PaymentMethodDefaultArgs> = $Result.GetResult<Prisma.$PaymentMethodPayload, S>

  type PaymentMethodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentMethodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentMethodCountAggregateInputType | true
    }

  export interface PaymentMethodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentMethod'], meta: { name: 'PaymentMethod' } }
    /**
     * Find zero or one PaymentMethod that matches the filter.
     * @param {PaymentMethodFindUniqueArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentMethodFindUniqueArgs>(args: SelectSubset<T, PaymentMethodFindUniqueArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentMethod that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentMethodFindUniqueOrThrowArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentMethodFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentMethodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentMethod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindFirstArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentMethodFindFirstArgs>(args?: SelectSubset<T, PaymentMethodFindFirstArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentMethod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindFirstOrThrowArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentMethodFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentMethodFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentMethods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentMethods
     * const paymentMethods = await prisma.paymentMethod.findMany()
     * 
     * // Get first 10 PaymentMethods
     * const paymentMethods = await prisma.paymentMethod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentMethodWithIdOnly = await prisma.paymentMethod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentMethodFindManyArgs>(args?: SelectSubset<T, PaymentMethodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentMethod.
     * @param {PaymentMethodCreateArgs} args - Arguments to create a PaymentMethod.
     * @example
     * // Create one PaymentMethod
     * const PaymentMethod = await prisma.paymentMethod.create({
     *   data: {
     *     // ... data to create a PaymentMethod
     *   }
     * })
     * 
     */
    create<T extends PaymentMethodCreateArgs>(args: SelectSubset<T, PaymentMethodCreateArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentMethods.
     * @param {PaymentMethodCreateManyArgs} args - Arguments to create many PaymentMethods.
     * @example
     * // Create many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentMethodCreateManyArgs>(args?: SelectSubset<T, PaymentMethodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentMethods and returns the data saved in the database.
     * @param {PaymentMethodCreateManyAndReturnArgs} args - Arguments to create many PaymentMethods.
     * @example
     * // Create many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentMethods and only return the `id`
     * const paymentMethodWithIdOnly = await prisma.paymentMethod.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentMethodCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentMethodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentMethod.
     * @param {PaymentMethodDeleteArgs} args - Arguments to delete one PaymentMethod.
     * @example
     * // Delete one PaymentMethod
     * const PaymentMethod = await prisma.paymentMethod.delete({
     *   where: {
     *     // ... filter to delete one PaymentMethod
     *   }
     * })
     * 
     */
    delete<T extends PaymentMethodDeleteArgs>(args: SelectSubset<T, PaymentMethodDeleteArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentMethod.
     * @param {PaymentMethodUpdateArgs} args - Arguments to update one PaymentMethod.
     * @example
     * // Update one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentMethodUpdateArgs>(args: SelectSubset<T, PaymentMethodUpdateArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentMethods.
     * @param {PaymentMethodDeleteManyArgs} args - Arguments to filter PaymentMethods to delete.
     * @example
     * // Delete a few PaymentMethods
     * const { count } = await prisma.paymentMethod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentMethodDeleteManyArgs>(args?: SelectSubset<T, PaymentMethodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentMethodUpdateManyArgs>(args: SelectSubset<T, PaymentMethodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentMethods and returns the data updated in the database.
     * @param {PaymentMethodUpdateManyAndReturnArgs} args - Arguments to update many PaymentMethods.
     * @example
     * // Update many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentMethods and only return the `id`
     * const paymentMethodWithIdOnly = await prisma.paymentMethod.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentMethodUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentMethodUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentMethod.
     * @param {PaymentMethodUpsertArgs} args - Arguments to update or create a PaymentMethod.
     * @example
     * // Update or create a PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.upsert({
     *   create: {
     *     // ... data to create a PaymentMethod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentMethod we want to update
     *   }
     * })
     */
    upsert<T extends PaymentMethodUpsertArgs>(args: SelectSubset<T, PaymentMethodUpsertArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodCountArgs} args - Arguments to filter PaymentMethods to count.
     * @example
     * // Count the number of PaymentMethods
     * const count = await prisma.paymentMethod.count({
     *   where: {
     *     // ... the filter for the PaymentMethods we want to count
     *   }
     * })
    **/
    count<T extends PaymentMethodCountArgs>(
      args?: Subset<T, PaymentMethodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentMethodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentMethodAggregateArgs>(args: Subset<T, PaymentMethodAggregateArgs>): Prisma.PrismaPromise<GetPaymentMethodAggregateType<T>>

    /**
     * Group by PaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentMethodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentMethodGroupByArgs['orderBy'] }
        : { orderBy?: PaymentMethodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentMethodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentMethodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentMethod model
   */
  readonly fields: PaymentMethodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentMethod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentMethodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentMethod model
   */
  interface PaymentMethodFieldRefs {
    readonly id: FieldRef<"PaymentMethod", 'String'>
    readonly customerId: FieldRef<"PaymentMethod", 'String'>
    readonly stripePaymentMethodId: FieldRef<"PaymentMethod", 'String'>
    readonly type: FieldRef<"PaymentMethod", 'String'>
    readonly last4: FieldRef<"PaymentMethod", 'String'>
    readonly brand: FieldRef<"PaymentMethod", 'String'>
    readonly expiryMonth: FieldRef<"PaymentMethod", 'Int'>
    readonly expiryYear: FieldRef<"PaymentMethod", 'Int'>
    readonly isDefault: FieldRef<"PaymentMethod", 'Boolean'>
    readonly createdAt: FieldRef<"PaymentMethod", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentMethod", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentMethod findUnique
   */
  export type PaymentMethodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod findUniqueOrThrow
   */
  export type PaymentMethodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod findFirst
   */
  export type PaymentMethodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMethods.
     */
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod findFirstOrThrow
   */
  export type PaymentMethodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMethods.
     */
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod findMany
   */
  export type PaymentMethodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethods to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod create
   */
  export type PaymentMethodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentMethod.
     */
    data: XOR<PaymentMethodCreateInput, PaymentMethodUncheckedCreateInput>
  }

  /**
   * PaymentMethod createMany
   */
  export type PaymentMethodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentMethods.
     */
    data: PaymentMethodCreateManyInput | PaymentMethodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentMethod createManyAndReturn
   */
  export type PaymentMethodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentMethods.
     */
    data: PaymentMethodCreateManyInput | PaymentMethodCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentMethod update
   */
  export type PaymentMethodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentMethod.
     */
    data: XOR<PaymentMethodUpdateInput, PaymentMethodUncheckedUpdateInput>
    /**
     * Choose, which PaymentMethod to update.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod updateMany
   */
  export type PaymentMethodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentMethods.
     */
    data: XOR<PaymentMethodUpdateManyMutationInput, PaymentMethodUncheckedUpdateManyInput>
    /**
     * Filter which PaymentMethods to update
     */
    where?: PaymentMethodWhereInput
    /**
     * Limit how many PaymentMethods to update.
     */
    limit?: number
  }

  /**
   * PaymentMethod updateManyAndReturn
   */
  export type PaymentMethodUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * The data used to update PaymentMethods.
     */
    data: XOR<PaymentMethodUpdateManyMutationInput, PaymentMethodUncheckedUpdateManyInput>
    /**
     * Filter which PaymentMethods to update
     */
    where?: PaymentMethodWhereInput
    /**
     * Limit how many PaymentMethods to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentMethod upsert
   */
  export type PaymentMethodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentMethod to update in case it exists.
     */
    where: PaymentMethodWhereUniqueInput
    /**
     * In case the PaymentMethod found by the `where` argument doesn't exist, create a new PaymentMethod with this data.
     */
    create: XOR<PaymentMethodCreateInput, PaymentMethodUncheckedCreateInput>
    /**
     * In case the PaymentMethod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentMethodUpdateInput, PaymentMethodUncheckedUpdateInput>
  }

  /**
   * PaymentMethod delete
   */
  export type PaymentMethodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter which PaymentMethod to delete.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod deleteMany
   */
  export type PaymentMethodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMethods to delete
     */
    where?: PaymentMethodWhereInput
    /**
     * Limit how many PaymentMethods to delete.
     */
    limit?: number
  }

  /**
   * PaymentMethod without action
   */
  export type PaymentMethodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
  }


  /**
   * Model Inventory
   */

  export type AggregateInventory = {
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  export type InventoryAvgAggregateOutputType = {
    quantity: number | null
    reservedQuantity: number | null
    availableQuantity: number | null
    reorderPoint: number | null
    reorderQuantity: number | null
  }

  export type InventorySumAggregateOutputType = {
    quantity: number | null
    reservedQuantity: number | null
    availableQuantity: number | null
    reorderPoint: number | null
    reorderQuantity: number | null
  }

  export type InventoryMinAggregateOutputType = {
    id: string | null
    productId: string | null
    location: string | null
    quantity: number | null
    reservedQuantity: number | null
    availableQuantity: number | null
    reorderPoint: number | null
    reorderQuantity: number | null
    batchNumber: string | null
    lastRestocked: Date | null
    lastCounted: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    location: string | null
    quantity: number | null
    reservedQuantity: number | null
    availableQuantity: number | null
    reorderPoint: number | null
    reorderQuantity: number | null
    batchNumber: string | null
    lastRestocked: Date | null
    lastCounted: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryCountAggregateOutputType = {
    id: number
    productId: number
    location: number
    quantity: number
    reservedQuantity: number
    availableQuantity: number
    reorderPoint: number
    reorderQuantity: number
    batchNumber: number
    serialNumbers: number
    lastRestocked: number
    lastCounted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InventoryAvgAggregateInputType = {
    quantity?: true
    reservedQuantity?: true
    availableQuantity?: true
    reorderPoint?: true
    reorderQuantity?: true
  }

  export type InventorySumAggregateInputType = {
    quantity?: true
    reservedQuantity?: true
    availableQuantity?: true
    reorderPoint?: true
    reorderQuantity?: true
  }

  export type InventoryMinAggregateInputType = {
    id?: true
    productId?: true
    location?: true
    quantity?: true
    reservedQuantity?: true
    availableQuantity?: true
    reorderPoint?: true
    reorderQuantity?: true
    batchNumber?: true
    lastRestocked?: true
    lastCounted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryMaxAggregateInputType = {
    id?: true
    productId?: true
    location?: true
    quantity?: true
    reservedQuantity?: true
    availableQuantity?: true
    reorderPoint?: true
    reorderQuantity?: true
    batchNumber?: true
    lastRestocked?: true
    lastCounted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryCountAggregateInputType = {
    id?: true
    productId?: true
    location?: true
    quantity?: true
    reservedQuantity?: true
    availableQuantity?: true
    reorderPoint?: true
    reorderQuantity?: true
    batchNumber?: true
    serialNumbers?: true
    lastRestocked?: true
    lastCounted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InventoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventory to aggregate.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inventories
    **/
    _count?: true | InventoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryMaxAggregateInputType
  }

  export type GetInventoryAggregateType<T extends InventoryAggregateArgs> = {
        [P in keyof T & keyof AggregateInventory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventory[P]>
      : GetScalarType<T[P], AggregateInventory[P]>
  }




  export type InventoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput
    orderBy?: InventoryOrderByWithAggregationInput | InventoryOrderByWithAggregationInput[]
    by: InventoryScalarFieldEnum[] | InventoryScalarFieldEnum
    having?: InventoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryCountAggregateInputType | true
    _avg?: InventoryAvgAggregateInputType
    _sum?: InventorySumAggregateInputType
    _min?: InventoryMinAggregateInputType
    _max?: InventoryMaxAggregateInputType
  }

  export type InventoryGroupByOutputType = {
    id: string
    productId: string
    location: string
    quantity: number
    reservedQuantity: number
    availableQuantity: number
    reorderPoint: number
    reorderQuantity: number
    batchNumber: string | null
    serialNumbers: JsonValue | null
    lastRestocked: Date | null
    lastCounted: Date | null
    createdAt: Date
    updatedAt: Date
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  type GetInventoryGroupByPayload<T extends InventoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryGroupByOutputType[P]>
        }
      >
    >


  export type InventorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    location?: boolean
    quantity?: boolean
    reservedQuantity?: boolean
    availableQuantity?: boolean
    reorderPoint?: boolean
    reorderQuantity?: boolean
    batchNumber?: boolean
    serialNumbers?: boolean
    lastRestocked?: boolean
    lastCounted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventory"]>

  export type InventorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    location?: boolean
    quantity?: boolean
    reservedQuantity?: boolean
    availableQuantity?: boolean
    reorderPoint?: boolean
    reorderQuantity?: boolean
    batchNumber?: boolean
    serialNumbers?: boolean
    lastRestocked?: boolean
    lastCounted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventory"]>

  export type InventorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    location?: boolean
    quantity?: boolean
    reservedQuantity?: boolean
    availableQuantity?: boolean
    reorderPoint?: boolean
    reorderQuantity?: boolean
    batchNumber?: boolean
    serialNumbers?: boolean
    lastRestocked?: boolean
    lastCounted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventory"]>

  export type InventorySelectScalar = {
    id?: boolean
    productId?: boolean
    location?: boolean
    quantity?: boolean
    reservedQuantity?: boolean
    availableQuantity?: boolean
    reorderPoint?: boolean
    reorderQuantity?: boolean
    batchNumber?: boolean
    serialNumbers?: boolean
    lastRestocked?: boolean
    lastCounted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InventoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "location" | "quantity" | "reservedQuantity" | "availableQuantity" | "reorderPoint" | "reorderQuantity" | "batchNumber" | "serialNumbers" | "lastRestocked" | "lastCounted" | "createdAt" | "updatedAt", ExtArgs["result"]["inventory"]>
  export type InventoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type InventoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type InventoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $InventoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Inventory"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      location: string
      quantity: number
      reservedQuantity: number
      availableQuantity: number
      reorderPoint: number
      reorderQuantity: number
      batchNumber: string | null
      serialNumbers: Prisma.JsonValue | null
      lastRestocked: Date | null
      lastCounted: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["inventory"]>
    composites: {}
  }

  type InventoryGetPayload<S extends boolean | null | undefined | InventoryDefaultArgs> = $Result.GetResult<Prisma.$InventoryPayload, S>

  type InventoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryCountAggregateInputType | true
    }

  export interface InventoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Inventory'], meta: { name: 'Inventory' } }
    /**
     * Find zero or one Inventory that matches the filter.
     * @param {InventoryFindUniqueArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryFindUniqueArgs>(args: SelectSubset<T, InventoryFindUniqueArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Inventory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryFindUniqueOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inventory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryFindFirstArgs>(args?: SelectSubset<T, InventoryFindFirstArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inventory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Inventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inventories
     * const inventories = await prisma.inventory.findMany()
     * 
     * // Get first 10 Inventories
     * const inventories = await prisma.inventory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryWithIdOnly = await prisma.inventory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryFindManyArgs>(args?: SelectSubset<T, InventoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Inventory.
     * @param {InventoryCreateArgs} args - Arguments to create a Inventory.
     * @example
     * // Create one Inventory
     * const Inventory = await prisma.inventory.create({
     *   data: {
     *     // ... data to create a Inventory
     *   }
     * })
     * 
     */
    create<T extends InventoryCreateArgs>(args: SelectSubset<T, InventoryCreateArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Inventories.
     * @param {InventoryCreateManyArgs} args - Arguments to create many Inventories.
     * @example
     * // Create many Inventories
     * const inventory = await prisma.inventory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryCreateManyArgs>(args?: SelectSubset<T, InventoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Inventories and returns the data saved in the database.
     * @param {InventoryCreateManyAndReturnArgs} args - Arguments to create many Inventories.
     * @example
     * // Create many Inventories
     * const inventory = await prisma.inventory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Inventories and only return the `id`
     * const inventoryWithIdOnly = await prisma.inventory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Inventory.
     * @param {InventoryDeleteArgs} args - Arguments to delete one Inventory.
     * @example
     * // Delete one Inventory
     * const Inventory = await prisma.inventory.delete({
     *   where: {
     *     // ... filter to delete one Inventory
     *   }
     * })
     * 
     */
    delete<T extends InventoryDeleteArgs>(args: SelectSubset<T, InventoryDeleteArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Inventory.
     * @param {InventoryUpdateArgs} args - Arguments to update one Inventory.
     * @example
     * // Update one Inventory
     * const inventory = await prisma.inventory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryUpdateArgs>(args: SelectSubset<T, InventoryUpdateArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Inventories.
     * @param {InventoryDeleteManyArgs} args - Arguments to filter Inventories to delete.
     * @example
     * // Delete a few Inventories
     * const { count } = await prisma.inventory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryDeleteManyArgs>(args?: SelectSubset<T, InventoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inventories
     * const inventory = await prisma.inventory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryUpdateManyArgs>(args: SelectSubset<T, InventoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventories and returns the data updated in the database.
     * @param {InventoryUpdateManyAndReturnArgs} args - Arguments to update many Inventories.
     * @example
     * // Update many Inventories
     * const inventory = await prisma.inventory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Inventories and only return the `id`
     * const inventoryWithIdOnly = await prisma.inventory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InventoryUpdateManyAndReturnArgs>(args: SelectSubset<T, InventoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Inventory.
     * @param {InventoryUpsertArgs} args - Arguments to update or create a Inventory.
     * @example
     * // Update or create a Inventory
     * const inventory = await prisma.inventory.upsert({
     *   create: {
     *     // ... data to create a Inventory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inventory we want to update
     *   }
     * })
     */
    upsert<T extends InventoryUpsertArgs>(args: SelectSubset<T, InventoryUpsertArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryCountArgs} args - Arguments to filter Inventories to count.
     * @example
     * // Count the number of Inventories
     * const count = await prisma.inventory.count({
     *   where: {
     *     // ... the filter for the Inventories we want to count
     *   }
     * })
    **/
    count<T extends InventoryCountArgs>(
      args?: Subset<T, InventoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryAggregateArgs>(args: Subset<T, InventoryAggregateArgs>): Prisma.PrismaPromise<GetInventoryAggregateType<T>>

    /**
     * Group by Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryGroupByArgs['orderBy'] }
        : { orderBy?: InventoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Inventory model
   */
  readonly fields: InventoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Inventory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Inventory model
   */
  interface InventoryFieldRefs {
    readonly id: FieldRef<"Inventory", 'String'>
    readonly productId: FieldRef<"Inventory", 'String'>
    readonly location: FieldRef<"Inventory", 'String'>
    readonly quantity: FieldRef<"Inventory", 'Int'>
    readonly reservedQuantity: FieldRef<"Inventory", 'Int'>
    readonly availableQuantity: FieldRef<"Inventory", 'Int'>
    readonly reorderPoint: FieldRef<"Inventory", 'Int'>
    readonly reorderQuantity: FieldRef<"Inventory", 'Int'>
    readonly batchNumber: FieldRef<"Inventory", 'String'>
    readonly serialNumbers: FieldRef<"Inventory", 'Json'>
    readonly lastRestocked: FieldRef<"Inventory", 'DateTime'>
    readonly lastCounted: FieldRef<"Inventory", 'DateTime'>
    readonly createdAt: FieldRef<"Inventory", 'DateTime'>
    readonly updatedAt: FieldRef<"Inventory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Inventory findUnique
   */
  export type InventoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory findUniqueOrThrow
   */
  export type InventoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory findFirst
   */
  export type InventoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory findFirstOrThrow
   */
  export type InventoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory findMany
   */
  export type InventoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventories to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory create
   */
  export type InventoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Inventory.
     */
    data: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>
  }

  /**
   * Inventory createMany
   */
  export type InventoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Inventories.
     */
    data: InventoryCreateManyInput | InventoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Inventory createManyAndReturn
   */
  export type InventoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * The data used to create many Inventories.
     */
    data: InventoryCreateManyInput | InventoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Inventory update
   */
  export type InventoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Inventory.
     */
    data: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>
    /**
     * Choose, which Inventory to update.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory updateMany
   */
  export type InventoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Inventories.
     */
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyInput>
    /**
     * Filter which Inventories to update
     */
    where?: InventoryWhereInput
    /**
     * Limit how many Inventories to update.
     */
    limit?: number
  }

  /**
   * Inventory updateManyAndReturn
   */
  export type InventoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * The data used to update Inventories.
     */
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyInput>
    /**
     * Filter which Inventories to update
     */
    where?: InventoryWhereInput
    /**
     * Limit how many Inventories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Inventory upsert
   */
  export type InventoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Inventory to update in case it exists.
     */
    where: InventoryWhereUniqueInput
    /**
     * In case the Inventory found by the `where` argument doesn't exist, create a new Inventory with this data.
     */
    create: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>
    /**
     * In case the Inventory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>
  }

  /**
   * Inventory delete
   */
  export type InventoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter which Inventory to delete.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory deleteMany
   */
  export type InventoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventories to delete
     */
    where?: InventoryWhereInput
    /**
     * Limit how many Inventories to delete.
     */
    limit?: number
  }

  /**
   * Inventory without action
   */
  export type InventoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
  }


  /**
   * Model Cart
   */

  export type AggregateCart = {
    _count: CartCountAggregateOutputType | null
    _min: CartMinAggregateOutputType | null
    _max: CartMaxAggregateOutputType | null
  }

  export type CartMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    userId: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CartMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    userId: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CartCountAggregateOutputType = {
    id: number
    sessionId: number
    userId: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CartMinAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CartMaxAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CartCountAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cart to aggregate.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Carts
    **/
    _count?: true | CartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CartMaxAggregateInputType
  }

  export type GetCartAggregateType<T extends CartAggregateArgs> = {
        [P in keyof T & keyof AggregateCart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCart[P]>
      : GetScalarType<T[P], AggregateCart[P]>
  }




  export type CartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartWhereInput
    orderBy?: CartOrderByWithAggregationInput | CartOrderByWithAggregationInput[]
    by: CartScalarFieldEnum[] | CartScalarFieldEnum
    having?: CartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CartCountAggregateInputType | true
    _min?: CartMinAggregateInputType
    _max?: CartMaxAggregateInputType
  }

  export type CartGroupByOutputType = {
    id: string
    sessionId: string | null
    userId: string | null
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: CartCountAggregateOutputType | null
    _min: CartMinAggregateOutputType | null
    _max: CartMaxAggregateOutputType | null
  }

  type GetCartGroupByPayload<T extends CartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CartGroupByOutputType[P]>
            : GetScalarType<T[P], CartGroupByOutputType[P]>
        }
      >
    >


  export type CartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Cart$userArgs<ExtArgs>
    items?: boolean | Cart$itemsArgs<ExtArgs>
    _count?: boolean | CartCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cart"]>

  export type CartSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Cart$userArgs<ExtArgs>
  }, ExtArgs["result"]["cart"]>

  export type CartSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Cart$userArgs<ExtArgs>
  }, ExtArgs["result"]["cart"]>

  export type CartSelectScalar = {
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CartOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "userId" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["cart"]>
  export type CartInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Cart$userArgs<ExtArgs>
    items?: boolean | Cart$itemsArgs<ExtArgs>
    _count?: boolean | CartCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CartIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Cart$userArgs<ExtArgs>
  }
  export type CartIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Cart$userArgs<ExtArgs>
  }

  export type $CartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cart"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      items: Prisma.$CartItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string | null
      userId: string | null
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cart"]>
    composites: {}
  }

  type CartGetPayload<S extends boolean | null | undefined | CartDefaultArgs> = $Result.GetResult<Prisma.$CartPayload, S>

  type CartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CartFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CartCountAggregateInputType | true
    }

  export interface CartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cart'], meta: { name: 'Cart' } }
    /**
     * Find zero or one Cart that matches the filter.
     * @param {CartFindUniqueArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CartFindUniqueArgs>(args: SelectSubset<T, CartFindUniqueArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cart that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CartFindUniqueOrThrowArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CartFindUniqueOrThrowArgs>(args: SelectSubset<T, CartFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindFirstArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CartFindFirstArgs>(args?: SelectSubset<T, CartFindFirstArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cart that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindFirstOrThrowArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CartFindFirstOrThrowArgs>(args?: SelectSubset<T, CartFindFirstOrThrowArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Carts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Carts
     * const carts = await prisma.cart.findMany()
     * 
     * // Get first 10 Carts
     * const carts = await prisma.cart.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cartWithIdOnly = await prisma.cart.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CartFindManyArgs>(args?: SelectSubset<T, CartFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cart.
     * @param {CartCreateArgs} args - Arguments to create a Cart.
     * @example
     * // Create one Cart
     * const Cart = await prisma.cart.create({
     *   data: {
     *     // ... data to create a Cart
     *   }
     * })
     * 
     */
    create<T extends CartCreateArgs>(args: SelectSubset<T, CartCreateArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Carts.
     * @param {CartCreateManyArgs} args - Arguments to create many Carts.
     * @example
     * // Create many Carts
     * const cart = await prisma.cart.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CartCreateManyArgs>(args?: SelectSubset<T, CartCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Carts and returns the data saved in the database.
     * @param {CartCreateManyAndReturnArgs} args - Arguments to create many Carts.
     * @example
     * // Create many Carts
     * const cart = await prisma.cart.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Carts and only return the `id`
     * const cartWithIdOnly = await prisma.cart.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CartCreateManyAndReturnArgs>(args?: SelectSubset<T, CartCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cart.
     * @param {CartDeleteArgs} args - Arguments to delete one Cart.
     * @example
     * // Delete one Cart
     * const Cart = await prisma.cart.delete({
     *   where: {
     *     // ... filter to delete one Cart
     *   }
     * })
     * 
     */
    delete<T extends CartDeleteArgs>(args: SelectSubset<T, CartDeleteArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cart.
     * @param {CartUpdateArgs} args - Arguments to update one Cart.
     * @example
     * // Update one Cart
     * const cart = await prisma.cart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CartUpdateArgs>(args: SelectSubset<T, CartUpdateArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Carts.
     * @param {CartDeleteManyArgs} args - Arguments to filter Carts to delete.
     * @example
     * // Delete a few Carts
     * const { count } = await prisma.cart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CartDeleteManyArgs>(args?: SelectSubset<T, CartDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Carts
     * const cart = await prisma.cart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CartUpdateManyArgs>(args: SelectSubset<T, CartUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carts and returns the data updated in the database.
     * @param {CartUpdateManyAndReturnArgs} args - Arguments to update many Carts.
     * @example
     * // Update many Carts
     * const cart = await prisma.cart.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Carts and only return the `id`
     * const cartWithIdOnly = await prisma.cart.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CartUpdateManyAndReturnArgs>(args: SelectSubset<T, CartUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cart.
     * @param {CartUpsertArgs} args - Arguments to update or create a Cart.
     * @example
     * // Update or create a Cart
     * const cart = await prisma.cart.upsert({
     *   create: {
     *     // ... data to create a Cart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cart we want to update
     *   }
     * })
     */
    upsert<T extends CartUpsertArgs>(args: SelectSubset<T, CartUpsertArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Carts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartCountArgs} args - Arguments to filter Carts to count.
     * @example
     * // Count the number of Carts
     * const count = await prisma.cart.count({
     *   where: {
     *     // ... the filter for the Carts we want to count
     *   }
     * })
    **/
    count<T extends CartCountArgs>(
      args?: Subset<T, CartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CartAggregateArgs>(args: Subset<T, CartAggregateArgs>): Prisma.PrismaPromise<GetCartAggregateType<T>>

    /**
     * Group by Cart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CartGroupByArgs['orderBy'] }
        : { orderBy?: CartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cart model
   */
  readonly fields: CartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CartClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Cart$userArgs<ExtArgs> = {}>(args?: Subset<T, Cart$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends Cart$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Cart$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cart model
   */
  interface CartFieldRefs {
    readonly id: FieldRef<"Cart", 'String'>
    readonly sessionId: FieldRef<"Cart", 'String'>
    readonly userId: FieldRef<"Cart", 'String'>
    readonly expiresAt: FieldRef<"Cart", 'DateTime'>
    readonly createdAt: FieldRef<"Cart", 'DateTime'>
    readonly updatedAt: FieldRef<"Cart", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Cart findUnique
   */
  export type CartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart findUniqueOrThrow
   */
  export type CartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart findFirst
   */
  export type CartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Carts.
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Carts.
     */
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * Cart findFirstOrThrow
   */
  export type CartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Carts.
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Carts.
     */
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * Cart findMany
   */
  export type CartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Carts to fetch.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Carts.
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * Cart create
   */
  export type CartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * The data needed to create a Cart.
     */
    data: XOR<CartCreateInput, CartUncheckedCreateInput>
  }

  /**
   * Cart createMany
   */
  export type CartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Carts.
     */
    data: CartCreateManyInput | CartCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cart createManyAndReturn
   */
  export type CartCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * The data used to create many Carts.
     */
    data: CartCreateManyInput | CartCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cart update
   */
  export type CartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * The data needed to update a Cart.
     */
    data: XOR<CartUpdateInput, CartUncheckedUpdateInput>
    /**
     * Choose, which Cart to update.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart updateMany
   */
  export type CartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Carts.
     */
    data: XOR<CartUpdateManyMutationInput, CartUncheckedUpdateManyInput>
    /**
     * Filter which Carts to update
     */
    where?: CartWhereInput
    /**
     * Limit how many Carts to update.
     */
    limit?: number
  }

  /**
   * Cart updateManyAndReturn
   */
  export type CartUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * The data used to update Carts.
     */
    data: XOR<CartUpdateManyMutationInput, CartUncheckedUpdateManyInput>
    /**
     * Filter which Carts to update
     */
    where?: CartWhereInput
    /**
     * Limit how many Carts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cart upsert
   */
  export type CartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * The filter to search for the Cart to update in case it exists.
     */
    where: CartWhereUniqueInput
    /**
     * In case the Cart found by the `where` argument doesn't exist, create a new Cart with this data.
     */
    create: XOR<CartCreateInput, CartUncheckedCreateInput>
    /**
     * In case the Cart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CartUpdateInput, CartUncheckedUpdateInput>
  }

  /**
   * Cart delete
   */
  export type CartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter which Cart to delete.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart deleteMany
   */
  export type CartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Carts to delete
     */
    where?: CartWhereInput
    /**
     * Limit how many Carts to delete.
     */
    limit?: number
  }

  /**
   * Cart.user
   */
  export type Cart$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Cart.items
   */
  export type Cart$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    where?: CartItemWhereInput
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    cursor?: CartItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * Cart without action
   */
  export type CartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
  }


  /**
   * Model CartItem
   */

  export type AggregateCartItem = {
    _count: CartItemCountAggregateOutputType | null
    _avg: CartItemAvgAggregateOutputType | null
    _sum: CartItemSumAggregateOutputType | null
    _min: CartItemMinAggregateOutputType | null
    _max: CartItemMaxAggregateOutputType | null
  }

  export type CartItemAvgAggregateOutputType = {
    quantity: number | null
  }

  export type CartItemSumAggregateOutputType = {
    quantity: number | null
  }

  export type CartItemMinAggregateOutputType = {
    id: string | null
    cartId: string | null
    productId: string | null
    quantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CartItemMaxAggregateOutputType = {
    id: string | null
    cartId: string | null
    productId: string | null
    quantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CartItemCountAggregateOutputType = {
    id: number
    cartId: number
    productId: number
    quantity: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CartItemAvgAggregateInputType = {
    quantity?: true
  }

  export type CartItemSumAggregateInputType = {
    quantity?: true
  }

  export type CartItemMinAggregateInputType = {
    id?: true
    cartId?: true
    productId?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CartItemMaxAggregateInputType = {
    id?: true
    cartId?: true
    productId?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CartItemCountAggregateInputType = {
    id?: true
    cartId?: true
    productId?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CartItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CartItem to aggregate.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CartItems
    **/
    _count?: true | CartItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CartItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CartItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CartItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CartItemMaxAggregateInputType
  }

  export type GetCartItemAggregateType<T extends CartItemAggregateArgs> = {
        [P in keyof T & keyof AggregateCartItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCartItem[P]>
      : GetScalarType<T[P], AggregateCartItem[P]>
  }




  export type CartItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartItemWhereInput
    orderBy?: CartItemOrderByWithAggregationInput | CartItemOrderByWithAggregationInput[]
    by: CartItemScalarFieldEnum[] | CartItemScalarFieldEnum
    having?: CartItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CartItemCountAggregateInputType | true
    _avg?: CartItemAvgAggregateInputType
    _sum?: CartItemSumAggregateInputType
    _min?: CartItemMinAggregateInputType
    _max?: CartItemMaxAggregateInputType
  }

  export type CartItemGroupByOutputType = {
    id: string
    cartId: string
    productId: string
    quantity: number
    createdAt: Date
    updatedAt: Date
    _count: CartItemCountAggregateOutputType | null
    _avg: CartItemAvgAggregateOutputType | null
    _sum: CartItemSumAggregateOutputType | null
    _min: CartItemMinAggregateOutputType | null
    _max: CartItemMaxAggregateOutputType | null
  }

  type GetCartItemGroupByPayload<T extends CartItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CartItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CartItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CartItemGroupByOutputType[P]>
            : GetScalarType<T[P], CartItemGroupByOutputType[P]>
        }
      >
    >


  export type CartItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cartId?: boolean
    productId?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cartItem"]>

  export type CartItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cartId?: boolean
    productId?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cartItem"]>

  export type CartItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cartId?: boolean
    productId?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cartItem"]>

  export type CartItemSelectScalar = {
    id?: boolean
    cartId?: boolean
    productId?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CartItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cartId" | "productId" | "quantity" | "createdAt" | "updatedAt", ExtArgs["result"]["cartItem"]>
  export type CartItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type CartItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type CartItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $CartItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CartItem"
    objects: {
      cart: Prisma.$CartPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cartId: string
      productId: string
      quantity: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cartItem"]>
    composites: {}
  }

  type CartItemGetPayload<S extends boolean | null | undefined | CartItemDefaultArgs> = $Result.GetResult<Prisma.$CartItemPayload, S>

  type CartItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CartItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CartItemCountAggregateInputType | true
    }

  export interface CartItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CartItem'], meta: { name: 'CartItem' } }
    /**
     * Find zero or one CartItem that matches the filter.
     * @param {CartItemFindUniqueArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CartItemFindUniqueArgs>(args: SelectSubset<T, CartItemFindUniqueArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CartItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CartItemFindUniqueOrThrowArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CartItemFindUniqueOrThrowArgs>(args: SelectSubset<T, CartItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CartItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemFindFirstArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CartItemFindFirstArgs>(args?: SelectSubset<T, CartItemFindFirstArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CartItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemFindFirstOrThrowArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CartItemFindFirstOrThrowArgs>(args?: SelectSubset<T, CartItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CartItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CartItems
     * const cartItems = await prisma.cartItem.findMany()
     * 
     * // Get first 10 CartItems
     * const cartItems = await prisma.cartItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cartItemWithIdOnly = await prisma.cartItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CartItemFindManyArgs>(args?: SelectSubset<T, CartItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CartItem.
     * @param {CartItemCreateArgs} args - Arguments to create a CartItem.
     * @example
     * // Create one CartItem
     * const CartItem = await prisma.cartItem.create({
     *   data: {
     *     // ... data to create a CartItem
     *   }
     * })
     * 
     */
    create<T extends CartItemCreateArgs>(args: SelectSubset<T, CartItemCreateArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CartItems.
     * @param {CartItemCreateManyArgs} args - Arguments to create many CartItems.
     * @example
     * // Create many CartItems
     * const cartItem = await prisma.cartItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CartItemCreateManyArgs>(args?: SelectSubset<T, CartItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CartItems and returns the data saved in the database.
     * @param {CartItemCreateManyAndReturnArgs} args - Arguments to create many CartItems.
     * @example
     * // Create many CartItems
     * const cartItem = await prisma.cartItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CartItems and only return the `id`
     * const cartItemWithIdOnly = await prisma.cartItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CartItemCreateManyAndReturnArgs>(args?: SelectSubset<T, CartItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CartItem.
     * @param {CartItemDeleteArgs} args - Arguments to delete one CartItem.
     * @example
     * // Delete one CartItem
     * const CartItem = await prisma.cartItem.delete({
     *   where: {
     *     // ... filter to delete one CartItem
     *   }
     * })
     * 
     */
    delete<T extends CartItemDeleteArgs>(args: SelectSubset<T, CartItemDeleteArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CartItem.
     * @param {CartItemUpdateArgs} args - Arguments to update one CartItem.
     * @example
     * // Update one CartItem
     * const cartItem = await prisma.cartItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CartItemUpdateArgs>(args: SelectSubset<T, CartItemUpdateArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CartItems.
     * @param {CartItemDeleteManyArgs} args - Arguments to filter CartItems to delete.
     * @example
     * // Delete a few CartItems
     * const { count } = await prisma.cartItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CartItemDeleteManyArgs>(args?: SelectSubset<T, CartItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CartItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CartItems
     * const cartItem = await prisma.cartItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CartItemUpdateManyArgs>(args: SelectSubset<T, CartItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CartItems and returns the data updated in the database.
     * @param {CartItemUpdateManyAndReturnArgs} args - Arguments to update many CartItems.
     * @example
     * // Update many CartItems
     * const cartItem = await prisma.cartItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CartItems and only return the `id`
     * const cartItemWithIdOnly = await prisma.cartItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CartItemUpdateManyAndReturnArgs>(args: SelectSubset<T, CartItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CartItem.
     * @param {CartItemUpsertArgs} args - Arguments to update or create a CartItem.
     * @example
     * // Update or create a CartItem
     * const cartItem = await prisma.cartItem.upsert({
     *   create: {
     *     // ... data to create a CartItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CartItem we want to update
     *   }
     * })
     */
    upsert<T extends CartItemUpsertArgs>(args: SelectSubset<T, CartItemUpsertArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CartItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemCountArgs} args - Arguments to filter CartItems to count.
     * @example
     * // Count the number of CartItems
     * const count = await prisma.cartItem.count({
     *   where: {
     *     // ... the filter for the CartItems we want to count
     *   }
     * })
    **/
    count<T extends CartItemCountArgs>(
      args?: Subset<T, CartItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CartItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CartItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CartItemAggregateArgs>(args: Subset<T, CartItemAggregateArgs>): Prisma.PrismaPromise<GetCartItemAggregateType<T>>

    /**
     * Group by CartItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CartItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CartItemGroupByArgs['orderBy'] }
        : { orderBy?: CartItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CartItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCartItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CartItem model
   */
  readonly fields: CartItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CartItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CartItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cart<T extends CartDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CartDefaultArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CartItem model
   */
  interface CartItemFieldRefs {
    readonly id: FieldRef<"CartItem", 'String'>
    readonly cartId: FieldRef<"CartItem", 'String'>
    readonly productId: FieldRef<"CartItem", 'String'>
    readonly quantity: FieldRef<"CartItem", 'Int'>
    readonly createdAt: FieldRef<"CartItem", 'DateTime'>
    readonly updatedAt: FieldRef<"CartItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CartItem findUnique
   */
  export type CartItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem findUniqueOrThrow
   */
  export type CartItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem findFirst
   */
  export type CartItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CartItems.
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CartItems.
     */
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * CartItem findFirstOrThrow
   */
  export type CartItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CartItems.
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CartItems.
     */
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * CartItem findMany
   */
  export type CartItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItems to fetch.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CartItems.
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * CartItem create
   */
  export type CartItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * The data needed to create a CartItem.
     */
    data: XOR<CartItemCreateInput, CartItemUncheckedCreateInput>
  }

  /**
   * CartItem createMany
   */
  export type CartItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CartItems.
     */
    data: CartItemCreateManyInput | CartItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CartItem createManyAndReturn
   */
  export type CartItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * The data used to create many CartItems.
     */
    data: CartItemCreateManyInput | CartItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CartItem update
   */
  export type CartItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * The data needed to update a CartItem.
     */
    data: XOR<CartItemUpdateInput, CartItemUncheckedUpdateInput>
    /**
     * Choose, which CartItem to update.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem updateMany
   */
  export type CartItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CartItems.
     */
    data: XOR<CartItemUpdateManyMutationInput, CartItemUncheckedUpdateManyInput>
    /**
     * Filter which CartItems to update
     */
    where?: CartItemWhereInput
    /**
     * Limit how many CartItems to update.
     */
    limit?: number
  }

  /**
   * CartItem updateManyAndReturn
   */
  export type CartItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * The data used to update CartItems.
     */
    data: XOR<CartItemUpdateManyMutationInput, CartItemUncheckedUpdateManyInput>
    /**
     * Filter which CartItems to update
     */
    where?: CartItemWhereInput
    /**
     * Limit how many CartItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CartItem upsert
   */
  export type CartItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * The filter to search for the CartItem to update in case it exists.
     */
    where: CartItemWhereUniqueInput
    /**
     * In case the CartItem found by the `where` argument doesn't exist, create a new CartItem with this data.
     */
    create: XOR<CartItemCreateInput, CartItemUncheckedCreateInput>
    /**
     * In case the CartItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CartItemUpdateInput, CartItemUncheckedUpdateInput>
  }

  /**
   * CartItem delete
   */
  export type CartItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter which CartItem to delete.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem deleteMany
   */
  export type CartItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CartItems to delete
     */
    where?: CartItemWhereInput
    /**
     * Limit how many CartItems to delete.
     */
    limit?: number
  }

  /**
   * CartItem without action
   */
  export type CartItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
  }


  /**
   * Model PriceHistory
   */

  export type AggregatePriceHistory = {
    _count: PriceHistoryCountAggregateOutputType | null
    _avg: PriceHistoryAvgAggregateOutputType | null
    _sum: PriceHistorySumAggregateOutputType | null
    _min: PriceHistoryMinAggregateOutputType | null
    _max: PriceHistoryMaxAggregateOutputType | null
  }

  export type PriceHistoryAvgAggregateOutputType = {
    price: number | null
    previousPrice: number | null
  }

  export type PriceHistorySumAggregateOutputType = {
    price: number | null
    previousPrice: number | null
  }

  export type PriceHistoryMinAggregateOutputType = {
    id: string | null
    productId: string | null
    price: number | null
    previousPrice: number | null
    currency: string | null
    reason: string | null
    effectiveFrom: Date | null
    effectiveUntil: Date | null
    createdAt: Date | null
  }

  export type PriceHistoryMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    price: number | null
    previousPrice: number | null
    currency: string | null
    reason: string | null
    effectiveFrom: Date | null
    effectiveUntil: Date | null
    createdAt: Date | null
  }

  export type PriceHistoryCountAggregateOutputType = {
    id: number
    productId: number
    price: number
    previousPrice: number
    currency: number
    reason: number
    effectiveFrom: number
    effectiveUntil: number
    createdAt: number
    _all: number
  }


  export type PriceHistoryAvgAggregateInputType = {
    price?: true
    previousPrice?: true
  }

  export type PriceHistorySumAggregateInputType = {
    price?: true
    previousPrice?: true
  }

  export type PriceHistoryMinAggregateInputType = {
    id?: true
    productId?: true
    price?: true
    previousPrice?: true
    currency?: true
    reason?: true
    effectiveFrom?: true
    effectiveUntil?: true
    createdAt?: true
  }

  export type PriceHistoryMaxAggregateInputType = {
    id?: true
    productId?: true
    price?: true
    previousPrice?: true
    currency?: true
    reason?: true
    effectiveFrom?: true
    effectiveUntil?: true
    createdAt?: true
  }

  export type PriceHistoryCountAggregateInputType = {
    id?: true
    productId?: true
    price?: true
    previousPrice?: true
    currency?: true
    reason?: true
    effectiveFrom?: true
    effectiveUntil?: true
    createdAt?: true
    _all?: true
  }

  export type PriceHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PriceHistory to aggregate.
     */
    where?: PriceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceHistories to fetch.
     */
    orderBy?: PriceHistoryOrderByWithRelationInput | PriceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PriceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PriceHistories
    **/
    _count?: true | PriceHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PriceHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PriceHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PriceHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PriceHistoryMaxAggregateInputType
  }

  export type GetPriceHistoryAggregateType<T extends PriceHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregatePriceHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePriceHistory[P]>
      : GetScalarType<T[P], AggregatePriceHistory[P]>
  }




  export type PriceHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PriceHistoryWhereInput
    orderBy?: PriceHistoryOrderByWithAggregationInput | PriceHistoryOrderByWithAggregationInput[]
    by: PriceHistoryScalarFieldEnum[] | PriceHistoryScalarFieldEnum
    having?: PriceHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PriceHistoryCountAggregateInputType | true
    _avg?: PriceHistoryAvgAggregateInputType
    _sum?: PriceHistorySumAggregateInputType
    _min?: PriceHistoryMinAggregateInputType
    _max?: PriceHistoryMaxAggregateInputType
  }

  export type PriceHistoryGroupByOutputType = {
    id: string
    productId: string
    price: number
    previousPrice: number | null
    currency: string
    reason: string | null
    effectiveFrom: Date
    effectiveUntil: Date | null
    createdAt: Date
    _count: PriceHistoryCountAggregateOutputType | null
    _avg: PriceHistoryAvgAggregateOutputType | null
    _sum: PriceHistorySumAggregateOutputType | null
    _min: PriceHistoryMinAggregateOutputType | null
    _max: PriceHistoryMaxAggregateOutputType | null
  }

  type GetPriceHistoryGroupByPayload<T extends PriceHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PriceHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PriceHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PriceHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], PriceHistoryGroupByOutputType[P]>
        }
      >
    >


  export type PriceHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    price?: boolean
    previousPrice?: boolean
    currency?: boolean
    reason?: boolean
    effectiveFrom?: boolean
    effectiveUntil?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["priceHistory"]>

  export type PriceHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    price?: boolean
    previousPrice?: boolean
    currency?: boolean
    reason?: boolean
    effectiveFrom?: boolean
    effectiveUntil?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["priceHistory"]>

  export type PriceHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    price?: boolean
    previousPrice?: boolean
    currency?: boolean
    reason?: boolean
    effectiveFrom?: boolean
    effectiveUntil?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["priceHistory"]>

  export type PriceHistorySelectScalar = {
    id?: boolean
    productId?: boolean
    price?: boolean
    previousPrice?: boolean
    currency?: boolean
    reason?: boolean
    effectiveFrom?: boolean
    effectiveUntil?: boolean
    createdAt?: boolean
  }

  export type PriceHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "price" | "previousPrice" | "currency" | "reason" | "effectiveFrom" | "effectiveUntil" | "createdAt", ExtArgs["result"]["priceHistory"]>
  export type PriceHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type PriceHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type PriceHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $PriceHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PriceHistory"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      price: number
      previousPrice: number | null
      currency: string
      reason: string | null
      effectiveFrom: Date
      effectiveUntil: Date | null
      createdAt: Date
    }, ExtArgs["result"]["priceHistory"]>
    composites: {}
  }

  type PriceHistoryGetPayload<S extends boolean | null | undefined | PriceHistoryDefaultArgs> = $Result.GetResult<Prisma.$PriceHistoryPayload, S>

  type PriceHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PriceHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PriceHistoryCountAggregateInputType | true
    }

  export interface PriceHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PriceHistory'], meta: { name: 'PriceHistory' } }
    /**
     * Find zero or one PriceHistory that matches the filter.
     * @param {PriceHistoryFindUniqueArgs} args - Arguments to find a PriceHistory
     * @example
     * // Get one PriceHistory
     * const priceHistory = await prisma.priceHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PriceHistoryFindUniqueArgs>(args: SelectSubset<T, PriceHistoryFindUniqueArgs<ExtArgs>>): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PriceHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PriceHistoryFindUniqueOrThrowArgs} args - Arguments to find a PriceHistory
     * @example
     * // Get one PriceHistory
     * const priceHistory = await prisma.priceHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PriceHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, PriceHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PriceHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryFindFirstArgs} args - Arguments to find a PriceHistory
     * @example
     * // Get one PriceHistory
     * const priceHistory = await prisma.priceHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PriceHistoryFindFirstArgs>(args?: SelectSubset<T, PriceHistoryFindFirstArgs<ExtArgs>>): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PriceHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryFindFirstOrThrowArgs} args - Arguments to find a PriceHistory
     * @example
     * // Get one PriceHistory
     * const priceHistory = await prisma.priceHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PriceHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, PriceHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PriceHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PriceHistories
     * const priceHistories = await prisma.priceHistory.findMany()
     * 
     * // Get first 10 PriceHistories
     * const priceHistories = await prisma.priceHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const priceHistoryWithIdOnly = await prisma.priceHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PriceHistoryFindManyArgs>(args?: SelectSubset<T, PriceHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PriceHistory.
     * @param {PriceHistoryCreateArgs} args - Arguments to create a PriceHistory.
     * @example
     * // Create one PriceHistory
     * const PriceHistory = await prisma.priceHistory.create({
     *   data: {
     *     // ... data to create a PriceHistory
     *   }
     * })
     * 
     */
    create<T extends PriceHistoryCreateArgs>(args: SelectSubset<T, PriceHistoryCreateArgs<ExtArgs>>): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PriceHistories.
     * @param {PriceHistoryCreateManyArgs} args - Arguments to create many PriceHistories.
     * @example
     * // Create many PriceHistories
     * const priceHistory = await prisma.priceHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PriceHistoryCreateManyArgs>(args?: SelectSubset<T, PriceHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PriceHistories and returns the data saved in the database.
     * @param {PriceHistoryCreateManyAndReturnArgs} args - Arguments to create many PriceHistories.
     * @example
     * // Create many PriceHistories
     * const priceHistory = await prisma.priceHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PriceHistories and only return the `id`
     * const priceHistoryWithIdOnly = await prisma.priceHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PriceHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, PriceHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PriceHistory.
     * @param {PriceHistoryDeleteArgs} args - Arguments to delete one PriceHistory.
     * @example
     * // Delete one PriceHistory
     * const PriceHistory = await prisma.priceHistory.delete({
     *   where: {
     *     // ... filter to delete one PriceHistory
     *   }
     * })
     * 
     */
    delete<T extends PriceHistoryDeleteArgs>(args: SelectSubset<T, PriceHistoryDeleteArgs<ExtArgs>>): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PriceHistory.
     * @param {PriceHistoryUpdateArgs} args - Arguments to update one PriceHistory.
     * @example
     * // Update one PriceHistory
     * const priceHistory = await prisma.priceHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PriceHistoryUpdateArgs>(args: SelectSubset<T, PriceHistoryUpdateArgs<ExtArgs>>): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PriceHistories.
     * @param {PriceHistoryDeleteManyArgs} args - Arguments to filter PriceHistories to delete.
     * @example
     * // Delete a few PriceHistories
     * const { count } = await prisma.priceHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PriceHistoryDeleteManyArgs>(args?: SelectSubset<T, PriceHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PriceHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PriceHistories
     * const priceHistory = await prisma.priceHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PriceHistoryUpdateManyArgs>(args: SelectSubset<T, PriceHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PriceHistories and returns the data updated in the database.
     * @param {PriceHistoryUpdateManyAndReturnArgs} args - Arguments to update many PriceHistories.
     * @example
     * // Update many PriceHistories
     * const priceHistory = await prisma.priceHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PriceHistories and only return the `id`
     * const priceHistoryWithIdOnly = await prisma.priceHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PriceHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, PriceHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PriceHistory.
     * @param {PriceHistoryUpsertArgs} args - Arguments to update or create a PriceHistory.
     * @example
     * // Update or create a PriceHistory
     * const priceHistory = await prisma.priceHistory.upsert({
     *   create: {
     *     // ... data to create a PriceHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PriceHistory we want to update
     *   }
     * })
     */
    upsert<T extends PriceHistoryUpsertArgs>(args: SelectSubset<T, PriceHistoryUpsertArgs<ExtArgs>>): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PriceHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryCountArgs} args - Arguments to filter PriceHistories to count.
     * @example
     * // Count the number of PriceHistories
     * const count = await prisma.priceHistory.count({
     *   where: {
     *     // ... the filter for the PriceHistories we want to count
     *   }
     * })
    **/
    count<T extends PriceHistoryCountArgs>(
      args?: Subset<T, PriceHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PriceHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PriceHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PriceHistoryAggregateArgs>(args: Subset<T, PriceHistoryAggregateArgs>): Prisma.PrismaPromise<GetPriceHistoryAggregateType<T>>

    /**
     * Group by PriceHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PriceHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PriceHistoryGroupByArgs['orderBy'] }
        : { orderBy?: PriceHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PriceHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPriceHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PriceHistory model
   */
  readonly fields: PriceHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PriceHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PriceHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PriceHistory model
   */
  interface PriceHistoryFieldRefs {
    readonly id: FieldRef<"PriceHistory", 'String'>
    readonly productId: FieldRef<"PriceHistory", 'String'>
    readonly price: FieldRef<"PriceHistory", 'Float'>
    readonly previousPrice: FieldRef<"PriceHistory", 'Float'>
    readonly currency: FieldRef<"PriceHistory", 'String'>
    readonly reason: FieldRef<"PriceHistory", 'String'>
    readonly effectiveFrom: FieldRef<"PriceHistory", 'DateTime'>
    readonly effectiveUntil: FieldRef<"PriceHistory", 'DateTime'>
    readonly createdAt: FieldRef<"PriceHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PriceHistory findUnique
   */
  export type PriceHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceHistory
     */
    omit?: PriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PriceHistory to fetch.
     */
    where: PriceHistoryWhereUniqueInput
  }

  /**
   * PriceHistory findUniqueOrThrow
   */
  export type PriceHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceHistory
     */
    omit?: PriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PriceHistory to fetch.
     */
    where: PriceHistoryWhereUniqueInput
  }

  /**
   * PriceHistory findFirst
   */
  export type PriceHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceHistory
     */
    omit?: PriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PriceHistory to fetch.
     */
    where?: PriceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceHistories to fetch.
     */
    orderBy?: PriceHistoryOrderByWithRelationInput | PriceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PriceHistories.
     */
    cursor?: PriceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PriceHistories.
     */
    distinct?: PriceHistoryScalarFieldEnum | PriceHistoryScalarFieldEnum[]
  }

  /**
   * PriceHistory findFirstOrThrow
   */
  export type PriceHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceHistory
     */
    omit?: PriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PriceHistory to fetch.
     */
    where?: PriceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceHistories to fetch.
     */
    orderBy?: PriceHistoryOrderByWithRelationInput | PriceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PriceHistories.
     */
    cursor?: PriceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PriceHistories.
     */
    distinct?: PriceHistoryScalarFieldEnum | PriceHistoryScalarFieldEnum[]
  }

  /**
   * PriceHistory findMany
   */
  export type PriceHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceHistory
     */
    omit?: PriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PriceHistories to fetch.
     */
    where?: PriceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceHistories to fetch.
     */
    orderBy?: PriceHistoryOrderByWithRelationInput | PriceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PriceHistories.
     */
    cursor?: PriceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceHistories.
     */
    skip?: number
    distinct?: PriceHistoryScalarFieldEnum | PriceHistoryScalarFieldEnum[]
  }

  /**
   * PriceHistory create
   */
  export type PriceHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceHistory
     */
    omit?: PriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a PriceHistory.
     */
    data: XOR<PriceHistoryCreateInput, PriceHistoryUncheckedCreateInput>
  }

  /**
   * PriceHistory createMany
   */
  export type PriceHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PriceHistories.
     */
    data: PriceHistoryCreateManyInput | PriceHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PriceHistory createManyAndReturn
   */
  export type PriceHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PriceHistory
     */
    omit?: PriceHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many PriceHistories.
     */
    data: PriceHistoryCreateManyInput | PriceHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PriceHistory update
   */
  export type PriceHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceHistory
     */
    omit?: PriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a PriceHistory.
     */
    data: XOR<PriceHistoryUpdateInput, PriceHistoryUncheckedUpdateInput>
    /**
     * Choose, which PriceHistory to update.
     */
    where: PriceHistoryWhereUniqueInput
  }

  /**
   * PriceHistory updateMany
   */
  export type PriceHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PriceHistories.
     */
    data: XOR<PriceHistoryUpdateManyMutationInput, PriceHistoryUncheckedUpdateManyInput>
    /**
     * Filter which PriceHistories to update
     */
    where?: PriceHistoryWhereInput
    /**
     * Limit how many PriceHistories to update.
     */
    limit?: number
  }

  /**
   * PriceHistory updateManyAndReturn
   */
  export type PriceHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PriceHistory
     */
    omit?: PriceHistoryOmit<ExtArgs> | null
    /**
     * The data used to update PriceHistories.
     */
    data: XOR<PriceHistoryUpdateManyMutationInput, PriceHistoryUncheckedUpdateManyInput>
    /**
     * Filter which PriceHistories to update
     */
    where?: PriceHistoryWhereInput
    /**
     * Limit how many PriceHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PriceHistory upsert
   */
  export type PriceHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceHistory
     */
    omit?: PriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the PriceHistory to update in case it exists.
     */
    where: PriceHistoryWhereUniqueInput
    /**
     * In case the PriceHistory found by the `where` argument doesn't exist, create a new PriceHistory with this data.
     */
    create: XOR<PriceHistoryCreateInput, PriceHistoryUncheckedCreateInput>
    /**
     * In case the PriceHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PriceHistoryUpdateInput, PriceHistoryUncheckedUpdateInput>
  }

  /**
   * PriceHistory delete
   */
  export type PriceHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceHistory
     */
    omit?: PriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * Filter which PriceHistory to delete.
     */
    where: PriceHistoryWhereUniqueInput
  }

  /**
   * PriceHistory deleteMany
   */
  export type PriceHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PriceHistories to delete
     */
    where?: PriceHistoryWhereInput
    /**
     * Limit how many PriceHistories to delete.
     */
    limit?: number
  }

  /**
   * PriceHistory without action
   */
  export type PriceHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceHistory
     */
    omit?: PriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryInclude<ExtArgs> | null
  }


  /**
   * Model SystemHealth
   */

  export type AggregateSystemHealth = {
    _count: SystemHealthCountAggregateOutputType | null
    _avg: SystemHealthAvgAggregateOutputType | null
    _sum: SystemHealthSumAggregateOutputType | null
    _min: SystemHealthMinAggregateOutputType | null
    _max: SystemHealthMaxAggregateOutputType | null
  }

  export type SystemHealthAvgAggregateOutputType = {
    responseTime: number | null
    errorRate: number | null
    uptime: number | null
  }

  export type SystemHealthSumAggregateOutputType = {
    responseTime: number | null
    errorRate: number | null
    uptime: number | null
  }

  export type SystemHealthMinAggregateOutputType = {
    id: string | null
    service: string | null
    status: string | null
    responseTime: number | null
    errorRate: number | null
    uptime: number | null
    message: string | null
    lastCheck: Date | null
    nextCheck: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemHealthMaxAggregateOutputType = {
    id: string | null
    service: string | null
    status: string | null
    responseTime: number | null
    errorRate: number | null
    uptime: number | null
    message: string | null
    lastCheck: Date | null
    nextCheck: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemHealthCountAggregateOutputType = {
    id: number
    service: number
    status: number
    responseTime: number
    errorRate: number
    uptime: number
    message: number
    lastCheck: number
    nextCheck: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SystemHealthAvgAggregateInputType = {
    responseTime?: true
    errorRate?: true
    uptime?: true
  }

  export type SystemHealthSumAggregateInputType = {
    responseTime?: true
    errorRate?: true
    uptime?: true
  }

  export type SystemHealthMinAggregateInputType = {
    id?: true
    service?: true
    status?: true
    responseTime?: true
    errorRate?: true
    uptime?: true
    message?: true
    lastCheck?: true
    nextCheck?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemHealthMaxAggregateInputType = {
    id?: true
    service?: true
    status?: true
    responseTime?: true
    errorRate?: true
    uptime?: true
    message?: true
    lastCheck?: true
    nextCheck?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemHealthCountAggregateInputType = {
    id?: true
    service?: true
    status?: true
    responseTime?: true
    errorRate?: true
    uptime?: true
    message?: true
    lastCheck?: true
    nextCheck?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SystemHealthAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemHealth to aggregate.
     */
    where?: SystemHealthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemHealths to fetch.
     */
    orderBy?: SystemHealthOrderByWithRelationInput | SystemHealthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemHealthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemHealths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemHealths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemHealths
    **/
    _count?: true | SystemHealthCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemHealthAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemHealthSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemHealthMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemHealthMaxAggregateInputType
  }

  export type GetSystemHealthAggregateType<T extends SystemHealthAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemHealth]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemHealth[P]>
      : GetScalarType<T[P], AggregateSystemHealth[P]>
  }




  export type SystemHealthGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemHealthWhereInput
    orderBy?: SystemHealthOrderByWithAggregationInput | SystemHealthOrderByWithAggregationInput[]
    by: SystemHealthScalarFieldEnum[] | SystemHealthScalarFieldEnum
    having?: SystemHealthScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemHealthCountAggregateInputType | true
    _avg?: SystemHealthAvgAggregateInputType
    _sum?: SystemHealthSumAggregateInputType
    _min?: SystemHealthMinAggregateInputType
    _max?: SystemHealthMaxAggregateInputType
  }

  export type SystemHealthGroupByOutputType = {
    id: string
    service: string
    status: string
    responseTime: number | null
    errorRate: number | null
    uptime: number | null
    message: string | null
    lastCheck: Date
    nextCheck: Date | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: SystemHealthCountAggregateOutputType | null
    _avg: SystemHealthAvgAggregateOutputType | null
    _sum: SystemHealthSumAggregateOutputType | null
    _min: SystemHealthMinAggregateOutputType | null
    _max: SystemHealthMaxAggregateOutputType | null
  }

  type GetSystemHealthGroupByPayload<T extends SystemHealthGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemHealthGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemHealthGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemHealthGroupByOutputType[P]>
            : GetScalarType<T[P], SystemHealthGroupByOutputType[P]>
        }
      >
    >


  export type SystemHealthSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service?: boolean
    status?: boolean
    responseTime?: boolean
    errorRate?: boolean
    uptime?: boolean
    message?: boolean
    lastCheck?: boolean
    nextCheck?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemHealth"]>

  export type SystemHealthSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service?: boolean
    status?: boolean
    responseTime?: boolean
    errorRate?: boolean
    uptime?: boolean
    message?: boolean
    lastCheck?: boolean
    nextCheck?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemHealth"]>

  export type SystemHealthSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service?: boolean
    status?: boolean
    responseTime?: boolean
    errorRate?: boolean
    uptime?: boolean
    message?: boolean
    lastCheck?: boolean
    nextCheck?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemHealth"]>

  export type SystemHealthSelectScalar = {
    id?: boolean
    service?: boolean
    status?: boolean
    responseTime?: boolean
    errorRate?: boolean
    uptime?: boolean
    message?: boolean
    lastCheck?: boolean
    nextCheck?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SystemHealthOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "service" | "status" | "responseTime" | "errorRate" | "uptime" | "message" | "lastCheck" | "nextCheck" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["systemHealth"]>

  export type $SystemHealthPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemHealth"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      service: string
      status: string
      responseTime: number | null
      errorRate: number | null
      uptime: number | null
      message: string | null
      lastCheck: Date
      nextCheck: Date | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["systemHealth"]>
    composites: {}
  }

  type SystemHealthGetPayload<S extends boolean | null | undefined | SystemHealthDefaultArgs> = $Result.GetResult<Prisma.$SystemHealthPayload, S>

  type SystemHealthCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemHealthFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemHealthCountAggregateInputType | true
    }

  export interface SystemHealthDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemHealth'], meta: { name: 'SystemHealth' } }
    /**
     * Find zero or one SystemHealth that matches the filter.
     * @param {SystemHealthFindUniqueArgs} args - Arguments to find a SystemHealth
     * @example
     * // Get one SystemHealth
     * const systemHealth = await prisma.systemHealth.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemHealthFindUniqueArgs>(args: SelectSubset<T, SystemHealthFindUniqueArgs<ExtArgs>>): Prisma__SystemHealthClient<$Result.GetResult<Prisma.$SystemHealthPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemHealth that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemHealthFindUniqueOrThrowArgs} args - Arguments to find a SystemHealth
     * @example
     * // Get one SystemHealth
     * const systemHealth = await prisma.systemHealth.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemHealthFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemHealthFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemHealthClient<$Result.GetResult<Prisma.$SystemHealthPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemHealth that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemHealthFindFirstArgs} args - Arguments to find a SystemHealth
     * @example
     * // Get one SystemHealth
     * const systemHealth = await prisma.systemHealth.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemHealthFindFirstArgs>(args?: SelectSubset<T, SystemHealthFindFirstArgs<ExtArgs>>): Prisma__SystemHealthClient<$Result.GetResult<Prisma.$SystemHealthPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemHealth that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemHealthFindFirstOrThrowArgs} args - Arguments to find a SystemHealth
     * @example
     * // Get one SystemHealth
     * const systemHealth = await prisma.systemHealth.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemHealthFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemHealthFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemHealthClient<$Result.GetResult<Prisma.$SystemHealthPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemHealths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemHealthFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemHealths
     * const systemHealths = await prisma.systemHealth.findMany()
     * 
     * // Get first 10 SystemHealths
     * const systemHealths = await prisma.systemHealth.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemHealthWithIdOnly = await prisma.systemHealth.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemHealthFindManyArgs>(args?: SelectSubset<T, SystemHealthFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemHealthPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemHealth.
     * @param {SystemHealthCreateArgs} args - Arguments to create a SystemHealth.
     * @example
     * // Create one SystemHealth
     * const SystemHealth = await prisma.systemHealth.create({
     *   data: {
     *     // ... data to create a SystemHealth
     *   }
     * })
     * 
     */
    create<T extends SystemHealthCreateArgs>(args: SelectSubset<T, SystemHealthCreateArgs<ExtArgs>>): Prisma__SystemHealthClient<$Result.GetResult<Prisma.$SystemHealthPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemHealths.
     * @param {SystemHealthCreateManyArgs} args - Arguments to create many SystemHealths.
     * @example
     * // Create many SystemHealths
     * const systemHealth = await prisma.systemHealth.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemHealthCreateManyArgs>(args?: SelectSubset<T, SystemHealthCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemHealths and returns the data saved in the database.
     * @param {SystemHealthCreateManyAndReturnArgs} args - Arguments to create many SystemHealths.
     * @example
     * // Create many SystemHealths
     * const systemHealth = await prisma.systemHealth.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemHealths and only return the `id`
     * const systemHealthWithIdOnly = await prisma.systemHealth.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemHealthCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemHealthCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemHealthPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemHealth.
     * @param {SystemHealthDeleteArgs} args - Arguments to delete one SystemHealth.
     * @example
     * // Delete one SystemHealth
     * const SystemHealth = await prisma.systemHealth.delete({
     *   where: {
     *     // ... filter to delete one SystemHealth
     *   }
     * })
     * 
     */
    delete<T extends SystemHealthDeleteArgs>(args: SelectSubset<T, SystemHealthDeleteArgs<ExtArgs>>): Prisma__SystemHealthClient<$Result.GetResult<Prisma.$SystemHealthPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemHealth.
     * @param {SystemHealthUpdateArgs} args - Arguments to update one SystemHealth.
     * @example
     * // Update one SystemHealth
     * const systemHealth = await prisma.systemHealth.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemHealthUpdateArgs>(args: SelectSubset<T, SystemHealthUpdateArgs<ExtArgs>>): Prisma__SystemHealthClient<$Result.GetResult<Prisma.$SystemHealthPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemHealths.
     * @param {SystemHealthDeleteManyArgs} args - Arguments to filter SystemHealths to delete.
     * @example
     * // Delete a few SystemHealths
     * const { count } = await prisma.systemHealth.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemHealthDeleteManyArgs>(args?: SelectSubset<T, SystemHealthDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemHealths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemHealthUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemHealths
     * const systemHealth = await prisma.systemHealth.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemHealthUpdateManyArgs>(args: SelectSubset<T, SystemHealthUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemHealths and returns the data updated in the database.
     * @param {SystemHealthUpdateManyAndReturnArgs} args - Arguments to update many SystemHealths.
     * @example
     * // Update many SystemHealths
     * const systemHealth = await prisma.systemHealth.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemHealths and only return the `id`
     * const systemHealthWithIdOnly = await prisma.systemHealth.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemHealthUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemHealthUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemHealthPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemHealth.
     * @param {SystemHealthUpsertArgs} args - Arguments to update or create a SystemHealth.
     * @example
     * // Update or create a SystemHealth
     * const systemHealth = await prisma.systemHealth.upsert({
     *   create: {
     *     // ... data to create a SystemHealth
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemHealth we want to update
     *   }
     * })
     */
    upsert<T extends SystemHealthUpsertArgs>(args: SelectSubset<T, SystemHealthUpsertArgs<ExtArgs>>): Prisma__SystemHealthClient<$Result.GetResult<Prisma.$SystemHealthPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemHealths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemHealthCountArgs} args - Arguments to filter SystemHealths to count.
     * @example
     * // Count the number of SystemHealths
     * const count = await prisma.systemHealth.count({
     *   where: {
     *     // ... the filter for the SystemHealths we want to count
     *   }
     * })
    **/
    count<T extends SystemHealthCountArgs>(
      args?: Subset<T, SystemHealthCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemHealthCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemHealth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemHealthAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemHealthAggregateArgs>(args: Subset<T, SystemHealthAggregateArgs>): Prisma.PrismaPromise<GetSystemHealthAggregateType<T>>

    /**
     * Group by SystemHealth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemHealthGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemHealthGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemHealthGroupByArgs['orderBy'] }
        : { orderBy?: SystemHealthGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemHealthGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemHealthGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemHealth model
   */
  readonly fields: SystemHealthFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemHealth.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemHealthClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemHealth model
   */
  interface SystemHealthFieldRefs {
    readonly id: FieldRef<"SystemHealth", 'String'>
    readonly service: FieldRef<"SystemHealth", 'String'>
    readonly status: FieldRef<"SystemHealth", 'String'>
    readonly responseTime: FieldRef<"SystemHealth", 'Float'>
    readonly errorRate: FieldRef<"SystemHealth", 'Float'>
    readonly uptime: FieldRef<"SystemHealth", 'Float'>
    readonly message: FieldRef<"SystemHealth", 'String'>
    readonly lastCheck: FieldRef<"SystemHealth", 'DateTime'>
    readonly nextCheck: FieldRef<"SystemHealth", 'DateTime'>
    readonly metadata: FieldRef<"SystemHealth", 'Json'>
    readonly createdAt: FieldRef<"SystemHealth", 'DateTime'>
    readonly updatedAt: FieldRef<"SystemHealth", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemHealth findUnique
   */
  export type SystemHealthFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemHealth
     */
    select?: SystemHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemHealth
     */
    omit?: SystemHealthOmit<ExtArgs> | null
    /**
     * Filter, which SystemHealth to fetch.
     */
    where: SystemHealthWhereUniqueInput
  }

  /**
   * SystemHealth findUniqueOrThrow
   */
  export type SystemHealthFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemHealth
     */
    select?: SystemHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemHealth
     */
    omit?: SystemHealthOmit<ExtArgs> | null
    /**
     * Filter, which SystemHealth to fetch.
     */
    where: SystemHealthWhereUniqueInput
  }

  /**
   * SystemHealth findFirst
   */
  export type SystemHealthFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemHealth
     */
    select?: SystemHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemHealth
     */
    omit?: SystemHealthOmit<ExtArgs> | null
    /**
     * Filter, which SystemHealth to fetch.
     */
    where?: SystemHealthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemHealths to fetch.
     */
    orderBy?: SystemHealthOrderByWithRelationInput | SystemHealthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemHealths.
     */
    cursor?: SystemHealthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemHealths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemHealths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemHealths.
     */
    distinct?: SystemHealthScalarFieldEnum | SystemHealthScalarFieldEnum[]
  }

  /**
   * SystemHealth findFirstOrThrow
   */
  export type SystemHealthFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemHealth
     */
    select?: SystemHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemHealth
     */
    omit?: SystemHealthOmit<ExtArgs> | null
    /**
     * Filter, which SystemHealth to fetch.
     */
    where?: SystemHealthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemHealths to fetch.
     */
    orderBy?: SystemHealthOrderByWithRelationInput | SystemHealthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemHealths.
     */
    cursor?: SystemHealthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemHealths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemHealths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemHealths.
     */
    distinct?: SystemHealthScalarFieldEnum | SystemHealthScalarFieldEnum[]
  }

  /**
   * SystemHealth findMany
   */
  export type SystemHealthFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemHealth
     */
    select?: SystemHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemHealth
     */
    omit?: SystemHealthOmit<ExtArgs> | null
    /**
     * Filter, which SystemHealths to fetch.
     */
    where?: SystemHealthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemHealths to fetch.
     */
    orderBy?: SystemHealthOrderByWithRelationInput | SystemHealthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemHealths.
     */
    cursor?: SystemHealthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemHealths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemHealths.
     */
    skip?: number
    distinct?: SystemHealthScalarFieldEnum | SystemHealthScalarFieldEnum[]
  }

  /**
   * SystemHealth create
   */
  export type SystemHealthCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemHealth
     */
    select?: SystemHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemHealth
     */
    omit?: SystemHealthOmit<ExtArgs> | null
    /**
     * The data needed to create a SystemHealth.
     */
    data: XOR<SystemHealthCreateInput, SystemHealthUncheckedCreateInput>
  }

  /**
   * SystemHealth createMany
   */
  export type SystemHealthCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemHealths.
     */
    data: SystemHealthCreateManyInput | SystemHealthCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemHealth createManyAndReturn
   */
  export type SystemHealthCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemHealth
     */
    select?: SystemHealthSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemHealth
     */
    omit?: SystemHealthOmit<ExtArgs> | null
    /**
     * The data used to create many SystemHealths.
     */
    data: SystemHealthCreateManyInput | SystemHealthCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemHealth update
   */
  export type SystemHealthUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemHealth
     */
    select?: SystemHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemHealth
     */
    omit?: SystemHealthOmit<ExtArgs> | null
    /**
     * The data needed to update a SystemHealth.
     */
    data: XOR<SystemHealthUpdateInput, SystemHealthUncheckedUpdateInput>
    /**
     * Choose, which SystemHealth to update.
     */
    where: SystemHealthWhereUniqueInput
  }

  /**
   * SystemHealth updateMany
   */
  export type SystemHealthUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemHealths.
     */
    data: XOR<SystemHealthUpdateManyMutationInput, SystemHealthUncheckedUpdateManyInput>
    /**
     * Filter which SystemHealths to update
     */
    where?: SystemHealthWhereInput
    /**
     * Limit how many SystemHealths to update.
     */
    limit?: number
  }

  /**
   * SystemHealth updateManyAndReturn
   */
  export type SystemHealthUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemHealth
     */
    select?: SystemHealthSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemHealth
     */
    omit?: SystemHealthOmit<ExtArgs> | null
    /**
     * The data used to update SystemHealths.
     */
    data: XOR<SystemHealthUpdateManyMutationInput, SystemHealthUncheckedUpdateManyInput>
    /**
     * Filter which SystemHealths to update
     */
    where?: SystemHealthWhereInput
    /**
     * Limit how many SystemHealths to update.
     */
    limit?: number
  }

  /**
   * SystemHealth upsert
   */
  export type SystemHealthUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemHealth
     */
    select?: SystemHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemHealth
     */
    omit?: SystemHealthOmit<ExtArgs> | null
    /**
     * The filter to search for the SystemHealth to update in case it exists.
     */
    where: SystemHealthWhereUniqueInput
    /**
     * In case the SystemHealth found by the `where` argument doesn't exist, create a new SystemHealth with this data.
     */
    create: XOR<SystemHealthCreateInput, SystemHealthUncheckedCreateInput>
    /**
     * In case the SystemHealth was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemHealthUpdateInput, SystemHealthUncheckedUpdateInput>
  }

  /**
   * SystemHealth delete
   */
  export type SystemHealthDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemHealth
     */
    select?: SystemHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemHealth
     */
    omit?: SystemHealthOmit<ExtArgs> | null
    /**
     * Filter which SystemHealth to delete.
     */
    where: SystemHealthWhereUniqueInput
  }

  /**
   * SystemHealth deleteMany
   */
  export type SystemHealthDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemHealths to delete
     */
    where?: SystemHealthWhereInput
    /**
     * Limit how many SystemHealths to delete.
     */
    limit?: number
  }

  /**
   * SystemHealth without action
   */
  export type SystemHealthDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemHealth
     */
    select?: SystemHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemHealth
     */
    omit?: SystemHealthOmit<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    title: string | null
    message: string | null
    priority: string | null
    channel: string | null
    read: boolean | null
    readAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    title: string | null
    message: string | null
    priority: string | null
    channel: string | null
    read: boolean | null
    readAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    title: number
    message: number
    priority: number
    channel: number
    read: number
    readAt: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    priority?: true
    channel?: true
    read?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    priority?: true
    channel?: true
    read?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    priority?: true
    channel?: true
    read?: true
    readAt?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string | null
    type: string
    title: string
    message: string
    priority: string
    channel: string
    read: boolean
    readAt: Date | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    priority?: boolean
    channel?: boolean
    read?: boolean
    readAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    priority?: boolean
    channel?: boolean
    read?: boolean
    readAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    priority?: boolean
    channel?: boolean
    read?: boolean
    readAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    priority?: boolean
    channel?: boolean
    read?: boolean
    readAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "title" | "message" | "priority" | "channel" | "read" | "readAt" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["notification"]>

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      type: string
      title: string
      message: string
      priority: string
      channel: string
      read: boolean
      readAt: Date | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly priority: FieldRef<"Notification", 'String'>
    readonly channel: FieldRef<"Notification", 'String'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly readAt: FieldRef<"Notification", 'DateTime'>
    readonly metadata: FieldRef<"Notification", 'Json'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
  }


  /**
   * Model AnalyticsEvent
   */

  export type AggregateAnalyticsEvent = {
    _count: AnalyticsEventCountAggregateOutputType | null
    _min: AnalyticsEventMinAggregateOutputType | null
    _max: AnalyticsEventMaxAggregateOutputType | null
  }

  export type AnalyticsEventMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    userId: string | null
    eventName: string | null
    eventCategory: string | null
    timestamp: Date | null
    createdAt: Date | null
  }

  export type AnalyticsEventMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    userId: string | null
    eventName: string | null
    eventCategory: string | null
    timestamp: Date | null
    createdAt: Date | null
  }

  export type AnalyticsEventCountAggregateOutputType = {
    id: number
    sessionId: number
    userId: number
    eventName: number
    eventCategory: number
    eventData: number
    dataPoints: number
    context: number
    timestamp: number
    createdAt: number
    _all: number
  }


  export type AnalyticsEventMinAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    eventName?: true
    eventCategory?: true
    timestamp?: true
    createdAt?: true
  }

  export type AnalyticsEventMaxAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    eventName?: true
    eventCategory?: true
    timestamp?: true
    createdAt?: true
  }

  export type AnalyticsEventCountAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    eventName?: true
    eventCategory?: true
    eventData?: true
    dataPoints?: true
    context?: true
    timestamp?: true
    createdAt?: true
    _all?: true
  }

  export type AnalyticsEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsEvent to aggregate.
     */
    where?: AnalyticsEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsEvents to fetch.
     */
    orderBy?: AnalyticsEventOrderByWithRelationInput | AnalyticsEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnalyticsEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnalyticsEvents
    **/
    _count?: true | AnalyticsEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalyticsEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalyticsEventMaxAggregateInputType
  }

  export type GetAnalyticsEventAggregateType<T extends AnalyticsEventAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalyticsEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalyticsEvent[P]>
      : GetScalarType<T[P], AggregateAnalyticsEvent[P]>
  }




  export type AnalyticsEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticsEventWhereInput
    orderBy?: AnalyticsEventOrderByWithAggregationInput | AnalyticsEventOrderByWithAggregationInput[]
    by: AnalyticsEventScalarFieldEnum[] | AnalyticsEventScalarFieldEnum
    having?: AnalyticsEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalyticsEventCountAggregateInputType | true
    _min?: AnalyticsEventMinAggregateInputType
    _max?: AnalyticsEventMaxAggregateInputType
  }

  export type AnalyticsEventGroupByOutputType = {
    id: string
    sessionId: string
    userId: string | null
    eventName: string
    eventCategory: string
    eventData: JsonValue
    dataPoints: JsonValue
    context: JsonValue
    timestamp: Date
    createdAt: Date
    _count: AnalyticsEventCountAggregateOutputType | null
    _min: AnalyticsEventMinAggregateOutputType | null
    _max: AnalyticsEventMaxAggregateOutputType | null
  }

  type GetAnalyticsEventGroupByPayload<T extends AnalyticsEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnalyticsEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalyticsEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalyticsEventGroupByOutputType[P]>
            : GetScalarType<T[P], AnalyticsEventGroupByOutputType[P]>
        }
      >
    >


  export type AnalyticsEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    eventName?: boolean
    eventCategory?: boolean
    eventData?: boolean
    dataPoints?: boolean
    context?: boolean
    timestamp?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["analyticsEvent"]>

  export type AnalyticsEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    eventName?: boolean
    eventCategory?: boolean
    eventData?: boolean
    dataPoints?: boolean
    context?: boolean
    timestamp?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["analyticsEvent"]>

  export type AnalyticsEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    eventName?: boolean
    eventCategory?: boolean
    eventData?: boolean
    dataPoints?: boolean
    context?: boolean
    timestamp?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["analyticsEvent"]>

  export type AnalyticsEventSelectScalar = {
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    eventName?: boolean
    eventCategory?: boolean
    eventData?: boolean
    dataPoints?: boolean
    context?: boolean
    timestamp?: boolean
    createdAt?: boolean
  }

  export type AnalyticsEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "userId" | "eventName" | "eventCategory" | "eventData" | "dataPoints" | "context" | "timestamp" | "createdAt", ExtArgs["result"]["analyticsEvent"]>

  export type $AnalyticsEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnalyticsEvent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      userId: string | null
      eventName: string
      eventCategory: string
      eventData: Prisma.JsonValue
      dataPoints: Prisma.JsonValue
      context: Prisma.JsonValue
      timestamp: Date
      createdAt: Date
    }, ExtArgs["result"]["analyticsEvent"]>
    composites: {}
  }

  type AnalyticsEventGetPayload<S extends boolean | null | undefined | AnalyticsEventDefaultArgs> = $Result.GetResult<Prisma.$AnalyticsEventPayload, S>

  type AnalyticsEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnalyticsEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnalyticsEventCountAggregateInputType | true
    }

  export interface AnalyticsEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnalyticsEvent'], meta: { name: 'AnalyticsEvent' } }
    /**
     * Find zero or one AnalyticsEvent that matches the filter.
     * @param {AnalyticsEventFindUniqueArgs} args - Arguments to find a AnalyticsEvent
     * @example
     * // Get one AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnalyticsEventFindUniqueArgs>(args: SelectSubset<T, AnalyticsEventFindUniqueArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AnalyticsEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnalyticsEventFindUniqueOrThrowArgs} args - Arguments to find a AnalyticsEvent
     * @example
     * // Get one AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnalyticsEventFindUniqueOrThrowArgs>(args: SelectSubset<T, AnalyticsEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalyticsEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventFindFirstArgs} args - Arguments to find a AnalyticsEvent
     * @example
     * // Get one AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnalyticsEventFindFirstArgs>(args?: SelectSubset<T, AnalyticsEventFindFirstArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalyticsEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventFindFirstOrThrowArgs} args - Arguments to find a AnalyticsEvent
     * @example
     * // Get one AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnalyticsEventFindFirstOrThrowArgs>(args?: SelectSubset<T, AnalyticsEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AnalyticsEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnalyticsEvents
     * const analyticsEvents = await prisma.analyticsEvent.findMany()
     * 
     * // Get first 10 AnalyticsEvents
     * const analyticsEvents = await prisma.analyticsEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analyticsEventWithIdOnly = await prisma.analyticsEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnalyticsEventFindManyArgs>(args?: SelectSubset<T, AnalyticsEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AnalyticsEvent.
     * @param {AnalyticsEventCreateArgs} args - Arguments to create a AnalyticsEvent.
     * @example
     * // Create one AnalyticsEvent
     * const AnalyticsEvent = await prisma.analyticsEvent.create({
     *   data: {
     *     // ... data to create a AnalyticsEvent
     *   }
     * })
     * 
     */
    create<T extends AnalyticsEventCreateArgs>(args: SelectSubset<T, AnalyticsEventCreateArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AnalyticsEvents.
     * @param {AnalyticsEventCreateManyArgs} args - Arguments to create many AnalyticsEvents.
     * @example
     * // Create many AnalyticsEvents
     * const analyticsEvent = await prisma.analyticsEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnalyticsEventCreateManyArgs>(args?: SelectSubset<T, AnalyticsEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnalyticsEvents and returns the data saved in the database.
     * @param {AnalyticsEventCreateManyAndReturnArgs} args - Arguments to create many AnalyticsEvents.
     * @example
     * // Create many AnalyticsEvents
     * const analyticsEvent = await prisma.analyticsEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnalyticsEvents and only return the `id`
     * const analyticsEventWithIdOnly = await prisma.analyticsEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnalyticsEventCreateManyAndReturnArgs>(args?: SelectSubset<T, AnalyticsEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AnalyticsEvent.
     * @param {AnalyticsEventDeleteArgs} args - Arguments to delete one AnalyticsEvent.
     * @example
     * // Delete one AnalyticsEvent
     * const AnalyticsEvent = await prisma.analyticsEvent.delete({
     *   where: {
     *     // ... filter to delete one AnalyticsEvent
     *   }
     * })
     * 
     */
    delete<T extends AnalyticsEventDeleteArgs>(args: SelectSubset<T, AnalyticsEventDeleteArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AnalyticsEvent.
     * @param {AnalyticsEventUpdateArgs} args - Arguments to update one AnalyticsEvent.
     * @example
     * // Update one AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnalyticsEventUpdateArgs>(args: SelectSubset<T, AnalyticsEventUpdateArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AnalyticsEvents.
     * @param {AnalyticsEventDeleteManyArgs} args - Arguments to filter AnalyticsEvents to delete.
     * @example
     * // Delete a few AnalyticsEvents
     * const { count } = await prisma.analyticsEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnalyticsEventDeleteManyArgs>(args?: SelectSubset<T, AnalyticsEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalyticsEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnalyticsEvents
     * const analyticsEvent = await prisma.analyticsEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnalyticsEventUpdateManyArgs>(args: SelectSubset<T, AnalyticsEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalyticsEvents and returns the data updated in the database.
     * @param {AnalyticsEventUpdateManyAndReturnArgs} args - Arguments to update many AnalyticsEvents.
     * @example
     * // Update many AnalyticsEvents
     * const analyticsEvent = await prisma.analyticsEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AnalyticsEvents and only return the `id`
     * const analyticsEventWithIdOnly = await prisma.analyticsEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnalyticsEventUpdateManyAndReturnArgs>(args: SelectSubset<T, AnalyticsEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AnalyticsEvent.
     * @param {AnalyticsEventUpsertArgs} args - Arguments to update or create a AnalyticsEvent.
     * @example
     * // Update or create a AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.upsert({
     *   create: {
     *     // ... data to create a AnalyticsEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnalyticsEvent we want to update
     *   }
     * })
     */
    upsert<T extends AnalyticsEventUpsertArgs>(args: SelectSubset<T, AnalyticsEventUpsertArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AnalyticsEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventCountArgs} args - Arguments to filter AnalyticsEvents to count.
     * @example
     * // Count the number of AnalyticsEvents
     * const count = await prisma.analyticsEvent.count({
     *   where: {
     *     // ... the filter for the AnalyticsEvents we want to count
     *   }
     * })
    **/
    count<T extends AnalyticsEventCountArgs>(
      args?: Subset<T, AnalyticsEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalyticsEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnalyticsEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalyticsEventAggregateArgs>(args: Subset<T, AnalyticsEventAggregateArgs>): Prisma.PrismaPromise<GetAnalyticsEventAggregateType<T>>

    /**
     * Group by AnalyticsEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnalyticsEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnalyticsEventGroupByArgs['orderBy'] }
        : { orderBy?: AnalyticsEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnalyticsEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalyticsEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnalyticsEvent model
   */
  readonly fields: AnalyticsEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnalyticsEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnalyticsEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnalyticsEvent model
   */
  interface AnalyticsEventFieldRefs {
    readonly id: FieldRef<"AnalyticsEvent", 'String'>
    readonly sessionId: FieldRef<"AnalyticsEvent", 'String'>
    readonly userId: FieldRef<"AnalyticsEvent", 'String'>
    readonly eventName: FieldRef<"AnalyticsEvent", 'String'>
    readonly eventCategory: FieldRef<"AnalyticsEvent", 'String'>
    readonly eventData: FieldRef<"AnalyticsEvent", 'Json'>
    readonly dataPoints: FieldRef<"AnalyticsEvent", 'Json'>
    readonly context: FieldRef<"AnalyticsEvent", 'Json'>
    readonly timestamp: FieldRef<"AnalyticsEvent", 'DateTime'>
    readonly createdAt: FieldRef<"AnalyticsEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AnalyticsEvent findUnique
   */
  export type AnalyticsEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsEvent to fetch.
     */
    where: AnalyticsEventWhereUniqueInput
  }

  /**
   * AnalyticsEvent findUniqueOrThrow
   */
  export type AnalyticsEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsEvent to fetch.
     */
    where: AnalyticsEventWhereUniqueInput
  }

  /**
   * AnalyticsEvent findFirst
   */
  export type AnalyticsEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsEvent to fetch.
     */
    where?: AnalyticsEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsEvents to fetch.
     */
    orderBy?: AnalyticsEventOrderByWithRelationInput | AnalyticsEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsEvents.
     */
    cursor?: AnalyticsEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsEvents.
     */
    distinct?: AnalyticsEventScalarFieldEnum | AnalyticsEventScalarFieldEnum[]
  }

  /**
   * AnalyticsEvent findFirstOrThrow
   */
  export type AnalyticsEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsEvent to fetch.
     */
    where?: AnalyticsEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsEvents to fetch.
     */
    orderBy?: AnalyticsEventOrderByWithRelationInput | AnalyticsEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsEvents.
     */
    cursor?: AnalyticsEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsEvents.
     */
    distinct?: AnalyticsEventScalarFieldEnum | AnalyticsEventScalarFieldEnum[]
  }

  /**
   * AnalyticsEvent findMany
   */
  export type AnalyticsEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsEvents to fetch.
     */
    where?: AnalyticsEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsEvents to fetch.
     */
    orderBy?: AnalyticsEventOrderByWithRelationInput | AnalyticsEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnalyticsEvents.
     */
    cursor?: AnalyticsEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsEvents.
     */
    skip?: number
    distinct?: AnalyticsEventScalarFieldEnum | AnalyticsEventScalarFieldEnum[]
  }

  /**
   * AnalyticsEvent create
   */
  export type AnalyticsEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * The data needed to create a AnalyticsEvent.
     */
    data: XOR<AnalyticsEventCreateInput, AnalyticsEventUncheckedCreateInput>
  }

  /**
   * AnalyticsEvent createMany
   */
  export type AnalyticsEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnalyticsEvents.
     */
    data: AnalyticsEventCreateManyInput | AnalyticsEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnalyticsEvent createManyAndReturn
   */
  export type AnalyticsEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * The data used to create many AnalyticsEvents.
     */
    data: AnalyticsEventCreateManyInput | AnalyticsEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnalyticsEvent update
   */
  export type AnalyticsEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * The data needed to update a AnalyticsEvent.
     */
    data: XOR<AnalyticsEventUpdateInput, AnalyticsEventUncheckedUpdateInput>
    /**
     * Choose, which AnalyticsEvent to update.
     */
    where: AnalyticsEventWhereUniqueInput
  }

  /**
   * AnalyticsEvent updateMany
   */
  export type AnalyticsEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnalyticsEvents.
     */
    data: XOR<AnalyticsEventUpdateManyMutationInput, AnalyticsEventUncheckedUpdateManyInput>
    /**
     * Filter which AnalyticsEvents to update
     */
    where?: AnalyticsEventWhereInput
    /**
     * Limit how many AnalyticsEvents to update.
     */
    limit?: number
  }

  /**
   * AnalyticsEvent updateManyAndReturn
   */
  export type AnalyticsEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * The data used to update AnalyticsEvents.
     */
    data: XOR<AnalyticsEventUpdateManyMutationInput, AnalyticsEventUncheckedUpdateManyInput>
    /**
     * Filter which AnalyticsEvents to update
     */
    where?: AnalyticsEventWhereInput
    /**
     * Limit how many AnalyticsEvents to update.
     */
    limit?: number
  }

  /**
   * AnalyticsEvent upsert
   */
  export type AnalyticsEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * The filter to search for the AnalyticsEvent to update in case it exists.
     */
    where: AnalyticsEventWhereUniqueInput
    /**
     * In case the AnalyticsEvent found by the `where` argument doesn't exist, create a new AnalyticsEvent with this data.
     */
    create: XOR<AnalyticsEventCreateInput, AnalyticsEventUncheckedCreateInput>
    /**
     * In case the AnalyticsEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnalyticsEventUpdateInput, AnalyticsEventUncheckedUpdateInput>
  }

  /**
   * AnalyticsEvent delete
   */
  export type AnalyticsEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Filter which AnalyticsEvent to delete.
     */
    where: AnalyticsEventWhereUniqueInput
  }

  /**
   * AnalyticsEvent deleteMany
   */
  export type AnalyticsEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsEvents to delete
     */
    where?: AnalyticsEventWhereInput
    /**
     * Limit how many AnalyticsEvents to delete.
     */
    limit?: number
  }

  /**
   * AnalyticsEvent without action
   */
  export type AnalyticsEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
  }


  /**
   * Model AnalyticsSession
   */

  export type AggregateAnalyticsSession = {
    _count: AnalyticsSessionCountAggregateOutputType | null
    _avg: AnalyticsSessionAvgAggregateOutputType | null
    _sum: AnalyticsSessionSumAggregateOutputType | null
    _min: AnalyticsSessionMinAggregateOutputType | null
    _max: AnalyticsSessionMaxAggregateOutputType | null
  }

  export type AnalyticsSessionAvgAggregateOutputType = {
    duration: number | null
    pageViews: number | null
    events: number | null
    engagementScore: number | null
    conversionValue: number | null
  }

  export type AnalyticsSessionSumAggregateOutputType = {
    duration: number | null
    pageViews: number | null
    events: number | null
    engagementScore: number | null
    conversionValue: number | null
  }

  export type AnalyticsSessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    visitorId: string | null
    startTime: Date | null
    endTime: Date | null
    duration: number | null
    pageViews: number | null
    events: number | null
    bounced: boolean | null
    source: string | null
    medium: string | null
    campaign: string | null
    content: string | null
    term: string | null
    deviceType: string | null
    deviceBrand: string | null
    browser: string | null
    os: string | null
    screenResolution: string | null
    country: string | null
    region: string | null
    city: string | null
    engagementScore: number | null
    conversionValue: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnalyticsSessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    visitorId: string | null
    startTime: Date | null
    endTime: Date | null
    duration: number | null
    pageViews: number | null
    events: number | null
    bounced: boolean | null
    source: string | null
    medium: string | null
    campaign: string | null
    content: string | null
    term: string | null
    deviceType: string | null
    deviceBrand: string | null
    browser: string | null
    os: string | null
    screenResolution: string | null
    country: string | null
    region: string | null
    city: string | null
    engagementScore: number | null
    conversionValue: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnalyticsSessionCountAggregateOutputType = {
    id: number
    userId: number
    visitorId: number
    startTime: number
    endTime: number
    duration: number
    pageViews: number
    events: number
    bounced: number
    source: number
    medium: number
    campaign: number
    content: number
    term: number
    deviceType: number
    deviceBrand: number
    browser: number
    os: number
    screenResolution: number
    country: number
    region: number
    city: number
    engagementScore: number
    conversionValue: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AnalyticsSessionAvgAggregateInputType = {
    duration?: true
    pageViews?: true
    events?: true
    engagementScore?: true
    conversionValue?: true
  }

  export type AnalyticsSessionSumAggregateInputType = {
    duration?: true
    pageViews?: true
    events?: true
    engagementScore?: true
    conversionValue?: true
  }

  export type AnalyticsSessionMinAggregateInputType = {
    id?: true
    userId?: true
    visitorId?: true
    startTime?: true
    endTime?: true
    duration?: true
    pageViews?: true
    events?: true
    bounced?: true
    source?: true
    medium?: true
    campaign?: true
    content?: true
    term?: true
    deviceType?: true
    deviceBrand?: true
    browser?: true
    os?: true
    screenResolution?: true
    country?: true
    region?: true
    city?: true
    engagementScore?: true
    conversionValue?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnalyticsSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    visitorId?: true
    startTime?: true
    endTime?: true
    duration?: true
    pageViews?: true
    events?: true
    bounced?: true
    source?: true
    medium?: true
    campaign?: true
    content?: true
    term?: true
    deviceType?: true
    deviceBrand?: true
    browser?: true
    os?: true
    screenResolution?: true
    country?: true
    region?: true
    city?: true
    engagementScore?: true
    conversionValue?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnalyticsSessionCountAggregateInputType = {
    id?: true
    userId?: true
    visitorId?: true
    startTime?: true
    endTime?: true
    duration?: true
    pageViews?: true
    events?: true
    bounced?: true
    source?: true
    medium?: true
    campaign?: true
    content?: true
    term?: true
    deviceType?: true
    deviceBrand?: true
    browser?: true
    os?: true
    screenResolution?: true
    country?: true
    region?: true
    city?: true
    engagementScore?: true
    conversionValue?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AnalyticsSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsSession to aggregate.
     */
    where?: AnalyticsSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsSessions to fetch.
     */
    orderBy?: AnalyticsSessionOrderByWithRelationInput | AnalyticsSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnalyticsSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnalyticsSessions
    **/
    _count?: true | AnalyticsSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnalyticsSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnalyticsSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalyticsSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalyticsSessionMaxAggregateInputType
  }

  export type GetAnalyticsSessionAggregateType<T extends AnalyticsSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalyticsSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalyticsSession[P]>
      : GetScalarType<T[P], AggregateAnalyticsSession[P]>
  }




  export type AnalyticsSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticsSessionWhereInput
    orderBy?: AnalyticsSessionOrderByWithAggregationInput | AnalyticsSessionOrderByWithAggregationInput[]
    by: AnalyticsSessionScalarFieldEnum[] | AnalyticsSessionScalarFieldEnum
    having?: AnalyticsSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalyticsSessionCountAggregateInputType | true
    _avg?: AnalyticsSessionAvgAggregateInputType
    _sum?: AnalyticsSessionSumAggregateInputType
    _min?: AnalyticsSessionMinAggregateInputType
    _max?: AnalyticsSessionMaxAggregateInputType
  }

  export type AnalyticsSessionGroupByOutputType = {
    id: string
    userId: string | null
    visitorId: string | null
    startTime: Date
    endTime: Date | null
    duration: number | null
    pageViews: number
    events: number
    bounced: boolean
    source: string | null
    medium: string | null
    campaign: string | null
    content: string | null
    term: string | null
    deviceType: string | null
    deviceBrand: string | null
    browser: string | null
    os: string | null
    screenResolution: string | null
    country: string | null
    region: string | null
    city: string | null
    engagementScore: number | null
    conversionValue: number | null
    createdAt: Date
    updatedAt: Date
    _count: AnalyticsSessionCountAggregateOutputType | null
    _avg: AnalyticsSessionAvgAggregateOutputType | null
    _sum: AnalyticsSessionSumAggregateOutputType | null
    _min: AnalyticsSessionMinAggregateOutputType | null
    _max: AnalyticsSessionMaxAggregateOutputType | null
  }

  type GetAnalyticsSessionGroupByPayload<T extends AnalyticsSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnalyticsSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalyticsSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalyticsSessionGroupByOutputType[P]>
            : GetScalarType<T[P], AnalyticsSessionGroupByOutputType[P]>
        }
      >
    >


  export type AnalyticsSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    visitorId?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    pageViews?: boolean
    events?: boolean
    bounced?: boolean
    source?: boolean
    medium?: boolean
    campaign?: boolean
    content?: boolean
    term?: boolean
    deviceType?: boolean
    deviceBrand?: boolean
    browser?: boolean
    os?: boolean
    screenResolution?: boolean
    country?: boolean
    region?: boolean
    city?: boolean
    engagementScore?: boolean
    conversionValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["analyticsSession"]>

  export type AnalyticsSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    visitorId?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    pageViews?: boolean
    events?: boolean
    bounced?: boolean
    source?: boolean
    medium?: boolean
    campaign?: boolean
    content?: boolean
    term?: boolean
    deviceType?: boolean
    deviceBrand?: boolean
    browser?: boolean
    os?: boolean
    screenResolution?: boolean
    country?: boolean
    region?: boolean
    city?: boolean
    engagementScore?: boolean
    conversionValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["analyticsSession"]>

  export type AnalyticsSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    visitorId?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    pageViews?: boolean
    events?: boolean
    bounced?: boolean
    source?: boolean
    medium?: boolean
    campaign?: boolean
    content?: boolean
    term?: boolean
    deviceType?: boolean
    deviceBrand?: boolean
    browser?: boolean
    os?: boolean
    screenResolution?: boolean
    country?: boolean
    region?: boolean
    city?: boolean
    engagementScore?: boolean
    conversionValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["analyticsSession"]>

  export type AnalyticsSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    visitorId?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    pageViews?: boolean
    events?: boolean
    bounced?: boolean
    source?: boolean
    medium?: boolean
    campaign?: boolean
    content?: boolean
    term?: boolean
    deviceType?: boolean
    deviceBrand?: boolean
    browser?: boolean
    os?: boolean
    screenResolution?: boolean
    country?: boolean
    region?: boolean
    city?: boolean
    engagementScore?: boolean
    conversionValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AnalyticsSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "visitorId" | "startTime" | "endTime" | "duration" | "pageViews" | "events" | "bounced" | "source" | "medium" | "campaign" | "content" | "term" | "deviceType" | "deviceBrand" | "browser" | "os" | "screenResolution" | "country" | "region" | "city" | "engagementScore" | "conversionValue" | "createdAt" | "updatedAt", ExtArgs["result"]["analyticsSession"]>

  export type $AnalyticsSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnalyticsSession"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      visitorId: string | null
      startTime: Date
      endTime: Date | null
      duration: number | null
      pageViews: number
      events: number
      bounced: boolean
      source: string | null
      medium: string | null
      campaign: string | null
      content: string | null
      term: string | null
      deviceType: string | null
      deviceBrand: string | null
      browser: string | null
      os: string | null
      screenResolution: string | null
      country: string | null
      region: string | null
      city: string | null
      engagementScore: number | null
      conversionValue: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["analyticsSession"]>
    composites: {}
  }

  type AnalyticsSessionGetPayload<S extends boolean | null | undefined | AnalyticsSessionDefaultArgs> = $Result.GetResult<Prisma.$AnalyticsSessionPayload, S>

  type AnalyticsSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnalyticsSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnalyticsSessionCountAggregateInputType | true
    }

  export interface AnalyticsSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnalyticsSession'], meta: { name: 'AnalyticsSession' } }
    /**
     * Find zero or one AnalyticsSession that matches the filter.
     * @param {AnalyticsSessionFindUniqueArgs} args - Arguments to find a AnalyticsSession
     * @example
     * // Get one AnalyticsSession
     * const analyticsSession = await prisma.analyticsSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnalyticsSessionFindUniqueArgs>(args: SelectSubset<T, AnalyticsSessionFindUniqueArgs<ExtArgs>>): Prisma__AnalyticsSessionClient<$Result.GetResult<Prisma.$AnalyticsSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AnalyticsSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnalyticsSessionFindUniqueOrThrowArgs} args - Arguments to find a AnalyticsSession
     * @example
     * // Get one AnalyticsSession
     * const analyticsSession = await prisma.analyticsSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnalyticsSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, AnalyticsSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnalyticsSessionClient<$Result.GetResult<Prisma.$AnalyticsSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalyticsSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsSessionFindFirstArgs} args - Arguments to find a AnalyticsSession
     * @example
     * // Get one AnalyticsSession
     * const analyticsSession = await prisma.analyticsSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnalyticsSessionFindFirstArgs>(args?: SelectSubset<T, AnalyticsSessionFindFirstArgs<ExtArgs>>): Prisma__AnalyticsSessionClient<$Result.GetResult<Prisma.$AnalyticsSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalyticsSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsSessionFindFirstOrThrowArgs} args - Arguments to find a AnalyticsSession
     * @example
     * // Get one AnalyticsSession
     * const analyticsSession = await prisma.analyticsSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnalyticsSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, AnalyticsSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnalyticsSessionClient<$Result.GetResult<Prisma.$AnalyticsSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AnalyticsSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnalyticsSessions
     * const analyticsSessions = await prisma.analyticsSession.findMany()
     * 
     * // Get first 10 AnalyticsSessions
     * const analyticsSessions = await prisma.analyticsSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analyticsSessionWithIdOnly = await prisma.analyticsSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnalyticsSessionFindManyArgs>(args?: SelectSubset<T, AnalyticsSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AnalyticsSession.
     * @param {AnalyticsSessionCreateArgs} args - Arguments to create a AnalyticsSession.
     * @example
     * // Create one AnalyticsSession
     * const AnalyticsSession = await prisma.analyticsSession.create({
     *   data: {
     *     // ... data to create a AnalyticsSession
     *   }
     * })
     * 
     */
    create<T extends AnalyticsSessionCreateArgs>(args: SelectSubset<T, AnalyticsSessionCreateArgs<ExtArgs>>): Prisma__AnalyticsSessionClient<$Result.GetResult<Prisma.$AnalyticsSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AnalyticsSessions.
     * @param {AnalyticsSessionCreateManyArgs} args - Arguments to create many AnalyticsSessions.
     * @example
     * // Create many AnalyticsSessions
     * const analyticsSession = await prisma.analyticsSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnalyticsSessionCreateManyArgs>(args?: SelectSubset<T, AnalyticsSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnalyticsSessions and returns the data saved in the database.
     * @param {AnalyticsSessionCreateManyAndReturnArgs} args - Arguments to create many AnalyticsSessions.
     * @example
     * // Create many AnalyticsSessions
     * const analyticsSession = await prisma.analyticsSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnalyticsSessions and only return the `id`
     * const analyticsSessionWithIdOnly = await prisma.analyticsSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnalyticsSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, AnalyticsSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AnalyticsSession.
     * @param {AnalyticsSessionDeleteArgs} args - Arguments to delete one AnalyticsSession.
     * @example
     * // Delete one AnalyticsSession
     * const AnalyticsSession = await prisma.analyticsSession.delete({
     *   where: {
     *     // ... filter to delete one AnalyticsSession
     *   }
     * })
     * 
     */
    delete<T extends AnalyticsSessionDeleteArgs>(args: SelectSubset<T, AnalyticsSessionDeleteArgs<ExtArgs>>): Prisma__AnalyticsSessionClient<$Result.GetResult<Prisma.$AnalyticsSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AnalyticsSession.
     * @param {AnalyticsSessionUpdateArgs} args - Arguments to update one AnalyticsSession.
     * @example
     * // Update one AnalyticsSession
     * const analyticsSession = await prisma.analyticsSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnalyticsSessionUpdateArgs>(args: SelectSubset<T, AnalyticsSessionUpdateArgs<ExtArgs>>): Prisma__AnalyticsSessionClient<$Result.GetResult<Prisma.$AnalyticsSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AnalyticsSessions.
     * @param {AnalyticsSessionDeleteManyArgs} args - Arguments to filter AnalyticsSessions to delete.
     * @example
     * // Delete a few AnalyticsSessions
     * const { count } = await prisma.analyticsSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnalyticsSessionDeleteManyArgs>(args?: SelectSubset<T, AnalyticsSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalyticsSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnalyticsSessions
     * const analyticsSession = await prisma.analyticsSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnalyticsSessionUpdateManyArgs>(args: SelectSubset<T, AnalyticsSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalyticsSessions and returns the data updated in the database.
     * @param {AnalyticsSessionUpdateManyAndReturnArgs} args - Arguments to update many AnalyticsSessions.
     * @example
     * // Update many AnalyticsSessions
     * const analyticsSession = await prisma.analyticsSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AnalyticsSessions and only return the `id`
     * const analyticsSessionWithIdOnly = await prisma.analyticsSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnalyticsSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, AnalyticsSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AnalyticsSession.
     * @param {AnalyticsSessionUpsertArgs} args - Arguments to update or create a AnalyticsSession.
     * @example
     * // Update or create a AnalyticsSession
     * const analyticsSession = await prisma.analyticsSession.upsert({
     *   create: {
     *     // ... data to create a AnalyticsSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnalyticsSession we want to update
     *   }
     * })
     */
    upsert<T extends AnalyticsSessionUpsertArgs>(args: SelectSubset<T, AnalyticsSessionUpsertArgs<ExtArgs>>): Prisma__AnalyticsSessionClient<$Result.GetResult<Prisma.$AnalyticsSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AnalyticsSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsSessionCountArgs} args - Arguments to filter AnalyticsSessions to count.
     * @example
     * // Count the number of AnalyticsSessions
     * const count = await prisma.analyticsSession.count({
     *   where: {
     *     // ... the filter for the AnalyticsSessions we want to count
     *   }
     * })
    **/
    count<T extends AnalyticsSessionCountArgs>(
      args?: Subset<T, AnalyticsSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalyticsSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnalyticsSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalyticsSessionAggregateArgs>(args: Subset<T, AnalyticsSessionAggregateArgs>): Prisma.PrismaPromise<GetAnalyticsSessionAggregateType<T>>

    /**
     * Group by AnalyticsSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnalyticsSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnalyticsSessionGroupByArgs['orderBy'] }
        : { orderBy?: AnalyticsSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnalyticsSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalyticsSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnalyticsSession model
   */
  readonly fields: AnalyticsSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnalyticsSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnalyticsSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnalyticsSession model
   */
  interface AnalyticsSessionFieldRefs {
    readonly id: FieldRef<"AnalyticsSession", 'String'>
    readonly userId: FieldRef<"AnalyticsSession", 'String'>
    readonly visitorId: FieldRef<"AnalyticsSession", 'String'>
    readonly startTime: FieldRef<"AnalyticsSession", 'DateTime'>
    readonly endTime: FieldRef<"AnalyticsSession", 'DateTime'>
    readonly duration: FieldRef<"AnalyticsSession", 'Int'>
    readonly pageViews: FieldRef<"AnalyticsSession", 'Int'>
    readonly events: FieldRef<"AnalyticsSession", 'Int'>
    readonly bounced: FieldRef<"AnalyticsSession", 'Boolean'>
    readonly source: FieldRef<"AnalyticsSession", 'String'>
    readonly medium: FieldRef<"AnalyticsSession", 'String'>
    readonly campaign: FieldRef<"AnalyticsSession", 'String'>
    readonly content: FieldRef<"AnalyticsSession", 'String'>
    readonly term: FieldRef<"AnalyticsSession", 'String'>
    readonly deviceType: FieldRef<"AnalyticsSession", 'String'>
    readonly deviceBrand: FieldRef<"AnalyticsSession", 'String'>
    readonly browser: FieldRef<"AnalyticsSession", 'String'>
    readonly os: FieldRef<"AnalyticsSession", 'String'>
    readonly screenResolution: FieldRef<"AnalyticsSession", 'String'>
    readonly country: FieldRef<"AnalyticsSession", 'String'>
    readonly region: FieldRef<"AnalyticsSession", 'String'>
    readonly city: FieldRef<"AnalyticsSession", 'String'>
    readonly engagementScore: FieldRef<"AnalyticsSession", 'Float'>
    readonly conversionValue: FieldRef<"AnalyticsSession", 'Float'>
    readonly createdAt: FieldRef<"AnalyticsSession", 'DateTime'>
    readonly updatedAt: FieldRef<"AnalyticsSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AnalyticsSession findUnique
   */
  export type AnalyticsSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsSession
     */
    select?: AnalyticsSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsSession
     */
    omit?: AnalyticsSessionOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsSession to fetch.
     */
    where: AnalyticsSessionWhereUniqueInput
  }

  /**
   * AnalyticsSession findUniqueOrThrow
   */
  export type AnalyticsSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsSession
     */
    select?: AnalyticsSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsSession
     */
    omit?: AnalyticsSessionOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsSession to fetch.
     */
    where: AnalyticsSessionWhereUniqueInput
  }

  /**
   * AnalyticsSession findFirst
   */
  export type AnalyticsSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsSession
     */
    select?: AnalyticsSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsSession
     */
    omit?: AnalyticsSessionOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsSession to fetch.
     */
    where?: AnalyticsSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsSessions to fetch.
     */
    orderBy?: AnalyticsSessionOrderByWithRelationInput | AnalyticsSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsSessions.
     */
    cursor?: AnalyticsSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsSessions.
     */
    distinct?: AnalyticsSessionScalarFieldEnum | AnalyticsSessionScalarFieldEnum[]
  }

  /**
   * AnalyticsSession findFirstOrThrow
   */
  export type AnalyticsSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsSession
     */
    select?: AnalyticsSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsSession
     */
    omit?: AnalyticsSessionOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsSession to fetch.
     */
    where?: AnalyticsSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsSessions to fetch.
     */
    orderBy?: AnalyticsSessionOrderByWithRelationInput | AnalyticsSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsSessions.
     */
    cursor?: AnalyticsSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsSessions.
     */
    distinct?: AnalyticsSessionScalarFieldEnum | AnalyticsSessionScalarFieldEnum[]
  }

  /**
   * AnalyticsSession findMany
   */
  export type AnalyticsSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsSession
     */
    select?: AnalyticsSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsSession
     */
    omit?: AnalyticsSessionOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsSessions to fetch.
     */
    where?: AnalyticsSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsSessions to fetch.
     */
    orderBy?: AnalyticsSessionOrderByWithRelationInput | AnalyticsSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnalyticsSessions.
     */
    cursor?: AnalyticsSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsSessions.
     */
    skip?: number
    distinct?: AnalyticsSessionScalarFieldEnum | AnalyticsSessionScalarFieldEnum[]
  }

  /**
   * AnalyticsSession create
   */
  export type AnalyticsSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsSession
     */
    select?: AnalyticsSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsSession
     */
    omit?: AnalyticsSessionOmit<ExtArgs> | null
    /**
     * The data needed to create a AnalyticsSession.
     */
    data: XOR<AnalyticsSessionCreateInput, AnalyticsSessionUncheckedCreateInput>
  }

  /**
   * AnalyticsSession createMany
   */
  export type AnalyticsSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnalyticsSessions.
     */
    data: AnalyticsSessionCreateManyInput | AnalyticsSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnalyticsSession createManyAndReturn
   */
  export type AnalyticsSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsSession
     */
    select?: AnalyticsSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsSession
     */
    omit?: AnalyticsSessionOmit<ExtArgs> | null
    /**
     * The data used to create many AnalyticsSessions.
     */
    data: AnalyticsSessionCreateManyInput | AnalyticsSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnalyticsSession update
   */
  export type AnalyticsSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsSession
     */
    select?: AnalyticsSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsSession
     */
    omit?: AnalyticsSessionOmit<ExtArgs> | null
    /**
     * The data needed to update a AnalyticsSession.
     */
    data: XOR<AnalyticsSessionUpdateInput, AnalyticsSessionUncheckedUpdateInput>
    /**
     * Choose, which AnalyticsSession to update.
     */
    where: AnalyticsSessionWhereUniqueInput
  }

  /**
   * AnalyticsSession updateMany
   */
  export type AnalyticsSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnalyticsSessions.
     */
    data: XOR<AnalyticsSessionUpdateManyMutationInput, AnalyticsSessionUncheckedUpdateManyInput>
    /**
     * Filter which AnalyticsSessions to update
     */
    where?: AnalyticsSessionWhereInput
    /**
     * Limit how many AnalyticsSessions to update.
     */
    limit?: number
  }

  /**
   * AnalyticsSession updateManyAndReturn
   */
  export type AnalyticsSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsSession
     */
    select?: AnalyticsSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsSession
     */
    omit?: AnalyticsSessionOmit<ExtArgs> | null
    /**
     * The data used to update AnalyticsSessions.
     */
    data: XOR<AnalyticsSessionUpdateManyMutationInput, AnalyticsSessionUncheckedUpdateManyInput>
    /**
     * Filter which AnalyticsSessions to update
     */
    where?: AnalyticsSessionWhereInput
    /**
     * Limit how many AnalyticsSessions to update.
     */
    limit?: number
  }

  /**
   * AnalyticsSession upsert
   */
  export type AnalyticsSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsSession
     */
    select?: AnalyticsSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsSession
     */
    omit?: AnalyticsSessionOmit<ExtArgs> | null
    /**
     * The filter to search for the AnalyticsSession to update in case it exists.
     */
    where: AnalyticsSessionWhereUniqueInput
    /**
     * In case the AnalyticsSession found by the `where` argument doesn't exist, create a new AnalyticsSession with this data.
     */
    create: XOR<AnalyticsSessionCreateInput, AnalyticsSessionUncheckedCreateInput>
    /**
     * In case the AnalyticsSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnalyticsSessionUpdateInput, AnalyticsSessionUncheckedUpdateInput>
  }

  /**
   * AnalyticsSession delete
   */
  export type AnalyticsSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsSession
     */
    select?: AnalyticsSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsSession
     */
    omit?: AnalyticsSessionOmit<ExtArgs> | null
    /**
     * Filter which AnalyticsSession to delete.
     */
    where: AnalyticsSessionWhereUniqueInput
  }

  /**
   * AnalyticsSession deleteMany
   */
  export type AnalyticsSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsSessions to delete
     */
    where?: AnalyticsSessionWhereInput
    /**
     * Limit how many AnalyticsSessions to delete.
     */
    limit?: number
  }

  /**
   * AnalyticsSession without action
   */
  export type AnalyticsSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsSession
     */
    select?: AnalyticsSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsSession
     */
    omit?: AnalyticsSessionOmit<ExtArgs> | null
  }


  /**
   * Model AnalyticsMetric
   */

  export type AggregateAnalyticsMetric = {
    _count: AnalyticsMetricCountAggregateOutputType | null
    _min: AnalyticsMetricMinAggregateOutputType | null
    _max: AnalyticsMetricMaxAggregateOutputType | null
  }

  export type AnalyticsMetricMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    category: string | null
    lastCalculated: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnalyticsMetricMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    category: string | null
    lastCalculated: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnalyticsMetricCountAggregateOutputType = {
    id: number
    name: number
    type: number
    category: number
    calculation: number
    dailyValues: number
    weeklyValues: number
    monthlyValues: number
    lastCalculated: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AnalyticsMetricMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    category?: true
    lastCalculated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnalyticsMetricMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    category?: true
    lastCalculated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnalyticsMetricCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    category?: true
    calculation?: true
    dailyValues?: true
    weeklyValues?: true
    monthlyValues?: true
    lastCalculated?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AnalyticsMetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsMetric to aggregate.
     */
    where?: AnalyticsMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsMetrics to fetch.
     */
    orderBy?: AnalyticsMetricOrderByWithRelationInput | AnalyticsMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnalyticsMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnalyticsMetrics
    **/
    _count?: true | AnalyticsMetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalyticsMetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalyticsMetricMaxAggregateInputType
  }

  export type GetAnalyticsMetricAggregateType<T extends AnalyticsMetricAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalyticsMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalyticsMetric[P]>
      : GetScalarType<T[P], AggregateAnalyticsMetric[P]>
  }




  export type AnalyticsMetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticsMetricWhereInput
    orderBy?: AnalyticsMetricOrderByWithAggregationInput | AnalyticsMetricOrderByWithAggregationInput[]
    by: AnalyticsMetricScalarFieldEnum[] | AnalyticsMetricScalarFieldEnum
    having?: AnalyticsMetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalyticsMetricCountAggregateInputType | true
    _min?: AnalyticsMetricMinAggregateInputType
    _max?: AnalyticsMetricMaxAggregateInputType
  }

  export type AnalyticsMetricGroupByOutputType = {
    id: string
    name: string
    type: string
    category: string
    calculation: JsonValue
    dailyValues: JsonValue | null
    weeklyValues: JsonValue | null
    monthlyValues: JsonValue | null
    lastCalculated: Date | null
    createdAt: Date
    updatedAt: Date
    _count: AnalyticsMetricCountAggregateOutputType | null
    _min: AnalyticsMetricMinAggregateOutputType | null
    _max: AnalyticsMetricMaxAggregateOutputType | null
  }

  type GetAnalyticsMetricGroupByPayload<T extends AnalyticsMetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnalyticsMetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalyticsMetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalyticsMetricGroupByOutputType[P]>
            : GetScalarType<T[P], AnalyticsMetricGroupByOutputType[P]>
        }
      >
    >


  export type AnalyticsMetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    category?: boolean
    calculation?: boolean
    dailyValues?: boolean
    weeklyValues?: boolean
    monthlyValues?: boolean
    lastCalculated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["analyticsMetric"]>

  export type AnalyticsMetricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    category?: boolean
    calculation?: boolean
    dailyValues?: boolean
    weeklyValues?: boolean
    monthlyValues?: boolean
    lastCalculated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["analyticsMetric"]>

  export type AnalyticsMetricSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    category?: boolean
    calculation?: boolean
    dailyValues?: boolean
    weeklyValues?: boolean
    monthlyValues?: boolean
    lastCalculated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["analyticsMetric"]>

  export type AnalyticsMetricSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    category?: boolean
    calculation?: boolean
    dailyValues?: boolean
    weeklyValues?: boolean
    monthlyValues?: boolean
    lastCalculated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AnalyticsMetricOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "category" | "calculation" | "dailyValues" | "weeklyValues" | "monthlyValues" | "lastCalculated" | "createdAt" | "updatedAt", ExtArgs["result"]["analyticsMetric"]>

  export type $AnalyticsMetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnalyticsMetric"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      category: string
      calculation: Prisma.JsonValue
      dailyValues: Prisma.JsonValue | null
      weeklyValues: Prisma.JsonValue | null
      monthlyValues: Prisma.JsonValue | null
      lastCalculated: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["analyticsMetric"]>
    composites: {}
  }

  type AnalyticsMetricGetPayload<S extends boolean | null | undefined | AnalyticsMetricDefaultArgs> = $Result.GetResult<Prisma.$AnalyticsMetricPayload, S>

  type AnalyticsMetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnalyticsMetricFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnalyticsMetricCountAggregateInputType | true
    }

  export interface AnalyticsMetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnalyticsMetric'], meta: { name: 'AnalyticsMetric' } }
    /**
     * Find zero or one AnalyticsMetric that matches the filter.
     * @param {AnalyticsMetricFindUniqueArgs} args - Arguments to find a AnalyticsMetric
     * @example
     * // Get one AnalyticsMetric
     * const analyticsMetric = await prisma.analyticsMetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnalyticsMetricFindUniqueArgs>(args: SelectSubset<T, AnalyticsMetricFindUniqueArgs<ExtArgs>>): Prisma__AnalyticsMetricClient<$Result.GetResult<Prisma.$AnalyticsMetricPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AnalyticsMetric that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnalyticsMetricFindUniqueOrThrowArgs} args - Arguments to find a AnalyticsMetric
     * @example
     * // Get one AnalyticsMetric
     * const analyticsMetric = await prisma.analyticsMetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnalyticsMetricFindUniqueOrThrowArgs>(args: SelectSubset<T, AnalyticsMetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnalyticsMetricClient<$Result.GetResult<Prisma.$AnalyticsMetricPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalyticsMetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsMetricFindFirstArgs} args - Arguments to find a AnalyticsMetric
     * @example
     * // Get one AnalyticsMetric
     * const analyticsMetric = await prisma.analyticsMetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnalyticsMetricFindFirstArgs>(args?: SelectSubset<T, AnalyticsMetricFindFirstArgs<ExtArgs>>): Prisma__AnalyticsMetricClient<$Result.GetResult<Prisma.$AnalyticsMetricPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalyticsMetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsMetricFindFirstOrThrowArgs} args - Arguments to find a AnalyticsMetric
     * @example
     * // Get one AnalyticsMetric
     * const analyticsMetric = await prisma.analyticsMetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnalyticsMetricFindFirstOrThrowArgs>(args?: SelectSubset<T, AnalyticsMetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnalyticsMetricClient<$Result.GetResult<Prisma.$AnalyticsMetricPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AnalyticsMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsMetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnalyticsMetrics
     * const analyticsMetrics = await prisma.analyticsMetric.findMany()
     * 
     * // Get first 10 AnalyticsMetrics
     * const analyticsMetrics = await prisma.analyticsMetric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analyticsMetricWithIdOnly = await prisma.analyticsMetric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnalyticsMetricFindManyArgs>(args?: SelectSubset<T, AnalyticsMetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsMetricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AnalyticsMetric.
     * @param {AnalyticsMetricCreateArgs} args - Arguments to create a AnalyticsMetric.
     * @example
     * // Create one AnalyticsMetric
     * const AnalyticsMetric = await prisma.analyticsMetric.create({
     *   data: {
     *     // ... data to create a AnalyticsMetric
     *   }
     * })
     * 
     */
    create<T extends AnalyticsMetricCreateArgs>(args: SelectSubset<T, AnalyticsMetricCreateArgs<ExtArgs>>): Prisma__AnalyticsMetricClient<$Result.GetResult<Prisma.$AnalyticsMetricPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AnalyticsMetrics.
     * @param {AnalyticsMetricCreateManyArgs} args - Arguments to create many AnalyticsMetrics.
     * @example
     * // Create many AnalyticsMetrics
     * const analyticsMetric = await prisma.analyticsMetric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnalyticsMetricCreateManyArgs>(args?: SelectSubset<T, AnalyticsMetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnalyticsMetrics and returns the data saved in the database.
     * @param {AnalyticsMetricCreateManyAndReturnArgs} args - Arguments to create many AnalyticsMetrics.
     * @example
     * // Create many AnalyticsMetrics
     * const analyticsMetric = await prisma.analyticsMetric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnalyticsMetrics and only return the `id`
     * const analyticsMetricWithIdOnly = await prisma.analyticsMetric.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnalyticsMetricCreateManyAndReturnArgs>(args?: SelectSubset<T, AnalyticsMetricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsMetricPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AnalyticsMetric.
     * @param {AnalyticsMetricDeleteArgs} args - Arguments to delete one AnalyticsMetric.
     * @example
     * // Delete one AnalyticsMetric
     * const AnalyticsMetric = await prisma.analyticsMetric.delete({
     *   where: {
     *     // ... filter to delete one AnalyticsMetric
     *   }
     * })
     * 
     */
    delete<T extends AnalyticsMetricDeleteArgs>(args: SelectSubset<T, AnalyticsMetricDeleteArgs<ExtArgs>>): Prisma__AnalyticsMetricClient<$Result.GetResult<Prisma.$AnalyticsMetricPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AnalyticsMetric.
     * @param {AnalyticsMetricUpdateArgs} args - Arguments to update one AnalyticsMetric.
     * @example
     * // Update one AnalyticsMetric
     * const analyticsMetric = await prisma.analyticsMetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnalyticsMetricUpdateArgs>(args: SelectSubset<T, AnalyticsMetricUpdateArgs<ExtArgs>>): Prisma__AnalyticsMetricClient<$Result.GetResult<Prisma.$AnalyticsMetricPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AnalyticsMetrics.
     * @param {AnalyticsMetricDeleteManyArgs} args - Arguments to filter AnalyticsMetrics to delete.
     * @example
     * // Delete a few AnalyticsMetrics
     * const { count } = await prisma.analyticsMetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnalyticsMetricDeleteManyArgs>(args?: SelectSubset<T, AnalyticsMetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalyticsMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsMetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnalyticsMetrics
     * const analyticsMetric = await prisma.analyticsMetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnalyticsMetricUpdateManyArgs>(args: SelectSubset<T, AnalyticsMetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalyticsMetrics and returns the data updated in the database.
     * @param {AnalyticsMetricUpdateManyAndReturnArgs} args - Arguments to update many AnalyticsMetrics.
     * @example
     * // Update many AnalyticsMetrics
     * const analyticsMetric = await prisma.analyticsMetric.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AnalyticsMetrics and only return the `id`
     * const analyticsMetricWithIdOnly = await prisma.analyticsMetric.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnalyticsMetricUpdateManyAndReturnArgs>(args: SelectSubset<T, AnalyticsMetricUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsMetricPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AnalyticsMetric.
     * @param {AnalyticsMetricUpsertArgs} args - Arguments to update or create a AnalyticsMetric.
     * @example
     * // Update or create a AnalyticsMetric
     * const analyticsMetric = await prisma.analyticsMetric.upsert({
     *   create: {
     *     // ... data to create a AnalyticsMetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnalyticsMetric we want to update
     *   }
     * })
     */
    upsert<T extends AnalyticsMetricUpsertArgs>(args: SelectSubset<T, AnalyticsMetricUpsertArgs<ExtArgs>>): Prisma__AnalyticsMetricClient<$Result.GetResult<Prisma.$AnalyticsMetricPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AnalyticsMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsMetricCountArgs} args - Arguments to filter AnalyticsMetrics to count.
     * @example
     * // Count the number of AnalyticsMetrics
     * const count = await prisma.analyticsMetric.count({
     *   where: {
     *     // ... the filter for the AnalyticsMetrics we want to count
     *   }
     * })
    **/
    count<T extends AnalyticsMetricCountArgs>(
      args?: Subset<T, AnalyticsMetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalyticsMetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnalyticsMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsMetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalyticsMetricAggregateArgs>(args: Subset<T, AnalyticsMetricAggregateArgs>): Prisma.PrismaPromise<GetAnalyticsMetricAggregateType<T>>

    /**
     * Group by AnalyticsMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsMetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnalyticsMetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnalyticsMetricGroupByArgs['orderBy'] }
        : { orderBy?: AnalyticsMetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnalyticsMetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalyticsMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnalyticsMetric model
   */
  readonly fields: AnalyticsMetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnalyticsMetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnalyticsMetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnalyticsMetric model
   */
  interface AnalyticsMetricFieldRefs {
    readonly id: FieldRef<"AnalyticsMetric", 'String'>
    readonly name: FieldRef<"AnalyticsMetric", 'String'>
    readonly type: FieldRef<"AnalyticsMetric", 'String'>
    readonly category: FieldRef<"AnalyticsMetric", 'String'>
    readonly calculation: FieldRef<"AnalyticsMetric", 'Json'>
    readonly dailyValues: FieldRef<"AnalyticsMetric", 'Json'>
    readonly weeklyValues: FieldRef<"AnalyticsMetric", 'Json'>
    readonly monthlyValues: FieldRef<"AnalyticsMetric", 'Json'>
    readonly lastCalculated: FieldRef<"AnalyticsMetric", 'DateTime'>
    readonly createdAt: FieldRef<"AnalyticsMetric", 'DateTime'>
    readonly updatedAt: FieldRef<"AnalyticsMetric", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AnalyticsMetric findUnique
   */
  export type AnalyticsMetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsMetric
     */
    select?: AnalyticsMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsMetric
     */
    omit?: AnalyticsMetricOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsMetric to fetch.
     */
    where: AnalyticsMetricWhereUniqueInput
  }

  /**
   * AnalyticsMetric findUniqueOrThrow
   */
  export type AnalyticsMetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsMetric
     */
    select?: AnalyticsMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsMetric
     */
    omit?: AnalyticsMetricOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsMetric to fetch.
     */
    where: AnalyticsMetricWhereUniqueInput
  }

  /**
   * AnalyticsMetric findFirst
   */
  export type AnalyticsMetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsMetric
     */
    select?: AnalyticsMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsMetric
     */
    omit?: AnalyticsMetricOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsMetric to fetch.
     */
    where?: AnalyticsMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsMetrics to fetch.
     */
    orderBy?: AnalyticsMetricOrderByWithRelationInput | AnalyticsMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsMetrics.
     */
    cursor?: AnalyticsMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsMetrics.
     */
    distinct?: AnalyticsMetricScalarFieldEnum | AnalyticsMetricScalarFieldEnum[]
  }

  /**
   * AnalyticsMetric findFirstOrThrow
   */
  export type AnalyticsMetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsMetric
     */
    select?: AnalyticsMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsMetric
     */
    omit?: AnalyticsMetricOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsMetric to fetch.
     */
    where?: AnalyticsMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsMetrics to fetch.
     */
    orderBy?: AnalyticsMetricOrderByWithRelationInput | AnalyticsMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsMetrics.
     */
    cursor?: AnalyticsMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsMetrics.
     */
    distinct?: AnalyticsMetricScalarFieldEnum | AnalyticsMetricScalarFieldEnum[]
  }

  /**
   * AnalyticsMetric findMany
   */
  export type AnalyticsMetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsMetric
     */
    select?: AnalyticsMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsMetric
     */
    omit?: AnalyticsMetricOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsMetrics to fetch.
     */
    where?: AnalyticsMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsMetrics to fetch.
     */
    orderBy?: AnalyticsMetricOrderByWithRelationInput | AnalyticsMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnalyticsMetrics.
     */
    cursor?: AnalyticsMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsMetrics.
     */
    skip?: number
    distinct?: AnalyticsMetricScalarFieldEnum | AnalyticsMetricScalarFieldEnum[]
  }

  /**
   * AnalyticsMetric create
   */
  export type AnalyticsMetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsMetric
     */
    select?: AnalyticsMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsMetric
     */
    omit?: AnalyticsMetricOmit<ExtArgs> | null
    /**
     * The data needed to create a AnalyticsMetric.
     */
    data: XOR<AnalyticsMetricCreateInput, AnalyticsMetricUncheckedCreateInput>
  }

  /**
   * AnalyticsMetric createMany
   */
  export type AnalyticsMetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnalyticsMetrics.
     */
    data: AnalyticsMetricCreateManyInput | AnalyticsMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnalyticsMetric createManyAndReturn
   */
  export type AnalyticsMetricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsMetric
     */
    select?: AnalyticsMetricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsMetric
     */
    omit?: AnalyticsMetricOmit<ExtArgs> | null
    /**
     * The data used to create many AnalyticsMetrics.
     */
    data: AnalyticsMetricCreateManyInput | AnalyticsMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnalyticsMetric update
   */
  export type AnalyticsMetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsMetric
     */
    select?: AnalyticsMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsMetric
     */
    omit?: AnalyticsMetricOmit<ExtArgs> | null
    /**
     * The data needed to update a AnalyticsMetric.
     */
    data: XOR<AnalyticsMetricUpdateInput, AnalyticsMetricUncheckedUpdateInput>
    /**
     * Choose, which AnalyticsMetric to update.
     */
    where: AnalyticsMetricWhereUniqueInput
  }

  /**
   * AnalyticsMetric updateMany
   */
  export type AnalyticsMetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnalyticsMetrics.
     */
    data: XOR<AnalyticsMetricUpdateManyMutationInput, AnalyticsMetricUncheckedUpdateManyInput>
    /**
     * Filter which AnalyticsMetrics to update
     */
    where?: AnalyticsMetricWhereInput
    /**
     * Limit how many AnalyticsMetrics to update.
     */
    limit?: number
  }

  /**
   * AnalyticsMetric updateManyAndReturn
   */
  export type AnalyticsMetricUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsMetric
     */
    select?: AnalyticsMetricSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsMetric
     */
    omit?: AnalyticsMetricOmit<ExtArgs> | null
    /**
     * The data used to update AnalyticsMetrics.
     */
    data: XOR<AnalyticsMetricUpdateManyMutationInput, AnalyticsMetricUncheckedUpdateManyInput>
    /**
     * Filter which AnalyticsMetrics to update
     */
    where?: AnalyticsMetricWhereInput
    /**
     * Limit how many AnalyticsMetrics to update.
     */
    limit?: number
  }

  /**
   * AnalyticsMetric upsert
   */
  export type AnalyticsMetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsMetric
     */
    select?: AnalyticsMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsMetric
     */
    omit?: AnalyticsMetricOmit<ExtArgs> | null
    /**
     * The filter to search for the AnalyticsMetric to update in case it exists.
     */
    where: AnalyticsMetricWhereUniqueInput
    /**
     * In case the AnalyticsMetric found by the `where` argument doesn't exist, create a new AnalyticsMetric with this data.
     */
    create: XOR<AnalyticsMetricCreateInput, AnalyticsMetricUncheckedCreateInput>
    /**
     * In case the AnalyticsMetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnalyticsMetricUpdateInput, AnalyticsMetricUncheckedUpdateInput>
  }

  /**
   * AnalyticsMetric delete
   */
  export type AnalyticsMetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsMetric
     */
    select?: AnalyticsMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsMetric
     */
    omit?: AnalyticsMetricOmit<ExtArgs> | null
    /**
     * Filter which AnalyticsMetric to delete.
     */
    where: AnalyticsMetricWhereUniqueInput
  }

  /**
   * AnalyticsMetric deleteMany
   */
  export type AnalyticsMetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsMetrics to delete
     */
    where?: AnalyticsMetricWhereInput
    /**
     * Limit how many AnalyticsMetrics to delete.
     */
    limit?: number
  }

  /**
   * AnalyticsMetric without action
   */
  export type AnalyticsMetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsMetric
     */
    select?: AnalyticsMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsMetric
     */
    omit?: AnalyticsMetricOmit<ExtArgs> | null
  }


  /**
   * Model AnalyticsCohort
   */

  export type AggregateAnalyticsCohort = {
    _count: AnalyticsCohortCountAggregateOutputType | null
    _avg: AnalyticsCohortAvgAggregateOutputType | null
    _sum: AnalyticsCohortSumAggregateOutputType | null
    _min: AnalyticsCohortMinAggregateOutputType | null
    _max: AnalyticsCohortMaxAggregateOutputType | null
  }

  export type AnalyticsCohortAvgAggregateOutputType = {
    userCount: number | null
  }

  export type AnalyticsCohortSumAggregateOutputType = {
    userCount: number | null
  }

  export type AnalyticsCohortMinAggregateOutputType = {
    id: string | null
    name: string | null
    userCount: number | null
    lastUpdated: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnalyticsCohortMaxAggregateOutputType = {
    id: string | null
    name: string | null
    userCount: number | null
    lastUpdated: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnalyticsCohortCountAggregateOutputType = {
    id: number
    name: number
    definition: number
    userCount: number
    retentionData: number
    engagementData: number
    revenueData: number
    lastUpdated: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AnalyticsCohortAvgAggregateInputType = {
    userCount?: true
  }

  export type AnalyticsCohortSumAggregateInputType = {
    userCount?: true
  }

  export type AnalyticsCohortMinAggregateInputType = {
    id?: true
    name?: true
    userCount?: true
    lastUpdated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnalyticsCohortMaxAggregateInputType = {
    id?: true
    name?: true
    userCount?: true
    lastUpdated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnalyticsCohortCountAggregateInputType = {
    id?: true
    name?: true
    definition?: true
    userCount?: true
    retentionData?: true
    engagementData?: true
    revenueData?: true
    lastUpdated?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AnalyticsCohortAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsCohort to aggregate.
     */
    where?: AnalyticsCohortWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsCohorts to fetch.
     */
    orderBy?: AnalyticsCohortOrderByWithRelationInput | AnalyticsCohortOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnalyticsCohortWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsCohorts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsCohorts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnalyticsCohorts
    **/
    _count?: true | AnalyticsCohortCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnalyticsCohortAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnalyticsCohortSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalyticsCohortMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalyticsCohortMaxAggregateInputType
  }

  export type GetAnalyticsCohortAggregateType<T extends AnalyticsCohortAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalyticsCohort]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalyticsCohort[P]>
      : GetScalarType<T[P], AggregateAnalyticsCohort[P]>
  }




  export type AnalyticsCohortGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticsCohortWhereInput
    orderBy?: AnalyticsCohortOrderByWithAggregationInput | AnalyticsCohortOrderByWithAggregationInput[]
    by: AnalyticsCohortScalarFieldEnum[] | AnalyticsCohortScalarFieldEnum
    having?: AnalyticsCohortScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalyticsCohortCountAggregateInputType | true
    _avg?: AnalyticsCohortAvgAggregateInputType
    _sum?: AnalyticsCohortSumAggregateInputType
    _min?: AnalyticsCohortMinAggregateInputType
    _max?: AnalyticsCohortMaxAggregateInputType
  }

  export type AnalyticsCohortGroupByOutputType = {
    id: string
    name: string
    definition: JsonValue
    userCount: number
    retentionData: JsonValue | null
    engagementData: JsonValue | null
    revenueData: JsonValue | null
    lastUpdated: Date | null
    createdAt: Date
    updatedAt: Date
    _count: AnalyticsCohortCountAggregateOutputType | null
    _avg: AnalyticsCohortAvgAggregateOutputType | null
    _sum: AnalyticsCohortSumAggregateOutputType | null
    _min: AnalyticsCohortMinAggregateOutputType | null
    _max: AnalyticsCohortMaxAggregateOutputType | null
  }

  type GetAnalyticsCohortGroupByPayload<T extends AnalyticsCohortGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnalyticsCohortGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalyticsCohortGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalyticsCohortGroupByOutputType[P]>
            : GetScalarType<T[P], AnalyticsCohortGroupByOutputType[P]>
        }
      >
    >


  export type AnalyticsCohortSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    definition?: boolean
    userCount?: boolean
    retentionData?: boolean
    engagementData?: boolean
    revenueData?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["analyticsCohort"]>

  export type AnalyticsCohortSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    definition?: boolean
    userCount?: boolean
    retentionData?: boolean
    engagementData?: boolean
    revenueData?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["analyticsCohort"]>

  export type AnalyticsCohortSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    definition?: boolean
    userCount?: boolean
    retentionData?: boolean
    engagementData?: boolean
    revenueData?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["analyticsCohort"]>

  export type AnalyticsCohortSelectScalar = {
    id?: boolean
    name?: boolean
    definition?: boolean
    userCount?: boolean
    retentionData?: boolean
    engagementData?: boolean
    revenueData?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AnalyticsCohortOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "definition" | "userCount" | "retentionData" | "engagementData" | "revenueData" | "lastUpdated" | "createdAt" | "updatedAt", ExtArgs["result"]["analyticsCohort"]>

  export type $AnalyticsCohortPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnalyticsCohort"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      definition: Prisma.JsonValue
      userCount: number
      retentionData: Prisma.JsonValue | null
      engagementData: Prisma.JsonValue | null
      revenueData: Prisma.JsonValue | null
      lastUpdated: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["analyticsCohort"]>
    composites: {}
  }

  type AnalyticsCohortGetPayload<S extends boolean | null | undefined | AnalyticsCohortDefaultArgs> = $Result.GetResult<Prisma.$AnalyticsCohortPayload, S>

  type AnalyticsCohortCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnalyticsCohortFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnalyticsCohortCountAggregateInputType | true
    }

  export interface AnalyticsCohortDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnalyticsCohort'], meta: { name: 'AnalyticsCohort' } }
    /**
     * Find zero or one AnalyticsCohort that matches the filter.
     * @param {AnalyticsCohortFindUniqueArgs} args - Arguments to find a AnalyticsCohort
     * @example
     * // Get one AnalyticsCohort
     * const analyticsCohort = await prisma.analyticsCohort.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnalyticsCohortFindUniqueArgs>(args: SelectSubset<T, AnalyticsCohortFindUniqueArgs<ExtArgs>>): Prisma__AnalyticsCohortClient<$Result.GetResult<Prisma.$AnalyticsCohortPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AnalyticsCohort that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnalyticsCohortFindUniqueOrThrowArgs} args - Arguments to find a AnalyticsCohort
     * @example
     * // Get one AnalyticsCohort
     * const analyticsCohort = await prisma.analyticsCohort.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnalyticsCohortFindUniqueOrThrowArgs>(args: SelectSubset<T, AnalyticsCohortFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnalyticsCohortClient<$Result.GetResult<Prisma.$AnalyticsCohortPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalyticsCohort that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsCohortFindFirstArgs} args - Arguments to find a AnalyticsCohort
     * @example
     * // Get one AnalyticsCohort
     * const analyticsCohort = await prisma.analyticsCohort.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnalyticsCohortFindFirstArgs>(args?: SelectSubset<T, AnalyticsCohortFindFirstArgs<ExtArgs>>): Prisma__AnalyticsCohortClient<$Result.GetResult<Prisma.$AnalyticsCohortPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalyticsCohort that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsCohortFindFirstOrThrowArgs} args - Arguments to find a AnalyticsCohort
     * @example
     * // Get one AnalyticsCohort
     * const analyticsCohort = await prisma.analyticsCohort.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnalyticsCohortFindFirstOrThrowArgs>(args?: SelectSubset<T, AnalyticsCohortFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnalyticsCohortClient<$Result.GetResult<Prisma.$AnalyticsCohortPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AnalyticsCohorts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsCohortFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnalyticsCohorts
     * const analyticsCohorts = await prisma.analyticsCohort.findMany()
     * 
     * // Get first 10 AnalyticsCohorts
     * const analyticsCohorts = await prisma.analyticsCohort.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analyticsCohortWithIdOnly = await prisma.analyticsCohort.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnalyticsCohortFindManyArgs>(args?: SelectSubset<T, AnalyticsCohortFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsCohortPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AnalyticsCohort.
     * @param {AnalyticsCohortCreateArgs} args - Arguments to create a AnalyticsCohort.
     * @example
     * // Create one AnalyticsCohort
     * const AnalyticsCohort = await prisma.analyticsCohort.create({
     *   data: {
     *     // ... data to create a AnalyticsCohort
     *   }
     * })
     * 
     */
    create<T extends AnalyticsCohortCreateArgs>(args: SelectSubset<T, AnalyticsCohortCreateArgs<ExtArgs>>): Prisma__AnalyticsCohortClient<$Result.GetResult<Prisma.$AnalyticsCohortPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AnalyticsCohorts.
     * @param {AnalyticsCohortCreateManyArgs} args - Arguments to create many AnalyticsCohorts.
     * @example
     * // Create many AnalyticsCohorts
     * const analyticsCohort = await prisma.analyticsCohort.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnalyticsCohortCreateManyArgs>(args?: SelectSubset<T, AnalyticsCohortCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnalyticsCohorts and returns the data saved in the database.
     * @param {AnalyticsCohortCreateManyAndReturnArgs} args - Arguments to create many AnalyticsCohorts.
     * @example
     * // Create many AnalyticsCohorts
     * const analyticsCohort = await prisma.analyticsCohort.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnalyticsCohorts and only return the `id`
     * const analyticsCohortWithIdOnly = await prisma.analyticsCohort.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnalyticsCohortCreateManyAndReturnArgs>(args?: SelectSubset<T, AnalyticsCohortCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsCohortPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AnalyticsCohort.
     * @param {AnalyticsCohortDeleteArgs} args - Arguments to delete one AnalyticsCohort.
     * @example
     * // Delete one AnalyticsCohort
     * const AnalyticsCohort = await prisma.analyticsCohort.delete({
     *   where: {
     *     // ... filter to delete one AnalyticsCohort
     *   }
     * })
     * 
     */
    delete<T extends AnalyticsCohortDeleteArgs>(args: SelectSubset<T, AnalyticsCohortDeleteArgs<ExtArgs>>): Prisma__AnalyticsCohortClient<$Result.GetResult<Prisma.$AnalyticsCohortPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AnalyticsCohort.
     * @param {AnalyticsCohortUpdateArgs} args - Arguments to update one AnalyticsCohort.
     * @example
     * // Update one AnalyticsCohort
     * const analyticsCohort = await prisma.analyticsCohort.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnalyticsCohortUpdateArgs>(args: SelectSubset<T, AnalyticsCohortUpdateArgs<ExtArgs>>): Prisma__AnalyticsCohortClient<$Result.GetResult<Prisma.$AnalyticsCohortPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AnalyticsCohorts.
     * @param {AnalyticsCohortDeleteManyArgs} args - Arguments to filter AnalyticsCohorts to delete.
     * @example
     * // Delete a few AnalyticsCohorts
     * const { count } = await prisma.analyticsCohort.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnalyticsCohortDeleteManyArgs>(args?: SelectSubset<T, AnalyticsCohortDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalyticsCohorts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsCohortUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnalyticsCohorts
     * const analyticsCohort = await prisma.analyticsCohort.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnalyticsCohortUpdateManyArgs>(args: SelectSubset<T, AnalyticsCohortUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalyticsCohorts and returns the data updated in the database.
     * @param {AnalyticsCohortUpdateManyAndReturnArgs} args - Arguments to update many AnalyticsCohorts.
     * @example
     * // Update many AnalyticsCohorts
     * const analyticsCohort = await prisma.analyticsCohort.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AnalyticsCohorts and only return the `id`
     * const analyticsCohortWithIdOnly = await prisma.analyticsCohort.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnalyticsCohortUpdateManyAndReturnArgs>(args: SelectSubset<T, AnalyticsCohortUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsCohortPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AnalyticsCohort.
     * @param {AnalyticsCohortUpsertArgs} args - Arguments to update or create a AnalyticsCohort.
     * @example
     * // Update or create a AnalyticsCohort
     * const analyticsCohort = await prisma.analyticsCohort.upsert({
     *   create: {
     *     // ... data to create a AnalyticsCohort
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnalyticsCohort we want to update
     *   }
     * })
     */
    upsert<T extends AnalyticsCohortUpsertArgs>(args: SelectSubset<T, AnalyticsCohortUpsertArgs<ExtArgs>>): Prisma__AnalyticsCohortClient<$Result.GetResult<Prisma.$AnalyticsCohortPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AnalyticsCohorts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsCohortCountArgs} args - Arguments to filter AnalyticsCohorts to count.
     * @example
     * // Count the number of AnalyticsCohorts
     * const count = await prisma.analyticsCohort.count({
     *   where: {
     *     // ... the filter for the AnalyticsCohorts we want to count
     *   }
     * })
    **/
    count<T extends AnalyticsCohortCountArgs>(
      args?: Subset<T, AnalyticsCohortCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalyticsCohortCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnalyticsCohort.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsCohortAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalyticsCohortAggregateArgs>(args: Subset<T, AnalyticsCohortAggregateArgs>): Prisma.PrismaPromise<GetAnalyticsCohortAggregateType<T>>

    /**
     * Group by AnalyticsCohort.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsCohortGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnalyticsCohortGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnalyticsCohortGroupByArgs['orderBy'] }
        : { orderBy?: AnalyticsCohortGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnalyticsCohortGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalyticsCohortGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnalyticsCohort model
   */
  readonly fields: AnalyticsCohortFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnalyticsCohort.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnalyticsCohortClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnalyticsCohort model
   */
  interface AnalyticsCohortFieldRefs {
    readonly id: FieldRef<"AnalyticsCohort", 'String'>
    readonly name: FieldRef<"AnalyticsCohort", 'String'>
    readonly definition: FieldRef<"AnalyticsCohort", 'Json'>
    readonly userCount: FieldRef<"AnalyticsCohort", 'Int'>
    readonly retentionData: FieldRef<"AnalyticsCohort", 'Json'>
    readonly engagementData: FieldRef<"AnalyticsCohort", 'Json'>
    readonly revenueData: FieldRef<"AnalyticsCohort", 'Json'>
    readonly lastUpdated: FieldRef<"AnalyticsCohort", 'DateTime'>
    readonly createdAt: FieldRef<"AnalyticsCohort", 'DateTime'>
    readonly updatedAt: FieldRef<"AnalyticsCohort", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AnalyticsCohort findUnique
   */
  export type AnalyticsCohortFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsCohort
     */
    select?: AnalyticsCohortSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsCohort
     */
    omit?: AnalyticsCohortOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsCohort to fetch.
     */
    where: AnalyticsCohortWhereUniqueInput
  }

  /**
   * AnalyticsCohort findUniqueOrThrow
   */
  export type AnalyticsCohortFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsCohort
     */
    select?: AnalyticsCohortSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsCohort
     */
    omit?: AnalyticsCohortOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsCohort to fetch.
     */
    where: AnalyticsCohortWhereUniqueInput
  }

  /**
   * AnalyticsCohort findFirst
   */
  export type AnalyticsCohortFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsCohort
     */
    select?: AnalyticsCohortSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsCohort
     */
    omit?: AnalyticsCohortOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsCohort to fetch.
     */
    where?: AnalyticsCohortWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsCohorts to fetch.
     */
    orderBy?: AnalyticsCohortOrderByWithRelationInput | AnalyticsCohortOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsCohorts.
     */
    cursor?: AnalyticsCohortWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsCohorts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsCohorts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsCohorts.
     */
    distinct?: AnalyticsCohortScalarFieldEnum | AnalyticsCohortScalarFieldEnum[]
  }

  /**
   * AnalyticsCohort findFirstOrThrow
   */
  export type AnalyticsCohortFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsCohort
     */
    select?: AnalyticsCohortSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsCohort
     */
    omit?: AnalyticsCohortOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsCohort to fetch.
     */
    where?: AnalyticsCohortWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsCohorts to fetch.
     */
    orderBy?: AnalyticsCohortOrderByWithRelationInput | AnalyticsCohortOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsCohorts.
     */
    cursor?: AnalyticsCohortWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsCohorts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsCohorts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsCohorts.
     */
    distinct?: AnalyticsCohortScalarFieldEnum | AnalyticsCohortScalarFieldEnum[]
  }

  /**
   * AnalyticsCohort findMany
   */
  export type AnalyticsCohortFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsCohort
     */
    select?: AnalyticsCohortSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsCohort
     */
    omit?: AnalyticsCohortOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsCohorts to fetch.
     */
    where?: AnalyticsCohortWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsCohorts to fetch.
     */
    orderBy?: AnalyticsCohortOrderByWithRelationInput | AnalyticsCohortOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnalyticsCohorts.
     */
    cursor?: AnalyticsCohortWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsCohorts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsCohorts.
     */
    skip?: number
    distinct?: AnalyticsCohortScalarFieldEnum | AnalyticsCohortScalarFieldEnum[]
  }

  /**
   * AnalyticsCohort create
   */
  export type AnalyticsCohortCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsCohort
     */
    select?: AnalyticsCohortSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsCohort
     */
    omit?: AnalyticsCohortOmit<ExtArgs> | null
    /**
     * The data needed to create a AnalyticsCohort.
     */
    data: XOR<AnalyticsCohortCreateInput, AnalyticsCohortUncheckedCreateInput>
  }

  /**
   * AnalyticsCohort createMany
   */
  export type AnalyticsCohortCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnalyticsCohorts.
     */
    data: AnalyticsCohortCreateManyInput | AnalyticsCohortCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnalyticsCohort createManyAndReturn
   */
  export type AnalyticsCohortCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsCohort
     */
    select?: AnalyticsCohortSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsCohort
     */
    omit?: AnalyticsCohortOmit<ExtArgs> | null
    /**
     * The data used to create many AnalyticsCohorts.
     */
    data: AnalyticsCohortCreateManyInput | AnalyticsCohortCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnalyticsCohort update
   */
  export type AnalyticsCohortUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsCohort
     */
    select?: AnalyticsCohortSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsCohort
     */
    omit?: AnalyticsCohortOmit<ExtArgs> | null
    /**
     * The data needed to update a AnalyticsCohort.
     */
    data: XOR<AnalyticsCohortUpdateInput, AnalyticsCohortUncheckedUpdateInput>
    /**
     * Choose, which AnalyticsCohort to update.
     */
    where: AnalyticsCohortWhereUniqueInput
  }

  /**
   * AnalyticsCohort updateMany
   */
  export type AnalyticsCohortUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnalyticsCohorts.
     */
    data: XOR<AnalyticsCohortUpdateManyMutationInput, AnalyticsCohortUncheckedUpdateManyInput>
    /**
     * Filter which AnalyticsCohorts to update
     */
    where?: AnalyticsCohortWhereInput
    /**
     * Limit how many AnalyticsCohorts to update.
     */
    limit?: number
  }

  /**
   * AnalyticsCohort updateManyAndReturn
   */
  export type AnalyticsCohortUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsCohort
     */
    select?: AnalyticsCohortSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsCohort
     */
    omit?: AnalyticsCohortOmit<ExtArgs> | null
    /**
     * The data used to update AnalyticsCohorts.
     */
    data: XOR<AnalyticsCohortUpdateManyMutationInput, AnalyticsCohortUncheckedUpdateManyInput>
    /**
     * Filter which AnalyticsCohorts to update
     */
    where?: AnalyticsCohortWhereInput
    /**
     * Limit how many AnalyticsCohorts to update.
     */
    limit?: number
  }

  /**
   * AnalyticsCohort upsert
   */
  export type AnalyticsCohortUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsCohort
     */
    select?: AnalyticsCohortSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsCohort
     */
    omit?: AnalyticsCohortOmit<ExtArgs> | null
    /**
     * The filter to search for the AnalyticsCohort to update in case it exists.
     */
    where: AnalyticsCohortWhereUniqueInput
    /**
     * In case the AnalyticsCohort found by the `where` argument doesn't exist, create a new AnalyticsCohort with this data.
     */
    create: XOR<AnalyticsCohortCreateInput, AnalyticsCohortUncheckedCreateInput>
    /**
     * In case the AnalyticsCohort was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnalyticsCohortUpdateInput, AnalyticsCohortUncheckedUpdateInput>
  }

  /**
   * AnalyticsCohort delete
   */
  export type AnalyticsCohortDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsCohort
     */
    select?: AnalyticsCohortSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsCohort
     */
    omit?: AnalyticsCohortOmit<ExtArgs> | null
    /**
     * Filter which AnalyticsCohort to delete.
     */
    where: AnalyticsCohortWhereUniqueInput
  }

  /**
   * AnalyticsCohort deleteMany
   */
  export type AnalyticsCohortDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsCohorts to delete
     */
    where?: AnalyticsCohortWhereInput
    /**
     * Limit how many AnalyticsCohorts to delete.
     */
    limit?: number
  }

  /**
   * AnalyticsCohort without action
   */
  export type AnalyticsCohortDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsCohort
     */
    select?: AnalyticsCohortSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsCohort
     */
    omit?: AnalyticsCohortOmit<ExtArgs> | null
  }


  /**
   * Model AnalyticsFunnel
   */

  export type AggregateAnalyticsFunnel = {
    _count: AnalyticsFunnelCountAggregateOutputType | null
    _min: AnalyticsFunnelMinAggregateOutputType | null
    _max: AnalyticsFunnelMaxAggregateOutputType | null
  }

  export type AnalyticsFunnelMinAggregateOutputType = {
    id: string | null
    name: string | null
    lastCalculated: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnalyticsFunnelMaxAggregateOutputType = {
    id: string | null
    name: string | null
    lastCalculated: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnalyticsFunnelCountAggregateOutputType = {
    id: number
    name: number
    steps: number
    conversionRates: number
    dropoffRates: number
    avgTimePerStep: number
    lastCalculated: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AnalyticsFunnelMinAggregateInputType = {
    id?: true
    name?: true
    lastCalculated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnalyticsFunnelMaxAggregateInputType = {
    id?: true
    name?: true
    lastCalculated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnalyticsFunnelCountAggregateInputType = {
    id?: true
    name?: true
    steps?: true
    conversionRates?: true
    dropoffRates?: true
    avgTimePerStep?: true
    lastCalculated?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AnalyticsFunnelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsFunnel to aggregate.
     */
    where?: AnalyticsFunnelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsFunnels to fetch.
     */
    orderBy?: AnalyticsFunnelOrderByWithRelationInput | AnalyticsFunnelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnalyticsFunnelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsFunnels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsFunnels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnalyticsFunnels
    **/
    _count?: true | AnalyticsFunnelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalyticsFunnelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalyticsFunnelMaxAggregateInputType
  }

  export type GetAnalyticsFunnelAggregateType<T extends AnalyticsFunnelAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalyticsFunnel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalyticsFunnel[P]>
      : GetScalarType<T[P], AggregateAnalyticsFunnel[P]>
  }




  export type AnalyticsFunnelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticsFunnelWhereInput
    orderBy?: AnalyticsFunnelOrderByWithAggregationInput | AnalyticsFunnelOrderByWithAggregationInput[]
    by: AnalyticsFunnelScalarFieldEnum[] | AnalyticsFunnelScalarFieldEnum
    having?: AnalyticsFunnelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalyticsFunnelCountAggregateInputType | true
    _min?: AnalyticsFunnelMinAggregateInputType
    _max?: AnalyticsFunnelMaxAggregateInputType
  }

  export type AnalyticsFunnelGroupByOutputType = {
    id: string
    name: string
    steps: JsonValue
    conversionRates: JsonValue | null
    dropoffRates: JsonValue | null
    avgTimePerStep: JsonValue | null
    lastCalculated: Date | null
    createdAt: Date
    updatedAt: Date
    _count: AnalyticsFunnelCountAggregateOutputType | null
    _min: AnalyticsFunnelMinAggregateOutputType | null
    _max: AnalyticsFunnelMaxAggregateOutputType | null
  }

  type GetAnalyticsFunnelGroupByPayload<T extends AnalyticsFunnelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnalyticsFunnelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalyticsFunnelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalyticsFunnelGroupByOutputType[P]>
            : GetScalarType<T[P], AnalyticsFunnelGroupByOutputType[P]>
        }
      >
    >


  export type AnalyticsFunnelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    steps?: boolean
    conversionRates?: boolean
    dropoffRates?: boolean
    avgTimePerStep?: boolean
    lastCalculated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["analyticsFunnel"]>

  export type AnalyticsFunnelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    steps?: boolean
    conversionRates?: boolean
    dropoffRates?: boolean
    avgTimePerStep?: boolean
    lastCalculated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["analyticsFunnel"]>

  export type AnalyticsFunnelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    steps?: boolean
    conversionRates?: boolean
    dropoffRates?: boolean
    avgTimePerStep?: boolean
    lastCalculated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["analyticsFunnel"]>

  export type AnalyticsFunnelSelectScalar = {
    id?: boolean
    name?: boolean
    steps?: boolean
    conversionRates?: boolean
    dropoffRates?: boolean
    avgTimePerStep?: boolean
    lastCalculated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AnalyticsFunnelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "steps" | "conversionRates" | "dropoffRates" | "avgTimePerStep" | "lastCalculated" | "createdAt" | "updatedAt", ExtArgs["result"]["analyticsFunnel"]>

  export type $AnalyticsFunnelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnalyticsFunnel"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      steps: Prisma.JsonValue
      conversionRates: Prisma.JsonValue | null
      dropoffRates: Prisma.JsonValue | null
      avgTimePerStep: Prisma.JsonValue | null
      lastCalculated: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["analyticsFunnel"]>
    composites: {}
  }

  type AnalyticsFunnelGetPayload<S extends boolean | null | undefined | AnalyticsFunnelDefaultArgs> = $Result.GetResult<Prisma.$AnalyticsFunnelPayload, S>

  type AnalyticsFunnelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnalyticsFunnelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnalyticsFunnelCountAggregateInputType | true
    }

  export interface AnalyticsFunnelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnalyticsFunnel'], meta: { name: 'AnalyticsFunnel' } }
    /**
     * Find zero or one AnalyticsFunnel that matches the filter.
     * @param {AnalyticsFunnelFindUniqueArgs} args - Arguments to find a AnalyticsFunnel
     * @example
     * // Get one AnalyticsFunnel
     * const analyticsFunnel = await prisma.analyticsFunnel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnalyticsFunnelFindUniqueArgs>(args: SelectSubset<T, AnalyticsFunnelFindUniqueArgs<ExtArgs>>): Prisma__AnalyticsFunnelClient<$Result.GetResult<Prisma.$AnalyticsFunnelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AnalyticsFunnel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnalyticsFunnelFindUniqueOrThrowArgs} args - Arguments to find a AnalyticsFunnel
     * @example
     * // Get one AnalyticsFunnel
     * const analyticsFunnel = await prisma.analyticsFunnel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnalyticsFunnelFindUniqueOrThrowArgs>(args: SelectSubset<T, AnalyticsFunnelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnalyticsFunnelClient<$Result.GetResult<Prisma.$AnalyticsFunnelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalyticsFunnel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsFunnelFindFirstArgs} args - Arguments to find a AnalyticsFunnel
     * @example
     * // Get one AnalyticsFunnel
     * const analyticsFunnel = await prisma.analyticsFunnel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnalyticsFunnelFindFirstArgs>(args?: SelectSubset<T, AnalyticsFunnelFindFirstArgs<ExtArgs>>): Prisma__AnalyticsFunnelClient<$Result.GetResult<Prisma.$AnalyticsFunnelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalyticsFunnel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsFunnelFindFirstOrThrowArgs} args - Arguments to find a AnalyticsFunnel
     * @example
     * // Get one AnalyticsFunnel
     * const analyticsFunnel = await prisma.analyticsFunnel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnalyticsFunnelFindFirstOrThrowArgs>(args?: SelectSubset<T, AnalyticsFunnelFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnalyticsFunnelClient<$Result.GetResult<Prisma.$AnalyticsFunnelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AnalyticsFunnels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsFunnelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnalyticsFunnels
     * const analyticsFunnels = await prisma.analyticsFunnel.findMany()
     * 
     * // Get first 10 AnalyticsFunnels
     * const analyticsFunnels = await prisma.analyticsFunnel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analyticsFunnelWithIdOnly = await prisma.analyticsFunnel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnalyticsFunnelFindManyArgs>(args?: SelectSubset<T, AnalyticsFunnelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsFunnelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AnalyticsFunnel.
     * @param {AnalyticsFunnelCreateArgs} args - Arguments to create a AnalyticsFunnel.
     * @example
     * // Create one AnalyticsFunnel
     * const AnalyticsFunnel = await prisma.analyticsFunnel.create({
     *   data: {
     *     // ... data to create a AnalyticsFunnel
     *   }
     * })
     * 
     */
    create<T extends AnalyticsFunnelCreateArgs>(args: SelectSubset<T, AnalyticsFunnelCreateArgs<ExtArgs>>): Prisma__AnalyticsFunnelClient<$Result.GetResult<Prisma.$AnalyticsFunnelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AnalyticsFunnels.
     * @param {AnalyticsFunnelCreateManyArgs} args - Arguments to create many AnalyticsFunnels.
     * @example
     * // Create many AnalyticsFunnels
     * const analyticsFunnel = await prisma.analyticsFunnel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnalyticsFunnelCreateManyArgs>(args?: SelectSubset<T, AnalyticsFunnelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnalyticsFunnels and returns the data saved in the database.
     * @param {AnalyticsFunnelCreateManyAndReturnArgs} args - Arguments to create many AnalyticsFunnels.
     * @example
     * // Create many AnalyticsFunnels
     * const analyticsFunnel = await prisma.analyticsFunnel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnalyticsFunnels and only return the `id`
     * const analyticsFunnelWithIdOnly = await prisma.analyticsFunnel.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnalyticsFunnelCreateManyAndReturnArgs>(args?: SelectSubset<T, AnalyticsFunnelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsFunnelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AnalyticsFunnel.
     * @param {AnalyticsFunnelDeleteArgs} args - Arguments to delete one AnalyticsFunnel.
     * @example
     * // Delete one AnalyticsFunnel
     * const AnalyticsFunnel = await prisma.analyticsFunnel.delete({
     *   where: {
     *     // ... filter to delete one AnalyticsFunnel
     *   }
     * })
     * 
     */
    delete<T extends AnalyticsFunnelDeleteArgs>(args: SelectSubset<T, AnalyticsFunnelDeleteArgs<ExtArgs>>): Prisma__AnalyticsFunnelClient<$Result.GetResult<Prisma.$AnalyticsFunnelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AnalyticsFunnel.
     * @param {AnalyticsFunnelUpdateArgs} args - Arguments to update one AnalyticsFunnel.
     * @example
     * // Update one AnalyticsFunnel
     * const analyticsFunnel = await prisma.analyticsFunnel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnalyticsFunnelUpdateArgs>(args: SelectSubset<T, AnalyticsFunnelUpdateArgs<ExtArgs>>): Prisma__AnalyticsFunnelClient<$Result.GetResult<Prisma.$AnalyticsFunnelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AnalyticsFunnels.
     * @param {AnalyticsFunnelDeleteManyArgs} args - Arguments to filter AnalyticsFunnels to delete.
     * @example
     * // Delete a few AnalyticsFunnels
     * const { count } = await prisma.analyticsFunnel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnalyticsFunnelDeleteManyArgs>(args?: SelectSubset<T, AnalyticsFunnelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalyticsFunnels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsFunnelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnalyticsFunnels
     * const analyticsFunnel = await prisma.analyticsFunnel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnalyticsFunnelUpdateManyArgs>(args: SelectSubset<T, AnalyticsFunnelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalyticsFunnels and returns the data updated in the database.
     * @param {AnalyticsFunnelUpdateManyAndReturnArgs} args - Arguments to update many AnalyticsFunnels.
     * @example
     * // Update many AnalyticsFunnels
     * const analyticsFunnel = await prisma.analyticsFunnel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AnalyticsFunnels and only return the `id`
     * const analyticsFunnelWithIdOnly = await prisma.analyticsFunnel.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnalyticsFunnelUpdateManyAndReturnArgs>(args: SelectSubset<T, AnalyticsFunnelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsFunnelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AnalyticsFunnel.
     * @param {AnalyticsFunnelUpsertArgs} args - Arguments to update or create a AnalyticsFunnel.
     * @example
     * // Update or create a AnalyticsFunnel
     * const analyticsFunnel = await prisma.analyticsFunnel.upsert({
     *   create: {
     *     // ... data to create a AnalyticsFunnel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnalyticsFunnel we want to update
     *   }
     * })
     */
    upsert<T extends AnalyticsFunnelUpsertArgs>(args: SelectSubset<T, AnalyticsFunnelUpsertArgs<ExtArgs>>): Prisma__AnalyticsFunnelClient<$Result.GetResult<Prisma.$AnalyticsFunnelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AnalyticsFunnels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsFunnelCountArgs} args - Arguments to filter AnalyticsFunnels to count.
     * @example
     * // Count the number of AnalyticsFunnels
     * const count = await prisma.analyticsFunnel.count({
     *   where: {
     *     // ... the filter for the AnalyticsFunnels we want to count
     *   }
     * })
    **/
    count<T extends AnalyticsFunnelCountArgs>(
      args?: Subset<T, AnalyticsFunnelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalyticsFunnelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnalyticsFunnel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsFunnelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalyticsFunnelAggregateArgs>(args: Subset<T, AnalyticsFunnelAggregateArgs>): Prisma.PrismaPromise<GetAnalyticsFunnelAggregateType<T>>

    /**
     * Group by AnalyticsFunnel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsFunnelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnalyticsFunnelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnalyticsFunnelGroupByArgs['orderBy'] }
        : { orderBy?: AnalyticsFunnelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnalyticsFunnelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalyticsFunnelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnalyticsFunnel model
   */
  readonly fields: AnalyticsFunnelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnalyticsFunnel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnalyticsFunnelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnalyticsFunnel model
   */
  interface AnalyticsFunnelFieldRefs {
    readonly id: FieldRef<"AnalyticsFunnel", 'String'>
    readonly name: FieldRef<"AnalyticsFunnel", 'String'>
    readonly steps: FieldRef<"AnalyticsFunnel", 'Json'>
    readonly conversionRates: FieldRef<"AnalyticsFunnel", 'Json'>
    readonly dropoffRates: FieldRef<"AnalyticsFunnel", 'Json'>
    readonly avgTimePerStep: FieldRef<"AnalyticsFunnel", 'Json'>
    readonly lastCalculated: FieldRef<"AnalyticsFunnel", 'DateTime'>
    readonly createdAt: FieldRef<"AnalyticsFunnel", 'DateTime'>
    readonly updatedAt: FieldRef<"AnalyticsFunnel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AnalyticsFunnel findUnique
   */
  export type AnalyticsFunnelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsFunnel
     */
    select?: AnalyticsFunnelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsFunnel
     */
    omit?: AnalyticsFunnelOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsFunnel to fetch.
     */
    where: AnalyticsFunnelWhereUniqueInput
  }

  /**
   * AnalyticsFunnel findUniqueOrThrow
   */
  export type AnalyticsFunnelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsFunnel
     */
    select?: AnalyticsFunnelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsFunnel
     */
    omit?: AnalyticsFunnelOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsFunnel to fetch.
     */
    where: AnalyticsFunnelWhereUniqueInput
  }

  /**
   * AnalyticsFunnel findFirst
   */
  export type AnalyticsFunnelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsFunnel
     */
    select?: AnalyticsFunnelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsFunnel
     */
    omit?: AnalyticsFunnelOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsFunnel to fetch.
     */
    where?: AnalyticsFunnelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsFunnels to fetch.
     */
    orderBy?: AnalyticsFunnelOrderByWithRelationInput | AnalyticsFunnelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsFunnels.
     */
    cursor?: AnalyticsFunnelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsFunnels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsFunnels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsFunnels.
     */
    distinct?: AnalyticsFunnelScalarFieldEnum | AnalyticsFunnelScalarFieldEnum[]
  }

  /**
   * AnalyticsFunnel findFirstOrThrow
   */
  export type AnalyticsFunnelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsFunnel
     */
    select?: AnalyticsFunnelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsFunnel
     */
    omit?: AnalyticsFunnelOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsFunnel to fetch.
     */
    where?: AnalyticsFunnelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsFunnels to fetch.
     */
    orderBy?: AnalyticsFunnelOrderByWithRelationInput | AnalyticsFunnelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsFunnels.
     */
    cursor?: AnalyticsFunnelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsFunnels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsFunnels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsFunnels.
     */
    distinct?: AnalyticsFunnelScalarFieldEnum | AnalyticsFunnelScalarFieldEnum[]
  }

  /**
   * AnalyticsFunnel findMany
   */
  export type AnalyticsFunnelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsFunnel
     */
    select?: AnalyticsFunnelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsFunnel
     */
    omit?: AnalyticsFunnelOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsFunnels to fetch.
     */
    where?: AnalyticsFunnelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsFunnels to fetch.
     */
    orderBy?: AnalyticsFunnelOrderByWithRelationInput | AnalyticsFunnelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnalyticsFunnels.
     */
    cursor?: AnalyticsFunnelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsFunnels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsFunnels.
     */
    skip?: number
    distinct?: AnalyticsFunnelScalarFieldEnum | AnalyticsFunnelScalarFieldEnum[]
  }

  /**
   * AnalyticsFunnel create
   */
  export type AnalyticsFunnelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsFunnel
     */
    select?: AnalyticsFunnelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsFunnel
     */
    omit?: AnalyticsFunnelOmit<ExtArgs> | null
    /**
     * The data needed to create a AnalyticsFunnel.
     */
    data: XOR<AnalyticsFunnelCreateInput, AnalyticsFunnelUncheckedCreateInput>
  }

  /**
   * AnalyticsFunnel createMany
   */
  export type AnalyticsFunnelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnalyticsFunnels.
     */
    data: AnalyticsFunnelCreateManyInput | AnalyticsFunnelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnalyticsFunnel createManyAndReturn
   */
  export type AnalyticsFunnelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsFunnel
     */
    select?: AnalyticsFunnelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsFunnel
     */
    omit?: AnalyticsFunnelOmit<ExtArgs> | null
    /**
     * The data used to create many AnalyticsFunnels.
     */
    data: AnalyticsFunnelCreateManyInput | AnalyticsFunnelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnalyticsFunnel update
   */
  export type AnalyticsFunnelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsFunnel
     */
    select?: AnalyticsFunnelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsFunnel
     */
    omit?: AnalyticsFunnelOmit<ExtArgs> | null
    /**
     * The data needed to update a AnalyticsFunnel.
     */
    data: XOR<AnalyticsFunnelUpdateInput, AnalyticsFunnelUncheckedUpdateInput>
    /**
     * Choose, which AnalyticsFunnel to update.
     */
    where: AnalyticsFunnelWhereUniqueInput
  }

  /**
   * AnalyticsFunnel updateMany
   */
  export type AnalyticsFunnelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnalyticsFunnels.
     */
    data: XOR<AnalyticsFunnelUpdateManyMutationInput, AnalyticsFunnelUncheckedUpdateManyInput>
    /**
     * Filter which AnalyticsFunnels to update
     */
    where?: AnalyticsFunnelWhereInput
    /**
     * Limit how many AnalyticsFunnels to update.
     */
    limit?: number
  }

  /**
   * AnalyticsFunnel updateManyAndReturn
   */
  export type AnalyticsFunnelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsFunnel
     */
    select?: AnalyticsFunnelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsFunnel
     */
    omit?: AnalyticsFunnelOmit<ExtArgs> | null
    /**
     * The data used to update AnalyticsFunnels.
     */
    data: XOR<AnalyticsFunnelUpdateManyMutationInput, AnalyticsFunnelUncheckedUpdateManyInput>
    /**
     * Filter which AnalyticsFunnels to update
     */
    where?: AnalyticsFunnelWhereInput
    /**
     * Limit how many AnalyticsFunnels to update.
     */
    limit?: number
  }

  /**
   * AnalyticsFunnel upsert
   */
  export type AnalyticsFunnelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsFunnel
     */
    select?: AnalyticsFunnelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsFunnel
     */
    omit?: AnalyticsFunnelOmit<ExtArgs> | null
    /**
     * The filter to search for the AnalyticsFunnel to update in case it exists.
     */
    where: AnalyticsFunnelWhereUniqueInput
    /**
     * In case the AnalyticsFunnel found by the `where` argument doesn't exist, create a new AnalyticsFunnel with this data.
     */
    create: XOR<AnalyticsFunnelCreateInput, AnalyticsFunnelUncheckedCreateInput>
    /**
     * In case the AnalyticsFunnel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnalyticsFunnelUpdateInput, AnalyticsFunnelUncheckedUpdateInput>
  }

  /**
   * AnalyticsFunnel delete
   */
  export type AnalyticsFunnelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsFunnel
     */
    select?: AnalyticsFunnelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsFunnel
     */
    omit?: AnalyticsFunnelOmit<ExtArgs> | null
    /**
     * Filter which AnalyticsFunnel to delete.
     */
    where: AnalyticsFunnelWhereUniqueInput
  }

  /**
   * AnalyticsFunnel deleteMany
   */
  export type AnalyticsFunnelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsFunnels to delete
     */
    where?: AnalyticsFunnelWhereInput
    /**
     * Limit how many AnalyticsFunnels to delete.
     */
    limit?: number
  }

  /**
   * AnalyticsFunnel without action
   */
  export type AnalyticsFunnelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsFunnel
     */
    select?: AnalyticsFunnelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsFunnel
     */
    omit?: AnalyticsFunnelOmit<ExtArgs> | null
  }


  /**
   * Model AnalyticsAttribution
   */

  export type AggregateAnalyticsAttribution = {
    _count: AnalyticsAttributionCountAggregateOutputType | null
    _avg: AnalyticsAttributionAvgAggregateOutputType | null
    _sum: AnalyticsAttributionSumAggregateOutputType | null
    _min: AnalyticsAttributionMinAggregateOutputType | null
    _max: AnalyticsAttributionMaxAggregateOutputType | null
  }

  export type AnalyticsAttributionAvgAggregateOutputType = {
    conversionValue: number | null
  }

  export type AnalyticsAttributionSumAggregateOutputType = {
    conversionValue: number | null
  }

  export type AnalyticsAttributionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    conversionId: string | null
    conversionType: string | null
    conversionValue: number | null
    model: string | null
    convertedAt: Date | null
    createdAt: Date | null
  }

  export type AnalyticsAttributionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    conversionId: string | null
    conversionType: string | null
    conversionValue: number | null
    model: string | null
    convertedAt: Date | null
    createdAt: Date | null
  }

  export type AnalyticsAttributionCountAggregateOutputType = {
    id: number
    userId: number
    conversionId: number
    conversionType: number
    conversionValue: number
    touchpoints: number
    model: number
    channelWeights: number
    convertedAt: number
    createdAt: number
    _all: number
  }


  export type AnalyticsAttributionAvgAggregateInputType = {
    conversionValue?: true
  }

  export type AnalyticsAttributionSumAggregateInputType = {
    conversionValue?: true
  }

  export type AnalyticsAttributionMinAggregateInputType = {
    id?: true
    userId?: true
    conversionId?: true
    conversionType?: true
    conversionValue?: true
    model?: true
    convertedAt?: true
    createdAt?: true
  }

  export type AnalyticsAttributionMaxAggregateInputType = {
    id?: true
    userId?: true
    conversionId?: true
    conversionType?: true
    conversionValue?: true
    model?: true
    convertedAt?: true
    createdAt?: true
  }

  export type AnalyticsAttributionCountAggregateInputType = {
    id?: true
    userId?: true
    conversionId?: true
    conversionType?: true
    conversionValue?: true
    touchpoints?: true
    model?: true
    channelWeights?: true
    convertedAt?: true
    createdAt?: true
    _all?: true
  }

  export type AnalyticsAttributionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsAttribution to aggregate.
     */
    where?: AnalyticsAttributionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsAttributions to fetch.
     */
    orderBy?: AnalyticsAttributionOrderByWithRelationInput | AnalyticsAttributionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnalyticsAttributionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsAttributions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsAttributions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnalyticsAttributions
    **/
    _count?: true | AnalyticsAttributionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnalyticsAttributionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnalyticsAttributionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalyticsAttributionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalyticsAttributionMaxAggregateInputType
  }

  export type GetAnalyticsAttributionAggregateType<T extends AnalyticsAttributionAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalyticsAttribution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalyticsAttribution[P]>
      : GetScalarType<T[P], AggregateAnalyticsAttribution[P]>
  }




  export type AnalyticsAttributionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticsAttributionWhereInput
    orderBy?: AnalyticsAttributionOrderByWithAggregationInput | AnalyticsAttributionOrderByWithAggregationInput[]
    by: AnalyticsAttributionScalarFieldEnum[] | AnalyticsAttributionScalarFieldEnum
    having?: AnalyticsAttributionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalyticsAttributionCountAggregateInputType | true
    _avg?: AnalyticsAttributionAvgAggregateInputType
    _sum?: AnalyticsAttributionSumAggregateInputType
    _min?: AnalyticsAttributionMinAggregateInputType
    _max?: AnalyticsAttributionMaxAggregateInputType
  }

  export type AnalyticsAttributionGroupByOutputType = {
    id: string
    userId: string
    conversionId: string | null
    conversionType: string
    conversionValue: number | null
    touchpoints: JsonValue
    model: string
    channelWeights: JsonValue
    convertedAt: Date | null
    createdAt: Date
    _count: AnalyticsAttributionCountAggregateOutputType | null
    _avg: AnalyticsAttributionAvgAggregateOutputType | null
    _sum: AnalyticsAttributionSumAggregateOutputType | null
    _min: AnalyticsAttributionMinAggregateOutputType | null
    _max: AnalyticsAttributionMaxAggregateOutputType | null
  }

  type GetAnalyticsAttributionGroupByPayload<T extends AnalyticsAttributionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnalyticsAttributionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalyticsAttributionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalyticsAttributionGroupByOutputType[P]>
            : GetScalarType<T[P], AnalyticsAttributionGroupByOutputType[P]>
        }
      >
    >


  export type AnalyticsAttributionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    conversionId?: boolean
    conversionType?: boolean
    conversionValue?: boolean
    touchpoints?: boolean
    model?: boolean
    channelWeights?: boolean
    convertedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["analyticsAttribution"]>

  export type AnalyticsAttributionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    conversionId?: boolean
    conversionType?: boolean
    conversionValue?: boolean
    touchpoints?: boolean
    model?: boolean
    channelWeights?: boolean
    convertedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["analyticsAttribution"]>

  export type AnalyticsAttributionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    conversionId?: boolean
    conversionType?: boolean
    conversionValue?: boolean
    touchpoints?: boolean
    model?: boolean
    channelWeights?: boolean
    convertedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["analyticsAttribution"]>

  export type AnalyticsAttributionSelectScalar = {
    id?: boolean
    userId?: boolean
    conversionId?: boolean
    conversionType?: boolean
    conversionValue?: boolean
    touchpoints?: boolean
    model?: boolean
    channelWeights?: boolean
    convertedAt?: boolean
    createdAt?: boolean
  }

  export type AnalyticsAttributionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "conversionId" | "conversionType" | "conversionValue" | "touchpoints" | "model" | "channelWeights" | "convertedAt" | "createdAt", ExtArgs["result"]["analyticsAttribution"]>

  export type $AnalyticsAttributionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnalyticsAttribution"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      conversionId: string | null
      conversionType: string
      conversionValue: number | null
      touchpoints: Prisma.JsonValue
      model: string
      channelWeights: Prisma.JsonValue
      convertedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["analyticsAttribution"]>
    composites: {}
  }

  type AnalyticsAttributionGetPayload<S extends boolean | null | undefined | AnalyticsAttributionDefaultArgs> = $Result.GetResult<Prisma.$AnalyticsAttributionPayload, S>

  type AnalyticsAttributionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnalyticsAttributionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnalyticsAttributionCountAggregateInputType | true
    }

  export interface AnalyticsAttributionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnalyticsAttribution'], meta: { name: 'AnalyticsAttribution' } }
    /**
     * Find zero or one AnalyticsAttribution that matches the filter.
     * @param {AnalyticsAttributionFindUniqueArgs} args - Arguments to find a AnalyticsAttribution
     * @example
     * // Get one AnalyticsAttribution
     * const analyticsAttribution = await prisma.analyticsAttribution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnalyticsAttributionFindUniqueArgs>(args: SelectSubset<T, AnalyticsAttributionFindUniqueArgs<ExtArgs>>): Prisma__AnalyticsAttributionClient<$Result.GetResult<Prisma.$AnalyticsAttributionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AnalyticsAttribution that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnalyticsAttributionFindUniqueOrThrowArgs} args - Arguments to find a AnalyticsAttribution
     * @example
     * // Get one AnalyticsAttribution
     * const analyticsAttribution = await prisma.analyticsAttribution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnalyticsAttributionFindUniqueOrThrowArgs>(args: SelectSubset<T, AnalyticsAttributionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnalyticsAttributionClient<$Result.GetResult<Prisma.$AnalyticsAttributionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalyticsAttribution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsAttributionFindFirstArgs} args - Arguments to find a AnalyticsAttribution
     * @example
     * // Get one AnalyticsAttribution
     * const analyticsAttribution = await prisma.analyticsAttribution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnalyticsAttributionFindFirstArgs>(args?: SelectSubset<T, AnalyticsAttributionFindFirstArgs<ExtArgs>>): Prisma__AnalyticsAttributionClient<$Result.GetResult<Prisma.$AnalyticsAttributionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalyticsAttribution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsAttributionFindFirstOrThrowArgs} args - Arguments to find a AnalyticsAttribution
     * @example
     * // Get one AnalyticsAttribution
     * const analyticsAttribution = await prisma.analyticsAttribution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnalyticsAttributionFindFirstOrThrowArgs>(args?: SelectSubset<T, AnalyticsAttributionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnalyticsAttributionClient<$Result.GetResult<Prisma.$AnalyticsAttributionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AnalyticsAttributions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsAttributionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnalyticsAttributions
     * const analyticsAttributions = await prisma.analyticsAttribution.findMany()
     * 
     * // Get first 10 AnalyticsAttributions
     * const analyticsAttributions = await prisma.analyticsAttribution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analyticsAttributionWithIdOnly = await prisma.analyticsAttribution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnalyticsAttributionFindManyArgs>(args?: SelectSubset<T, AnalyticsAttributionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsAttributionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AnalyticsAttribution.
     * @param {AnalyticsAttributionCreateArgs} args - Arguments to create a AnalyticsAttribution.
     * @example
     * // Create one AnalyticsAttribution
     * const AnalyticsAttribution = await prisma.analyticsAttribution.create({
     *   data: {
     *     // ... data to create a AnalyticsAttribution
     *   }
     * })
     * 
     */
    create<T extends AnalyticsAttributionCreateArgs>(args: SelectSubset<T, AnalyticsAttributionCreateArgs<ExtArgs>>): Prisma__AnalyticsAttributionClient<$Result.GetResult<Prisma.$AnalyticsAttributionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AnalyticsAttributions.
     * @param {AnalyticsAttributionCreateManyArgs} args - Arguments to create many AnalyticsAttributions.
     * @example
     * // Create many AnalyticsAttributions
     * const analyticsAttribution = await prisma.analyticsAttribution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnalyticsAttributionCreateManyArgs>(args?: SelectSubset<T, AnalyticsAttributionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnalyticsAttributions and returns the data saved in the database.
     * @param {AnalyticsAttributionCreateManyAndReturnArgs} args - Arguments to create many AnalyticsAttributions.
     * @example
     * // Create many AnalyticsAttributions
     * const analyticsAttribution = await prisma.analyticsAttribution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnalyticsAttributions and only return the `id`
     * const analyticsAttributionWithIdOnly = await prisma.analyticsAttribution.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnalyticsAttributionCreateManyAndReturnArgs>(args?: SelectSubset<T, AnalyticsAttributionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsAttributionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AnalyticsAttribution.
     * @param {AnalyticsAttributionDeleteArgs} args - Arguments to delete one AnalyticsAttribution.
     * @example
     * // Delete one AnalyticsAttribution
     * const AnalyticsAttribution = await prisma.analyticsAttribution.delete({
     *   where: {
     *     // ... filter to delete one AnalyticsAttribution
     *   }
     * })
     * 
     */
    delete<T extends AnalyticsAttributionDeleteArgs>(args: SelectSubset<T, AnalyticsAttributionDeleteArgs<ExtArgs>>): Prisma__AnalyticsAttributionClient<$Result.GetResult<Prisma.$AnalyticsAttributionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AnalyticsAttribution.
     * @param {AnalyticsAttributionUpdateArgs} args - Arguments to update one AnalyticsAttribution.
     * @example
     * // Update one AnalyticsAttribution
     * const analyticsAttribution = await prisma.analyticsAttribution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnalyticsAttributionUpdateArgs>(args: SelectSubset<T, AnalyticsAttributionUpdateArgs<ExtArgs>>): Prisma__AnalyticsAttributionClient<$Result.GetResult<Prisma.$AnalyticsAttributionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AnalyticsAttributions.
     * @param {AnalyticsAttributionDeleteManyArgs} args - Arguments to filter AnalyticsAttributions to delete.
     * @example
     * // Delete a few AnalyticsAttributions
     * const { count } = await prisma.analyticsAttribution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnalyticsAttributionDeleteManyArgs>(args?: SelectSubset<T, AnalyticsAttributionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalyticsAttributions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsAttributionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnalyticsAttributions
     * const analyticsAttribution = await prisma.analyticsAttribution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnalyticsAttributionUpdateManyArgs>(args: SelectSubset<T, AnalyticsAttributionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalyticsAttributions and returns the data updated in the database.
     * @param {AnalyticsAttributionUpdateManyAndReturnArgs} args - Arguments to update many AnalyticsAttributions.
     * @example
     * // Update many AnalyticsAttributions
     * const analyticsAttribution = await prisma.analyticsAttribution.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AnalyticsAttributions and only return the `id`
     * const analyticsAttributionWithIdOnly = await prisma.analyticsAttribution.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnalyticsAttributionUpdateManyAndReturnArgs>(args: SelectSubset<T, AnalyticsAttributionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsAttributionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AnalyticsAttribution.
     * @param {AnalyticsAttributionUpsertArgs} args - Arguments to update or create a AnalyticsAttribution.
     * @example
     * // Update or create a AnalyticsAttribution
     * const analyticsAttribution = await prisma.analyticsAttribution.upsert({
     *   create: {
     *     // ... data to create a AnalyticsAttribution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnalyticsAttribution we want to update
     *   }
     * })
     */
    upsert<T extends AnalyticsAttributionUpsertArgs>(args: SelectSubset<T, AnalyticsAttributionUpsertArgs<ExtArgs>>): Prisma__AnalyticsAttributionClient<$Result.GetResult<Prisma.$AnalyticsAttributionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AnalyticsAttributions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsAttributionCountArgs} args - Arguments to filter AnalyticsAttributions to count.
     * @example
     * // Count the number of AnalyticsAttributions
     * const count = await prisma.analyticsAttribution.count({
     *   where: {
     *     // ... the filter for the AnalyticsAttributions we want to count
     *   }
     * })
    **/
    count<T extends AnalyticsAttributionCountArgs>(
      args?: Subset<T, AnalyticsAttributionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalyticsAttributionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnalyticsAttribution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsAttributionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalyticsAttributionAggregateArgs>(args: Subset<T, AnalyticsAttributionAggregateArgs>): Prisma.PrismaPromise<GetAnalyticsAttributionAggregateType<T>>

    /**
     * Group by AnalyticsAttribution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsAttributionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnalyticsAttributionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnalyticsAttributionGroupByArgs['orderBy'] }
        : { orderBy?: AnalyticsAttributionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnalyticsAttributionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalyticsAttributionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnalyticsAttribution model
   */
  readonly fields: AnalyticsAttributionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnalyticsAttribution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnalyticsAttributionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnalyticsAttribution model
   */
  interface AnalyticsAttributionFieldRefs {
    readonly id: FieldRef<"AnalyticsAttribution", 'String'>
    readonly userId: FieldRef<"AnalyticsAttribution", 'String'>
    readonly conversionId: FieldRef<"AnalyticsAttribution", 'String'>
    readonly conversionType: FieldRef<"AnalyticsAttribution", 'String'>
    readonly conversionValue: FieldRef<"AnalyticsAttribution", 'Float'>
    readonly touchpoints: FieldRef<"AnalyticsAttribution", 'Json'>
    readonly model: FieldRef<"AnalyticsAttribution", 'String'>
    readonly channelWeights: FieldRef<"AnalyticsAttribution", 'Json'>
    readonly convertedAt: FieldRef<"AnalyticsAttribution", 'DateTime'>
    readonly createdAt: FieldRef<"AnalyticsAttribution", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AnalyticsAttribution findUnique
   */
  export type AnalyticsAttributionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsAttribution
     */
    select?: AnalyticsAttributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsAttribution
     */
    omit?: AnalyticsAttributionOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsAttribution to fetch.
     */
    where: AnalyticsAttributionWhereUniqueInput
  }

  /**
   * AnalyticsAttribution findUniqueOrThrow
   */
  export type AnalyticsAttributionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsAttribution
     */
    select?: AnalyticsAttributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsAttribution
     */
    omit?: AnalyticsAttributionOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsAttribution to fetch.
     */
    where: AnalyticsAttributionWhereUniqueInput
  }

  /**
   * AnalyticsAttribution findFirst
   */
  export type AnalyticsAttributionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsAttribution
     */
    select?: AnalyticsAttributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsAttribution
     */
    omit?: AnalyticsAttributionOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsAttribution to fetch.
     */
    where?: AnalyticsAttributionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsAttributions to fetch.
     */
    orderBy?: AnalyticsAttributionOrderByWithRelationInput | AnalyticsAttributionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsAttributions.
     */
    cursor?: AnalyticsAttributionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsAttributions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsAttributions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsAttributions.
     */
    distinct?: AnalyticsAttributionScalarFieldEnum | AnalyticsAttributionScalarFieldEnum[]
  }

  /**
   * AnalyticsAttribution findFirstOrThrow
   */
  export type AnalyticsAttributionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsAttribution
     */
    select?: AnalyticsAttributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsAttribution
     */
    omit?: AnalyticsAttributionOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsAttribution to fetch.
     */
    where?: AnalyticsAttributionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsAttributions to fetch.
     */
    orderBy?: AnalyticsAttributionOrderByWithRelationInput | AnalyticsAttributionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsAttributions.
     */
    cursor?: AnalyticsAttributionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsAttributions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsAttributions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsAttributions.
     */
    distinct?: AnalyticsAttributionScalarFieldEnum | AnalyticsAttributionScalarFieldEnum[]
  }

  /**
   * AnalyticsAttribution findMany
   */
  export type AnalyticsAttributionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsAttribution
     */
    select?: AnalyticsAttributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsAttribution
     */
    omit?: AnalyticsAttributionOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsAttributions to fetch.
     */
    where?: AnalyticsAttributionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsAttributions to fetch.
     */
    orderBy?: AnalyticsAttributionOrderByWithRelationInput | AnalyticsAttributionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnalyticsAttributions.
     */
    cursor?: AnalyticsAttributionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsAttributions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsAttributions.
     */
    skip?: number
    distinct?: AnalyticsAttributionScalarFieldEnum | AnalyticsAttributionScalarFieldEnum[]
  }

  /**
   * AnalyticsAttribution create
   */
  export type AnalyticsAttributionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsAttribution
     */
    select?: AnalyticsAttributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsAttribution
     */
    omit?: AnalyticsAttributionOmit<ExtArgs> | null
    /**
     * The data needed to create a AnalyticsAttribution.
     */
    data: XOR<AnalyticsAttributionCreateInput, AnalyticsAttributionUncheckedCreateInput>
  }

  /**
   * AnalyticsAttribution createMany
   */
  export type AnalyticsAttributionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnalyticsAttributions.
     */
    data: AnalyticsAttributionCreateManyInput | AnalyticsAttributionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnalyticsAttribution createManyAndReturn
   */
  export type AnalyticsAttributionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsAttribution
     */
    select?: AnalyticsAttributionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsAttribution
     */
    omit?: AnalyticsAttributionOmit<ExtArgs> | null
    /**
     * The data used to create many AnalyticsAttributions.
     */
    data: AnalyticsAttributionCreateManyInput | AnalyticsAttributionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnalyticsAttribution update
   */
  export type AnalyticsAttributionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsAttribution
     */
    select?: AnalyticsAttributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsAttribution
     */
    omit?: AnalyticsAttributionOmit<ExtArgs> | null
    /**
     * The data needed to update a AnalyticsAttribution.
     */
    data: XOR<AnalyticsAttributionUpdateInput, AnalyticsAttributionUncheckedUpdateInput>
    /**
     * Choose, which AnalyticsAttribution to update.
     */
    where: AnalyticsAttributionWhereUniqueInput
  }

  /**
   * AnalyticsAttribution updateMany
   */
  export type AnalyticsAttributionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnalyticsAttributions.
     */
    data: XOR<AnalyticsAttributionUpdateManyMutationInput, AnalyticsAttributionUncheckedUpdateManyInput>
    /**
     * Filter which AnalyticsAttributions to update
     */
    where?: AnalyticsAttributionWhereInput
    /**
     * Limit how many AnalyticsAttributions to update.
     */
    limit?: number
  }

  /**
   * AnalyticsAttribution updateManyAndReturn
   */
  export type AnalyticsAttributionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsAttribution
     */
    select?: AnalyticsAttributionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsAttribution
     */
    omit?: AnalyticsAttributionOmit<ExtArgs> | null
    /**
     * The data used to update AnalyticsAttributions.
     */
    data: XOR<AnalyticsAttributionUpdateManyMutationInput, AnalyticsAttributionUncheckedUpdateManyInput>
    /**
     * Filter which AnalyticsAttributions to update
     */
    where?: AnalyticsAttributionWhereInput
    /**
     * Limit how many AnalyticsAttributions to update.
     */
    limit?: number
  }

  /**
   * AnalyticsAttribution upsert
   */
  export type AnalyticsAttributionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsAttribution
     */
    select?: AnalyticsAttributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsAttribution
     */
    omit?: AnalyticsAttributionOmit<ExtArgs> | null
    /**
     * The filter to search for the AnalyticsAttribution to update in case it exists.
     */
    where: AnalyticsAttributionWhereUniqueInput
    /**
     * In case the AnalyticsAttribution found by the `where` argument doesn't exist, create a new AnalyticsAttribution with this data.
     */
    create: XOR<AnalyticsAttributionCreateInput, AnalyticsAttributionUncheckedCreateInput>
    /**
     * In case the AnalyticsAttribution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnalyticsAttributionUpdateInput, AnalyticsAttributionUncheckedUpdateInput>
  }

  /**
   * AnalyticsAttribution delete
   */
  export type AnalyticsAttributionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsAttribution
     */
    select?: AnalyticsAttributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsAttribution
     */
    omit?: AnalyticsAttributionOmit<ExtArgs> | null
    /**
     * Filter which AnalyticsAttribution to delete.
     */
    where: AnalyticsAttributionWhereUniqueInput
  }

  /**
   * AnalyticsAttribution deleteMany
   */
  export type AnalyticsAttributionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsAttributions to delete
     */
    where?: AnalyticsAttributionWhereInput
    /**
     * Limit how many AnalyticsAttributions to delete.
     */
    limit?: number
  }

  /**
   * AnalyticsAttribution without action
   */
  export type AnalyticsAttributionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsAttribution
     */
    select?: AnalyticsAttributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsAttribution
     */
    omit?: AnalyticsAttributionOmit<ExtArgs> | null
  }


  /**
   * Model AnalyticsSegment
   */

  export type AggregateAnalyticsSegment = {
    _count: AnalyticsSegmentCountAggregateOutputType | null
    _avg: AnalyticsSegmentAvgAggregateOutputType | null
    _sum: AnalyticsSegmentSumAggregateOutputType | null
    _min: AnalyticsSegmentMinAggregateOutputType | null
    _max: AnalyticsSegmentMaxAggregateOutputType | null
  }

  export type AnalyticsSegmentAvgAggregateOutputType = {
    userCount: number | null
    avgEngagement: number | null
    avgRevenue: number | null
    conversionRate: number | null
  }

  export type AnalyticsSegmentSumAggregateOutputType = {
    userCount: number | null
    avgEngagement: number | null
    avgRevenue: number | null
    conversionRate: number | null
  }

  export type AnalyticsSegmentMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    userCount: number | null
    avgEngagement: number | null
    avgRevenue: number | null
    conversionRate: number | null
    lastUpdated: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnalyticsSegmentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    userCount: number | null
    avgEngagement: number | null
    avgRevenue: number | null
    conversionRate: number | null
    lastUpdated: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnalyticsSegmentCountAggregateOutputType = {
    id: number
    name: number
    type: number
    conditions: number
    userCount: number
    avgEngagement: number
    avgRevenue: number
    conversionRate: number
    lastUpdated: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AnalyticsSegmentAvgAggregateInputType = {
    userCount?: true
    avgEngagement?: true
    avgRevenue?: true
    conversionRate?: true
  }

  export type AnalyticsSegmentSumAggregateInputType = {
    userCount?: true
    avgEngagement?: true
    avgRevenue?: true
    conversionRate?: true
  }

  export type AnalyticsSegmentMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    userCount?: true
    avgEngagement?: true
    avgRevenue?: true
    conversionRate?: true
    lastUpdated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnalyticsSegmentMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    userCount?: true
    avgEngagement?: true
    avgRevenue?: true
    conversionRate?: true
    lastUpdated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnalyticsSegmentCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    conditions?: true
    userCount?: true
    avgEngagement?: true
    avgRevenue?: true
    conversionRate?: true
    lastUpdated?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AnalyticsSegmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsSegment to aggregate.
     */
    where?: AnalyticsSegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsSegments to fetch.
     */
    orderBy?: AnalyticsSegmentOrderByWithRelationInput | AnalyticsSegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnalyticsSegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsSegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsSegments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnalyticsSegments
    **/
    _count?: true | AnalyticsSegmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnalyticsSegmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnalyticsSegmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalyticsSegmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalyticsSegmentMaxAggregateInputType
  }

  export type GetAnalyticsSegmentAggregateType<T extends AnalyticsSegmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalyticsSegment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalyticsSegment[P]>
      : GetScalarType<T[P], AggregateAnalyticsSegment[P]>
  }




  export type AnalyticsSegmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticsSegmentWhereInput
    orderBy?: AnalyticsSegmentOrderByWithAggregationInput | AnalyticsSegmentOrderByWithAggregationInput[]
    by: AnalyticsSegmentScalarFieldEnum[] | AnalyticsSegmentScalarFieldEnum
    having?: AnalyticsSegmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalyticsSegmentCountAggregateInputType | true
    _avg?: AnalyticsSegmentAvgAggregateInputType
    _sum?: AnalyticsSegmentSumAggregateInputType
    _min?: AnalyticsSegmentMinAggregateInputType
    _max?: AnalyticsSegmentMaxAggregateInputType
  }

  export type AnalyticsSegmentGroupByOutputType = {
    id: string
    name: string
    type: string
    conditions: JsonValue
    userCount: number
    avgEngagement: number | null
    avgRevenue: number | null
    conversionRate: number | null
    lastUpdated: Date | null
    createdAt: Date
    updatedAt: Date
    _count: AnalyticsSegmentCountAggregateOutputType | null
    _avg: AnalyticsSegmentAvgAggregateOutputType | null
    _sum: AnalyticsSegmentSumAggregateOutputType | null
    _min: AnalyticsSegmentMinAggregateOutputType | null
    _max: AnalyticsSegmentMaxAggregateOutputType | null
  }

  type GetAnalyticsSegmentGroupByPayload<T extends AnalyticsSegmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnalyticsSegmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalyticsSegmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalyticsSegmentGroupByOutputType[P]>
            : GetScalarType<T[P], AnalyticsSegmentGroupByOutputType[P]>
        }
      >
    >


  export type AnalyticsSegmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    conditions?: boolean
    userCount?: boolean
    avgEngagement?: boolean
    avgRevenue?: boolean
    conversionRate?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["analyticsSegment"]>

  export type AnalyticsSegmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    conditions?: boolean
    userCount?: boolean
    avgEngagement?: boolean
    avgRevenue?: boolean
    conversionRate?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["analyticsSegment"]>

  export type AnalyticsSegmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    conditions?: boolean
    userCount?: boolean
    avgEngagement?: boolean
    avgRevenue?: boolean
    conversionRate?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["analyticsSegment"]>

  export type AnalyticsSegmentSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    conditions?: boolean
    userCount?: boolean
    avgEngagement?: boolean
    avgRevenue?: boolean
    conversionRate?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AnalyticsSegmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "conditions" | "userCount" | "avgEngagement" | "avgRevenue" | "conversionRate" | "lastUpdated" | "createdAt" | "updatedAt", ExtArgs["result"]["analyticsSegment"]>

  export type $AnalyticsSegmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnalyticsSegment"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      conditions: Prisma.JsonValue
      userCount: number
      avgEngagement: number | null
      avgRevenue: number | null
      conversionRate: number | null
      lastUpdated: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["analyticsSegment"]>
    composites: {}
  }

  type AnalyticsSegmentGetPayload<S extends boolean | null | undefined | AnalyticsSegmentDefaultArgs> = $Result.GetResult<Prisma.$AnalyticsSegmentPayload, S>

  type AnalyticsSegmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnalyticsSegmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnalyticsSegmentCountAggregateInputType | true
    }

  export interface AnalyticsSegmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnalyticsSegment'], meta: { name: 'AnalyticsSegment' } }
    /**
     * Find zero or one AnalyticsSegment that matches the filter.
     * @param {AnalyticsSegmentFindUniqueArgs} args - Arguments to find a AnalyticsSegment
     * @example
     * // Get one AnalyticsSegment
     * const analyticsSegment = await prisma.analyticsSegment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnalyticsSegmentFindUniqueArgs>(args: SelectSubset<T, AnalyticsSegmentFindUniqueArgs<ExtArgs>>): Prisma__AnalyticsSegmentClient<$Result.GetResult<Prisma.$AnalyticsSegmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AnalyticsSegment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnalyticsSegmentFindUniqueOrThrowArgs} args - Arguments to find a AnalyticsSegment
     * @example
     * // Get one AnalyticsSegment
     * const analyticsSegment = await prisma.analyticsSegment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnalyticsSegmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AnalyticsSegmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnalyticsSegmentClient<$Result.GetResult<Prisma.$AnalyticsSegmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalyticsSegment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsSegmentFindFirstArgs} args - Arguments to find a AnalyticsSegment
     * @example
     * // Get one AnalyticsSegment
     * const analyticsSegment = await prisma.analyticsSegment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnalyticsSegmentFindFirstArgs>(args?: SelectSubset<T, AnalyticsSegmentFindFirstArgs<ExtArgs>>): Prisma__AnalyticsSegmentClient<$Result.GetResult<Prisma.$AnalyticsSegmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalyticsSegment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsSegmentFindFirstOrThrowArgs} args - Arguments to find a AnalyticsSegment
     * @example
     * // Get one AnalyticsSegment
     * const analyticsSegment = await prisma.analyticsSegment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnalyticsSegmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AnalyticsSegmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnalyticsSegmentClient<$Result.GetResult<Prisma.$AnalyticsSegmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AnalyticsSegments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsSegmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnalyticsSegments
     * const analyticsSegments = await prisma.analyticsSegment.findMany()
     * 
     * // Get first 10 AnalyticsSegments
     * const analyticsSegments = await prisma.analyticsSegment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analyticsSegmentWithIdOnly = await prisma.analyticsSegment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnalyticsSegmentFindManyArgs>(args?: SelectSubset<T, AnalyticsSegmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsSegmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AnalyticsSegment.
     * @param {AnalyticsSegmentCreateArgs} args - Arguments to create a AnalyticsSegment.
     * @example
     * // Create one AnalyticsSegment
     * const AnalyticsSegment = await prisma.analyticsSegment.create({
     *   data: {
     *     // ... data to create a AnalyticsSegment
     *   }
     * })
     * 
     */
    create<T extends AnalyticsSegmentCreateArgs>(args: SelectSubset<T, AnalyticsSegmentCreateArgs<ExtArgs>>): Prisma__AnalyticsSegmentClient<$Result.GetResult<Prisma.$AnalyticsSegmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AnalyticsSegments.
     * @param {AnalyticsSegmentCreateManyArgs} args - Arguments to create many AnalyticsSegments.
     * @example
     * // Create many AnalyticsSegments
     * const analyticsSegment = await prisma.analyticsSegment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnalyticsSegmentCreateManyArgs>(args?: SelectSubset<T, AnalyticsSegmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnalyticsSegments and returns the data saved in the database.
     * @param {AnalyticsSegmentCreateManyAndReturnArgs} args - Arguments to create many AnalyticsSegments.
     * @example
     * // Create many AnalyticsSegments
     * const analyticsSegment = await prisma.analyticsSegment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnalyticsSegments and only return the `id`
     * const analyticsSegmentWithIdOnly = await prisma.analyticsSegment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnalyticsSegmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AnalyticsSegmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsSegmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AnalyticsSegment.
     * @param {AnalyticsSegmentDeleteArgs} args - Arguments to delete one AnalyticsSegment.
     * @example
     * // Delete one AnalyticsSegment
     * const AnalyticsSegment = await prisma.analyticsSegment.delete({
     *   where: {
     *     // ... filter to delete one AnalyticsSegment
     *   }
     * })
     * 
     */
    delete<T extends AnalyticsSegmentDeleteArgs>(args: SelectSubset<T, AnalyticsSegmentDeleteArgs<ExtArgs>>): Prisma__AnalyticsSegmentClient<$Result.GetResult<Prisma.$AnalyticsSegmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AnalyticsSegment.
     * @param {AnalyticsSegmentUpdateArgs} args - Arguments to update one AnalyticsSegment.
     * @example
     * // Update one AnalyticsSegment
     * const analyticsSegment = await prisma.analyticsSegment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnalyticsSegmentUpdateArgs>(args: SelectSubset<T, AnalyticsSegmentUpdateArgs<ExtArgs>>): Prisma__AnalyticsSegmentClient<$Result.GetResult<Prisma.$AnalyticsSegmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AnalyticsSegments.
     * @param {AnalyticsSegmentDeleteManyArgs} args - Arguments to filter AnalyticsSegments to delete.
     * @example
     * // Delete a few AnalyticsSegments
     * const { count } = await prisma.analyticsSegment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnalyticsSegmentDeleteManyArgs>(args?: SelectSubset<T, AnalyticsSegmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalyticsSegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsSegmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnalyticsSegments
     * const analyticsSegment = await prisma.analyticsSegment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnalyticsSegmentUpdateManyArgs>(args: SelectSubset<T, AnalyticsSegmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalyticsSegments and returns the data updated in the database.
     * @param {AnalyticsSegmentUpdateManyAndReturnArgs} args - Arguments to update many AnalyticsSegments.
     * @example
     * // Update many AnalyticsSegments
     * const analyticsSegment = await prisma.analyticsSegment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AnalyticsSegments and only return the `id`
     * const analyticsSegmentWithIdOnly = await prisma.analyticsSegment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnalyticsSegmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AnalyticsSegmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsSegmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AnalyticsSegment.
     * @param {AnalyticsSegmentUpsertArgs} args - Arguments to update or create a AnalyticsSegment.
     * @example
     * // Update or create a AnalyticsSegment
     * const analyticsSegment = await prisma.analyticsSegment.upsert({
     *   create: {
     *     // ... data to create a AnalyticsSegment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnalyticsSegment we want to update
     *   }
     * })
     */
    upsert<T extends AnalyticsSegmentUpsertArgs>(args: SelectSubset<T, AnalyticsSegmentUpsertArgs<ExtArgs>>): Prisma__AnalyticsSegmentClient<$Result.GetResult<Prisma.$AnalyticsSegmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AnalyticsSegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsSegmentCountArgs} args - Arguments to filter AnalyticsSegments to count.
     * @example
     * // Count the number of AnalyticsSegments
     * const count = await prisma.analyticsSegment.count({
     *   where: {
     *     // ... the filter for the AnalyticsSegments we want to count
     *   }
     * })
    **/
    count<T extends AnalyticsSegmentCountArgs>(
      args?: Subset<T, AnalyticsSegmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalyticsSegmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnalyticsSegment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsSegmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalyticsSegmentAggregateArgs>(args: Subset<T, AnalyticsSegmentAggregateArgs>): Prisma.PrismaPromise<GetAnalyticsSegmentAggregateType<T>>

    /**
     * Group by AnalyticsSegment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsSegmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnalyticsSegmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnalyticsSegmentGroupByArgs['orderBy'] }
        : { orderBy?: AnalyticsSegmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnalyticsSegmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalyticsSegmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnalyticsSegment model
   */
  readonly fields: AnalyticsSegmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnalyticsSegment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnalyticsSegmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnalyticsSegment model
   */
  interface AnalyticsSegmentFieldRefs {
    readonly id: FieldRef<"AnalyticsSegment", 'String'>
    readonly name: FieldRef<"AnalyticsSegment", 'String'>
    readonly type: FieldRef<"AnalyticsSegment", 'String'>
    readonly conditions: FieldRef<"AnalyticsSegment", 'Json'>
    readonly userCount: FieldRef<"AnalyticsSegment", 'Int'>
    readonly avgEngagement: FieldRef<"AnalyticsSegment", 'Float'>
    readonly avgRevenue: FieldRef<"AnalyticsSegment", 'Float'>
    readonly conversionRate: FieldRef<"AnalyticsSegment", 'Float'>
    readonly lastUpdated: FieldRef<"AnalyticsSegment", 'DateTime'>
    readonly createdAt: FieldRef<"AnalyticsSegment", 'DateTime'>
    readonly updatedAt: FieldRef<"AnalyticsSegment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AnalyticsSegment findUnique
   */
  export type AnalyticsSegmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsSegment
     */
    select?: AnalyticsSegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsSegment
     */
    omit?: AnalyticsSegmentOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsSegment to fetch.
     */
    where: AnalyticsSegmentWhereUniqueInput
  }

  /**
   * AnalyticsSegment findUniqueOrThrow
   */
  export type AnalyticsSegmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsSegment
     */
    select?: AnalyticsSegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsSegment
     */
    omit?: AnalyticsSegmentOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsSegment to fetch.
     */
    where: AnalyticsSegmentWhereUniqueInput
  }

  /**
   * AnalyticsSegment findFirst
   */
  export type AnalyticsSegmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsSegment
     */
    select?: AnalyticsSegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsSegment
     */
    omit?: AnalyticsSegmentOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsSegment to fetch.
     */
    where?: AnalyticsSegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsSegments to fetch.
     */
    orderBy?: AnalyticsSegmentOrderByWithRelationInput | AnalyticsSegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsSegments.
     */
    cursor?: AnalyticsSegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsSegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsSegments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsSegments.
     */
    distinct?: AnalyticsSegmentScalarFieldEnum | AnalyticsSegmentScalarFieldEnum[]
  }

  /**
   * AnalyticsSegment findFirstOrThrow
   */
  export type AnalyticsSegmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsSegment
     */
    select?: AnalyticsSegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsSegment
     */
    omit?: AnalyticsSegmentOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsSegment to fetch.
     */
    where?: AnalyticsSegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsSegments to fetch.
     */
    orderBy?: AnalyticsSegmentOrderByWithRelationInput | AnalyticsSegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsSegments.
     */
    cursor?: AnalyticsSegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsSegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsSegments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsSegments.
     */
    distinct?: AnalyticsSegmentScalarFieldEnum | AnalyticsSegmentScalarFieldEnum[]
  }

  /**
   * AnalyticsSegment findMany
   */
  export type AnalyticsSegmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsSegment
     */
    select?: AnalyticsSegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsSegment
     */
    omit?: AnalyticsSegmentOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsSegments to fetch.
     */
    where?: AnalyticsSegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsSegments to fetch.
     */
    orderBy?: AnalyticsSegmentOrderByWithRelationInput | AnalyticsSegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnalyticsSegments.
     */
    cursor?: AnalyticsSegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsSegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsSegments.
     */
    skip?: number
    distinct?: AnalyticsSegmentScalarFieldEnum | AnalyticsSegmentScalarFieldEnum[]
  }

  /**
   * AnalyticsSegment create
   */
  export type AnalyticsSegmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsSegment
     */
    select?: AnalyticsSegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsSegment
     */
    omit?: AnalyticsSegmentOmit<ExtArgs> | null
    /**
     * The data needed to create a AnalyticsSegment.
     */
    data: XOR<AnalyticsSegmentCreateInput, AnalyticsSegmentUncheckedCreateInput>
  }

  /**
   * AnalyticsSegment createMany
   */
  export type AnalyticsSegmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnalyticsSegments.
     */
    data: AnalyticsSegmentCreateManyInput | AnalyticsSegmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnalyticsSegment createManyAndReturn
   */
  export type AnalyticsSegmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsSegment
     */
    select?: AnalyticsSegmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsSegment
     */
    omit?: AnalyticsSegmentOmit<ExtArgs> | null
    /**
     * The data used to create many AnalyticsSegments.
     */
    data: AnalyticsSegmentCreateManyInput | AnalyticsSegmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnalyticsSegment update
   */
  export type AnalyticsSegmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsSegment
     */
    select?: AnalyticsSegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsSegment
     */
    omit?: AnalyticsSegmentOmit<ExtArgs> | null
    /**
     * The data needed to update a AnalyticsSegment.
     */
    data: XOR<AnalyticsSegmentUpdateInput, AnalyticsSegmentUncheckedUpdateInput>
    /**
     * Choose, which AnalyticsSegment to update.
     */
    where: AnalyticsSegmentWhereUniqueInput
  }

  /**
   * AnalyticsSegment updateMany
   */
  export type AnalyticsSegmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnalyticsSegments.
     */
    data: XOR<AnalyticsSegmentUpdateManyMutationInput, AnalyticsSegmentUncheckedUpdateManyInput>
    /**
     * Filter which AnalyticsSegments to update
     */
    where?: AnalyticsSegmentWhereInput
    /**
     * Limit how many AnalyticsSegments to update.
     */
    limit?: number
  }

  /**
   * AnalyticsSegment updateManyAndReturn
   */
  export type AnalyticsSegmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsSegment
     */
    select?: AnalyticsSegmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsSegment
     */
    omit?: AnalyticsSegmentOmit<ExtArgs> | null
    /**
     * The data used to update AnalyticsSegments.
     */
    data: XOR<AnalyticsSegmentUpdateManyMutationInput, AnalyticsSegmentUncheckedUpdateManyInput>
    /**
     * Filter which AnalyticsSegments to update
     */
    where?: AnalyticsSegmentWhereInput
    /**
     * Limit how many AnalyticsSegments to update.
     */
    limit?: number
  }

  /**
   * AnalyticsSegment upsert
   */
  export type AnalyticsSegmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsSegment
     */
    select?: AnalyticsSegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsSegment
     */
    omit?: AnalyticsSegmentOmit<ExtArgs> | null
    /**
     * The filter to search for the AnalyticsSegment to update in case it exists.
     */
    where: AnalyticsSegmentWhereUniqueInput
    /**
     * In case the AnalyticsSegment found by the `where` argument doesn't exist, create a new AnalyticsSegment with this data.
     */
    create: XOR<AnalyticsSegmentCreateInput, AnalyticsSegmentUncheckedCreateInput>
    /**
     * In case the AnalyticsSegment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnalyticsSegmentUpdateInput, AnalyticsSegmentUncheckedUpdateInput>
  }

  /**
   * AnalyticsSegment delete
   */
  export type AnalyticsSegmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsSegment
     */
    select?: AnalyticsSegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsSegment
     */
    omit?: AnalyticsSegmentOmit<ExtArgs> | null
    /**
     * Filter which AnalyticsSegment to delete.
     */
    where: AnalyticsSegmentWhereUniqueInput
  }

  /**
   * AnalyticsSegment deleteMany
   */
  export type AnalyticsSegmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsSegments to delete
     */
    where?: AnalyticsSegmentWhereInput
    /**
     * Limit how many AnalyticsSegments to delete.
     */
    limit?: number
  }

  /**
   * AnalyticsSegment without action
   */
  export type AnalyticsSegmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsSegment
     */
    select?: AnalyticsSegmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsSegment
     */
    omit?: AnalyticsSegmentOmit<ExtArgs> | null
  }


  /**
   * Model AnalyticsReport
   */

  export type AggregateAnalyticsReport = {
    _count: AnalyticsReportCountAggregateOutputType | null
    _min: AnalyticsReportMinAggregateOutputType | null
    _max: AnalyticsReportMaxAggregateOutputType | null
  }

  export type AnalyticsReportMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    schedule: string | null
    lastRun: Date | null
    nextRun: Date | null
    format: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnalyticsReportMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    schedule: string | null
    lastRun: Date | null
    nextRun: Date | null
    format: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnalyticsReportCountAggregateOutputType = {
    id: number
    name: number
    type: number
    definition: number
    schedule: number
    lastRun: number
    nextRun: number
    recipients: number
    format: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AnalyticsReportMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    schedule?: true
    lastRun?: true
    nextRun?: true
    format?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnalyticsReportMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    schedule?: true
    lastRun?: true
    nextRun?: true
    format?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnalyticsReportCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    definition?: true
    schedule?: true
    lastRun?: true
    nextRun?: true
    recipients?: true
    format?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AnalyticsReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsReport to aggregate.
     */
    where?: AnalyticsReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsReports to fetch.
     */
    orderBy?: AnalyticsReportOrderByWithRelationInput | AnalyticsReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnalyticsReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnalyticsReports
    **/
    _count?: true | AnalyticsReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalyticsReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalyticsReportMaxAggregateInputType
  }

  export type GetAnalyticsReportAggregateType<T extends AnalyticsReportAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalyticsReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalyticsReport[P]>
      : GetScalarType<T[P], AggregateAnalyticsReport[P]>
  }




  export type AnalyticsReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticsReportWhereInput
    orderBy?: AnalyticsReportOrderByWithAggregationInput | AnalyticsReportOrderByWithAggregationInput[]
    by: AnalyticsReportScalarFieldEnum[] | AnalyticsReportScalarFieldEnum
    having?: AnalyticsReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalyticsReportCountAggregateInputType | true
    _min?: AnalyticsReportMinAggregateInputType
    _max?: AnalyticsReportMaxAggregateInputType
  }

  export type AnalyticsReportGroupByOutputType = {
    id: string
    name: string
    type: string
    definition: JsonValue
    schedule: string | null
    lastRun: Date | null
    nextRun: Date | null
    recipients: JsonValue | null
    format: string
    createdBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: AnalyticsReportCountAggregateOutputType | null
    _min: AnalyticsReportMinAggregateOutputType | null
    _max: AnalyticsReportMaxAggregateOutputType | null
  }

  type GetAnalyticsReportGroupByPayload<T extends AnalyticsReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnalyticsReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalyticsReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalyticsReportGroupByOutputType[P]>
            : GetScalarType<T[P], AnalyticsReportGroupByOutputType[P]>
        }
      >
    >


  export type AnalyticsReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    definition?: boolean
    schedule?: boolean
    lastRun?: boolean
    nextRun?: boolean
    recipients?: boolean
    format?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["analyticsReport"]>

  export type AnalyticsReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    definition?: boolean
    schedule?: boolean
    lastRun?: boolean
    nextRun?: boolean
    recipients?: boolean
    format?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["analyticsReport"]>

  export type AnalyticsReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    definition?: boolean
    schedule?: boolean
    lastRun?: boolean
    nextRun?: boolean
    recipients?: boolean
    format?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["analyticsReport"]>

  export type AnalyticsReportSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    definition?: boolean
    schedule?: boolean
    lastRun?: boolean
    nextRun?: boolean
    recipients?: boolean
    format?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AnalyticsReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "definition" | "schedule" | "lastRun" | "nextRun" | "recipients" | "format" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["analyticsReport"]>

  export type $AnalyticsReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnalyticsReport"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      definition: Prisma.JsonValue
      schedule: string | null
      lastRun: Date | null
      nextRun: Date | null
      recipients: Prisma.JsonValue | null
      format: string
      createdBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["analyticsReport"]>
    composites: {}
  }

  type AnalyticsReportGetPayload<S extends boolean | null | undefined | AnalyticsReportDefaultArgs> = $Result.GetResult<Prisma.$AnalyticsReportPayload, S>

  type AnalyticsReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnalyticsReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnalyticsReportCountAggregateInputType | true
    }

  export interface AnalyticsReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnalyticsReport'], meta: { name: 'AnalyticsReport' } }
    /**
     * Find zero or one AnalyticsReport that matches the filter.
     * @param {AnalyticsReportFindUniqueArgs} args - Arguments to find a AnalyticsReport
     * @example
     * // Get one AnalyticsReport
     * const analyticsReport = await prisma.analyticsReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnalyticsReportFindUniqueArgs>(args: SelectSubset<T, AnalyticsReportFindUniqueArgs<ExtArgs>>): Prisma__AnalyticsReportClient<$Result.GetResult<Prisma.$AnalyticsReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AnalyticsReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnalyticsReportFindUniqueOrThrowArgs} args - Arguments to find a AnalyticsReport
     * @example
     * // Get one AnalyticsReport
     * const analyticsReport = await prisma.analyticsReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnalyticsReportFindUniqueOrThrowArgs>(args: SelectSubset<T, AnalyticsReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnalyticsReportClient<$Result.GetResult<Prisma.$AnalyticsReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalyticsReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsReportFindFirstArgs} args - Arguments to find a AnalyticsReport
     * @example
     * // Get one AnalyticsReport
     * const analyticsReport = await prisma.analyticsReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnalyticsReportFindFirstArgs>(args?: SelectSubset<T, AnalyticsReportFindFirstArgs<ExtArgs>>): Prisma__AnalyticsReportClient<$Result.GetResult<Prisma.$AnalyticsReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalyticsReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsReportFindFirstOrThrowArgs} args - Arguments to find a AnalyticsReport
     * @example
     * // Get one AnalyticsReport
     * const analyticsReport = await prisma.analyticsReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnalyticsReportFindFirstOrThrowArgs>(args?: SelectSubset<T, AnalyticsReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnalyticsReportClient<$Result.GetResult<Prisma.$AnalyticsReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AnalyticsReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnalyticsReports
     * const analyticsReports = await prisma.analyticsReport.findMany()
     * 
     * // Get first 10 AnalyticsReports
     * const analyticsReports = await prisma.analyticsReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analyticsReportWithIdOnly = await prisma.analyticsReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnalyticsReportFindManyArgs>(args?: SelectSubset<T, AnalyticsReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AnalyticsReport.
     * @param {AnalyticsReportCreateArgs} args - Arguments to create a AnalyticsReport.
     * @example
     * // Create one AnalyticsReport
     * const AnalyticsReport = await prisma.analyticsReport.create({
     *   data: {
     *     // ... data to create a AnalyticsReport
     *   }
     * })
     * 
     */
    create<T extends AnalyticsReportCreateArgs>(args: SelectSubset<T, AnalyticsReportCreateArgs<ExtArgs>>): Prisma__AnalyticsReportClient<$Result.GetResult<Prisma.$AnalyticsReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AnalyticsReports.
     * @param {AnalyticsReportCreateManyArgs} args - Arguments to create many AnalyticsReports.
     * @example
     * // Create many AnalyticsReports
     * const analyticsReport = await prisma.analyticsReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnalyticsReportCreateManyArgs>(args?: SelectSubset<T, AnalyticsReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnalyticsReports and returns the data saved in the database.
     * @param {AnalyticsReportCreateManyAndReturnArgs} args - Arguments to create many AnalyticsReports.
     * @example
     * // Create many AnalyticsReports
     * const analyticsReport = await prisma.analyticsReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnalyticsReports and only return the `id`
     * const analyticsReportWithIdOnly = await prisma.analyticsReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnalyticsReportCreateManyAndReturnArgs>(args?: SelectSubset<T, AnalyticsReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AnalyticsReport.
     * @param {AnalyticsReportDeleteArgs} args - Arguments to delete one AnalyticsReport.
     * @example
     * // Delete one AnalyticsReport
     * const AnalyticsReport = await prisma.analyticsReport.delete({
     *   where: {
     *     // ... filter to delete one AnalyticsReport
     *   }
     * })
     * 
     */
    delete<T extends AnalyticsReportDeleteArgs>(args: SelectSubset<T, AnalyticsReportDeleteArgs<ExtArgs>>): Prisma__AnalyticsReportClient<$Result.GetResult<Prisma.$AnalyticsReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AnalyticsReport.
     * @param {AnalyticsReportUpdateArgs} args - Arguments to update one AnalyticsReport.
     * @example
     * // Update one AnalyticsReport
     * const analyticsReport = await prisma.analyticsReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnalyticsReportUpdateArgs>(args: SelectSubset<T, AnalyticsReportUpdateArgs<ExtArgs>>): Prisma__AnalyticsReportClient<$Result.GetResult<Prisma.$AnalyticsReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AnalyticsReports.
     * @param {AnalyticsReportDeleteManyArgs} args - Arguments to filter AnalyticsReports to delete.
     * @example
     * // Delete a few AnalyticsReports
     * const { count } = await prisma.analyticsReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnalyticsReportDeleteManyArgs>(args?: SelectSubset<T, AnalyticsReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalyticsReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnalyticsReports
     * const analyticsReport = await prisma.analyticsReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnalyticsReportUpdateManyArgs>(args: SelectSubset<T, AnalyticsReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalyticsReports and returns the data updated in the database.
     * @param {AnalyticsReportUpdateManyAndReturnArgs} args - Arguments to update many AnalyticsReports.
     * @example
     * // Update many AnalyticsReports
     * const analyticsReport = await prisma.analyticsReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AnalyticsReports and only return the `id`
     * const analyticsReportWithIdOnly = await prisma.analyticsReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnalyticsReportUpdateManyAndReturnArgs>(args: SelectSubset<T, AnalyticsReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AnalyticsReport.
     * @param {AnalyticsReportUpsertArgs} args - Arguments to update or create a AnalyticsReport.
     * @example
     * // Update or create a AnalyticsReport
     * const analyticsReport = await prisma.analyticsReport.upsert({
     *   create: {
     *     // ... data to create a AnalyticsReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnalyticsReport we want to update
     *   }
     * })
     */
    upsert<T extends AnalyticsReportUpsertArgs>(args: SelectSubset<T, AnalyticsReportUpsertArgs<ExtArgs>>): Prisma__AnalyticsReportClient<$Result.GetResult<Prisma.$AnalyticsReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AnalyticsReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsReportCountArgs} args - Arguments to filter AnalyticsReports to count.
     * @example
     * // Count the number of AnalyticsReports
     * const count = await prisma.analyticsReport.count({
     *   where: {
     *     // ... the filter for the AnalyticsReports we want to count
     *   }
     * })
    **/
    count<T extends AnalyticsReportCountArgs>(
      args?: Subset<T, AnalyticsReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalyticsReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnalyticsReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalyticsReportAggregateArgs>(args: Subset<T, AnalyticsReportAggregateArgs>): Prisma.PrismaPromise<GetAnalyticsReportAggregateType<T>>

    /**
     * Group by AnalyticsReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnalyticsReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnalyticsReportGroupByArgs['orderBy'] }
        : { orderBy?: AnalyticsReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnalyticsReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalyticsReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnalyticsReport model
   */
  readonly fields: AnalyticsReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnalyticsReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnalyticsReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnalyticsReport model
   */
  interface AnalyticsReportFieldRefs {
    readonly id: FieldRef<"AnalyticsReport", 'String'>
    readonly name: FieldRef<"AnalyticsReport", 'String'>
    readonly type: FieldRef<"AnalyticsReport", 'String'>
    readonly definition: FieldRef<"AnalyticsReport", 'Json'>
    readonly schedule: FieldRef<"AnalyticsReport", 'String'>
    readonly lastRun: FieldRef<"AnalyticsReport", 'DateTime'>
    readonly nextRun: FieldRef<"AnalyticsReport", 'DateTime'>
    readonly recipients: FieldRef<"AnalyticsReport", 'Json'>
    readonly format: FieldRef<"AnalyticsReport", 'String'>
    readonly createdBy: FieldRef<"AnalyticsReport", 'String'>
    readonly createdAt: FieldRef<"AnalyticsReport", 'DateTime'>
    readonly updatedAt: FieldRef<"AnalyticsReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AnalyticsReport findUnique
   */
  export type AnalyticsReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsReport
     */
    select?: AnalyticsReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsReport
     */
    omit?: AnalyticsReportOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsReport to fetch.
     */
    where: AnalyticsReportWhereUniqueInput
  }

  /**
   * AnalyticsReport findUniqueOrThrow
   */
  export type AnalyticsReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsReport
     */
    select?: AnalyticsReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsReport
     */
    omit?: AnalyticsReportOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsReport to fetch.
     */
    where: AnalyticsReportWhereUniqueInput
  }

  /**
   * AnalyticsReport findFirst
   */
  export type AnalyticsReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsReport
     */
    select?: AnalyticsReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsReport
     */
    omit?: AnalyticsReportOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsReport to fetch.
     */
    where?: AnalyticsReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsReports to fetch.
     */
    orderBy?: AnalyticsReportOrderByWithRelationInput | AnalyticsReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsReports.
     */
    cursor?: AnalyticsReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsReports.
     */
    distinct?: AnalyticsReportScalarFieldEnum | AnalyticsReportScalarFieldEnum[]
  }

  /**
   * AnalyticsReport findFirstOrThrow
   */
  export type AnalyticsReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsReport
     */
    select?: AnalyticsReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsReport
     */
    omit?: AnalyticsReportOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsReport to fetch.
     */
    where?: AnalyticsReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsReports to fetch.
     */
    orderBy?: AnalyticsReportOrderByWithRelationInput | AnalyticsReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsReports.
     */
    cursor?: AnalyticsReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsReports.
     */
    distinct?: AnalyticsReportScalarFieldEnum | AnalyticsReportScalarFieldEnum[]
  }

  /**
   * AnalyticsReport findMany
   */
  export type AnalyticsReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsReport
     */
    select?: AnalyticsReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsReport
     */
    omit?: AnalyticsReportOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsReports to fetch.
     */
    where?: AnalyticsReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsReports to fetch.
     */
    orderBy?: AnalyticsReportOrderByWithRelationInput | AnalyticsReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnalyticsReports.
     */
    cursor?: AnalyticsReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsReports.
     */
    skip?: number
    distinct?: AnalyticsReportScalarFieldEnum | AnalyticsReportScalarFieldEnum[]
  }

  /**
   * AnalyticsReport create
   */
  export type AnalyticsReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsReport
     */
    select?: AnalyticsReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsReport
     */
    omit?: AnalyticsReportOmit<ExtArgs> | null
    /**
     * The data needed to create a AnalyticsReport.
     */
    data: XOR<AnalyticsReportCreateInput, AnalyticsReportUncheckedCreateInput>
  }

  /**
   * AnalyticsReport createMany
   */
  export type AnalyticsReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnalyticsReports.
     */
    data: AnalyticsReportCreateManyInput | AnalyticsReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnalyticsReport createManyAndReturn
   */
  export type AnalyticsReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsReport
     */
    select?: AnalyticsReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsReport
     */
    omit?: AnalyticsReportOmit<ExtArgs> | null
    /**
     * The data used to create many AnalyticsReports.
     */
    data: AnalyticsReportCreateManyInput | AnalyticsReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnalyticsReport update
   */
  export type AnalyticsReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsReport
     */
    select?: AnalyticsReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsReport
     */
    omit?: AnalyticsReportOmit<ExtArgs> | null
    /**
     * The data needed to update a AnalyticsReport.
     */
    data: XOR<AnalyticsReportUpdateInput, AnalyticsReportUncheckedUpdateInput>
    /**
     * Choose, which AnalyticsReport to update.
     */
    where: AnalyticsReportWhereUniqueInput
  }

  /**
   * AnalyticsReport updateMany
   */
  export type AnalyticsReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnalyticsReports.
     */
    data: XOR<AnalyticsReportUpdateManyMutationInput, AnalyticsReportUncheckedUpdateManyInput>
    /**
     * Filter which AnalyticsReports to update
     */
    where?: AnalyticsReportWhereInput
    /**
     * Limit how many AnalyticsReports to update.
     */
    limit?: number
  }

  /**
   * AnalyticsReport updateManyAndReturn
   */
  export type AnalyticsReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsReport
     */
    select?: AnalyticsReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsReport
     */
    omit?: AnalyticsReportOmit<ExtArgs> | null
    /**
     * The data used to update AnalyticsReports.
     */
    data: XOR<AnalyticsReportUpdateManyMutationInput, AnalyticsReportUncheckedUpdateManyInput>
    /**
     * Filter which AnalyticsReports to update
     */
    where?: AnalyticsReportWhereInput
    /**
     * Limit how many AnalyticsReports to update.
     */
    limit?: number
  }

  /**
   * AnalyticsReport upsert
   */
  export type AnalyticsReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsReport
     */
    select?: AnalyticsReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsReport
     */
    omit?: AnalyticsReportOmit<ExtArgs> | null
    /**
     * The filter to search for the AnalyticsReport to update in case it exists.
     */
    where: AnalyticsReportWhereUniqueInput
    /**
     * In case the AnalyticsReport found by the `where` argument doesn't exist, create a new AnalyticsReport with this data.
     */
    create: XOR<AnalyticsReportCreateInput, AnalyticsReportUncheckedCreateInput>
    /**
     * In case the AnalyticsReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnalyticsReportUpdateInput, AnalyticsReportUncheckedUpdateInput>
  }

  /**
   * AnalyticsReport delete
   */
  export type AnalyticsReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsReport
     */
    select?: AnalyticsReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsReport
     */
    omit?: AnalyticsReportOmit<ExtArgs> | null
    /**
     * Filter which AnalyticsReport to delete.
     */
    where: AnalyticsReportWhereUniqueInput
  }

  /**
   * AnalyticsReport deleteMany
   */
  export type AnalyticsReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsReports to delete
     */
    where?: AnalyticsReportWhereInput
    /**
     * Limit how many AnalyticsReports to delete.
     */
    limit?: number
  }

  /**
   * AnalyticsReport without action
   */
  export type AnalyticsReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsReport
     */
    select?: AnalyticsReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsReport
     */
    omit?: AnalyticsReportOmit<ExtArgs> | null
  }


  /**
   * Model QuizSession
   */

  export type AggregateQuizSession = {
    _count: QuizSessionCountAggregateOutputType | null
    _avg: QuizSessionAvgAggregateOutputType | null
    _sum: QuizSessionSumAggregateOutputType | null
    _min: QuizSessionMinAggregateOutputType | null
    _max: QuizSessionMaxAggregateOutputType | null
  }

  export type QuizSessionAvgAggregateOutputType = {
    completionRate: number | null
    crewSize: number | null
    leadQualityScore: number | null
  }

  export type QuizSessionSumAggregateOutputType = {
    completionRate: number | null
    crewSize: number | null
    leadQualityScore: number | null
  }

  export type QuizSessionMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    quizId: string | null
    source: string | null
    utmSource: string | null
    utmMedium: string | null
    utmCampaign: string | null
    utmContent: string | null
    contentId: string | null
    campaignId: string | null
    landingPage: string | null
    ipAddress: string | null
    userAgent: string | null
    status: string | null
    createdAt: Date | null
    startTime: Date | null
    endTime: Date | null
    completionRate: number | null
    userName: string | null
    email: string | null
    phoneNumber: string | null
    companyName: string | null
    userType: string | null
    selectedBrand: string | null
    userSegment: string | null
    crewSize: number | null
    leadQualityScore: number | null
    version: string | null
  }

  export type QuizSessionMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    quizId: string | null
    source: string | null
    utmSource: string | null
    utmMedium: string | null
    utmCampaign: string | null
    utmContent: string | null
    contentId: string | null
    campaignId: string | null
    landingPage: string | null
    ipAddress: string | null
    userAgent: string | null
    status: string | null
    createdAt: Date | null
    startTime: Date | null
    endTime: Date | null
    completionRate: number | null
    userName: string | null
    email: string | null
    phoneNumber: string | null
    companyName: string | null
    userType: string | null
    selectedBrand: string | null
    userSegment: string | null
    crewSize: number | null
    leadQualityScore: number | null
    version: string | null
  }

  export type QuizSessionCountAggregateOutputType = {
    id: number
    sessionId: number
    quizId: number
    source: number
    utmSource: number
    utmMedium: number
    utmCampaign: number
    utmContent: number
    contentId: number
    campaignId: number
    deviceInfo: number
    landingPage: number
    ipAddress: number
    userAgent: number
    status: number
    createdAt: number
    startTime: number
    endTime: number
    completionRate: number
    userName: number
    email: number
    phoneNumber: number
    companyName: number
    userType: number
    selectedBrand: number
    userSegment: number
    crewSize: number
    leadQualityScore: number
    version: number
    _all: number
  }


  export type QuizSessionAvgAggregateInputType = {
    completionRate?: true
    crewSize?: true
    leadQualityScore?: true
  }

  export type QuizSessionSumAggregateInputType = {
    completionRate?: true
    crewSize?: true
    leadQualityScore?: true
  }

  export type QuizSessionMinAggregateInputType = {
    id?: true
    sessionId?: true
    quizId?: true
    source?: true
    utmSource?: true
    utmMedium?: true
    utmCampaign?: true
    utmContent?: true
    contentId?: true
    campaignId?: true
    landingPage?: true
    ipAddress?: true
    userAgent?: true
    status?: true
    createdAt?: true
    startTime?: true
    endTime?: true
    completionRate?: true
    userName?: true
    email?: true
    phoneNumber?: true
    companyName?: true
    userType?: true
    selectedBrand?: true
    userSegment?: true
    crewSize?: true
    leadQualityScore?: true
    version?: true
  }

  export type QuizSessionMaxAggregateInputType = {
    id?: true
    sessionId?: true
    quizId?: true
    source?: true
    utmSource?: true
    utmMedium?: true
    utmCampaign?: true
    utmContent?: true
    contentId?: true
    campaignId?: true
    landingPage?: true
    ipAddress?: true
    userAgent?: true
    status?: true
    createdAt?: true
    startTime?: true
    endTime?: true
    completionRate?: true
    userName?: true
    email?: true
    phoneNumber?: true
    companyName?: true
    userType?: true
    selectedBrand?: true
    userSegment?: true
    crewSize?: true
    leadQualityScore?: true
    version?: true
  }

  export type QuizSessionCountAggregateInputType = {
    id?: true
    sessionId?: true
    quizId?: true
    source?: true
    utmSource?: true
    utmMedium?: true
    utmCampaign?: true
    utmContent?: true
    contentId?: true
    campaignId?: true
    deviceInfo?: true
    landingPage?: true
    ipAddress?: true
    userAgent?: true
    status?: true
    createdAt?: true
    startTime?: true
    endTime?: true
    completionRate?: true
    userName?: true
    email?: true
    phoneNumber?: true
    companyName?: true
    userType?: true
    selectedBrand?: true
    userSegment?: true
    crewSize?: true
    leadQualityScore?: true
    version?: true
    _all?: true
  }

  export type QuizSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizSession to aggregate.
     */
    where?: QuizSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizSessions to fetch.
     */
    orderBy?: QuizSessionOrderByWithRelationInput | QuizSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizSessions
    **/
    _count?: true | QuizSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizSessionMaxAggregateInputType
  }

  export type GetQuizSessionAggregateType<T extends QuizSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizSession[P]>
      : GetScalarType<T[P], AggregateQuizSession[P]>
  }




  export type QuizSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizSessionWhereInput
    orderBy?: QuizSessionOrderByWithAggregationInput | QuizSessionOrderByWithAggregationInput[]
    by: QuizSessionScalarFieldEnum[] | QuizSessionScalarFieldEnum
    having?: QuizSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizSessionCountAggregateInputType | true
    _avg?: QuizSessionAvgAggregateInputType
    _sum?: QuizSessionSumAggregateInputType
    _min?: QuizSessionMinAggregateInputType
    _max?: QuizSessionMaxAggregateInputType
  }

  export type QuizSessionGroupByOutputType = {
    id: string
    sessionId: string
    quizId: string
    source: string | null
    utmSource: string | null
    utmMedium: string | null
    utmCampaign: string | null
    utmContent: string | null
    contentId: string | null
    campaignId: string | null
    deviceInfo: JsonValue | null
    landingPage: string | null
    ipAddress: string | null
    userAgent: string | null
    status: string
    createdAt: Date
    startTime: Date
    endTime: Date | null
    completionRate: number | null
    userName: string | null
    email: string | null
    phoneNumber: string | null
    companyName: string | null
    userType: string | null
    selectedBrand: string | null
    userSegment: string | null
    crewSize: number | null
    leadQualityScore: number | null
    version: string | null
    _count: QuizSessionCountAggregateOutputType | null
    _avg: QuizSessionAvgAggregateOutputType | null
    _sum: QuizSessionSumAggregateOutputType | null
    _min: QuizSessionMinAggregateOutputType | null
    _max: QuizSessionMaxAggregateOutputType | null
  }

  type GetQuizSessionGroupByPayload<T extends QuizSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizSessionGroupByOutputType[P]>
            : GetScalarType<T[P], QuizSessionGroupByOutputType[P]>
        }
      >
    >


  export type QuizSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    quizId?: boolean
    source?: boolean
    utmSource?: boolean
    utmMedium?: boolean
    utmCampaign?: boolean
    utmContent?: boolean
    contentId?: boolean
    campaignId?: boolean
    deviceInfo?: boolean
    landingPage?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    status?: boolean
    createdAt?: boolean
    startTime?: boolean
    endTime?: boolean
    completionRate?: boolean
    userName?: boolean
    email?: boolean
    phoneNumber?: boolean
    companyName?: boolean
    userType?: boolean
    selectedBrand?: boolean
    userSegment?: boolean
    crewSize?: boolean
    leadQualityScore?: boolean
    version?: boolean
    responses?: boolean | QuizSession$responsesArgs<ExtArgs>
    interactions?: boolean | QuizSession$interactionsArgs<ExtArgs>
    conversions?: boolean | QuizSession$conversionsArgs<ExtArgs>
    _count?: boolean | QuizSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizSession"]>

  export type QuizSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    quizId?: boolean
    source?: boolean
    utmSource?: boolean
    utmMedium?: boolean
    utmCampaign?: boolean
    utmContent?: boolean
    contentId?: boolean
    campaignId?: boolean
    deviceInfo?: boolean
    landingPage?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    status?: boolean
    createdAt?: boolean
    startTime?: boolean
    endTime?: boolean
    completionRate?: boolean
    userName?: boolean
    email?: boolean
    phoneNumber?: boolean
    companyName?: boolean
    userType?: boolean
    selectedBrand?: boolean
    userSegment?: boolean
    crewSize?: boolean
    leadQualityScore?: boolean
    version?: boolean
  }, ExtArgs["result"]["quizSession"]>

  export type QuizSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    quizId?: boolean
    source?: boolean
    utmSource?: boolean
    utmMedium?: boolean
    utmCampaign?: boolean
    utmContent?: boolean
    contentId?: boolean
    campaignId?: boolean
    deviceInfo?: boolean
    landingPage?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    status?: boolean
    createdAt?: boolean
    startTime?: boolean
    endTime?: boolean
    completionRate?: boolean
    userName?: boolean
    email?: boolean
    phoneNumber?: boolean
    companyName?: boolean
    userType?: boolean
    selectedBrand?: boolean
    userSegment?: boolean
    crewSize?: boolean
    leadQualityScore?: boolean
    version?: boolean
  }, ExtArgs["result"]["quizSession"]>

  export type QuizSessionSelectScalar = {
    id?: boolean
    sessionId?: boolean
    quizId?: boolean
    source?: boolean
    utmSource?: boolean
    utmMedium?: boolean
    utmCampaign?: boolean
    utmContent?: boolean
    contentId?: boolean
    campaignId?: boolean
    deviceInfo?: boolean
    landingPage?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    status?: boolean
    createdAt?: boolean
    startTime?: boolean
    endTime?: boolean
    completionRate?: boolean
    userName?: boolean
    email?: boolean
    phoneNumber?: boolean
    companyName?: boolean
    userType?: boolean
    selectedBrand?: boolean
    userSegment?: boolean
    crewSize?: boolean
    leadQualityScore?: boolean
    version?: boolean
  }

  export type QuizSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "quizId" | "source" | "utmSource" | "utmMedium" | "utmCampaign" | "utmContent" | "contentId" | "campaignId" | "deviceInfo" | "landingPage" | "ipAddress" | "userAgent" | "status" | "createdAt" | "startTime" | "endTime" | "completionRate" | "userName" | "email" | "phoneNumber" | "companyName" | "userType" | "selectedBrand" | "userSegment" | "crewSize" | "leadQualityScore" | "version", ExtArgs["result"]["quizSession"]>
  export type QuizSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responses?: boolean | QuizSession$responsesArgs<ExtArgs>
    interactions?: boolean | QuizSession$interactionsArgs<ExtArgs>
    conversions?: boolean | QuizSession$conversionsArgs<ExtArgs>
    _count?: boolean | QuizSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuizSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type QuizSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $QuizSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizSession"
    objects: {
      responses: Prisma.$QuizResponsePayload<ExtArgs>[]
      interactions: Prisma.$BehavioralInteractionPayload<ExtArgs>[]
      conversions: Prisma.$QuizConversionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      quizId: string
      source: string | null
      utmSource: string | null
      utmMedium: string | null
      utmCampaign: string | null
      utmContent: string | null
      contentId: string | null
      campaignId: string | null
      deviceInfo: Prisma.JsonValue | null
      landingPage: string | null
      ipAddress: string | null
      userAgent: string | null
      status: string
      createdAt: Date
      startTime: Date
      endTime: Date | null
      completionRate: number | null
      userName: string | null
      email: string | null
      phoneNumber: string | null
      companyName: string | null
      userType: string | null
      selectedBrand: string | null
      userSegment: string | null
      crewSize: number | null
      leadQualityScore: number | null
      version: string | null
    }, ExtArgs["result"]["quizSession"]>
    composites: {}
  }

  type QuizSessionGetPayload<S extends boolean | null | undefined | QuizSessionDefaultArgs> = $Result.GetResult<Prisma.$QuizSessionPayload, S>

  type QuizSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizSessionCountAggregateInputType | true
    }

  export interface QuizSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizSession'], meta: { name: 'QuizSession' } }
    /**
     * Find zero or one QuizSession that matches the filter.
     * @param {QuizSessionFindUniqueArgs} args - Arguments to find a QuizSession
     * @example
     * // Get one QuizSession
     * const quizSession = await prisma.quizSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizSessionFindUniqueArgs>(args: SelectSubset<T, QuizSessionFindUniqueArgs<ExtArgs>>): Prisma__QuizSessionClient<$Result.GetResult<Prisma.$QuizSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuizSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizSessionFindUniqueOrThrowArgs} args - Arguments to find a QuizSession
     * @example
     * // Get one QuizSession
     * const quizSession = await prisma.quizSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizSessionClient<$Result.GetResult<Prisma.$QuizSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizSessionFindFirstArgs} args - Arguments to find a QuizSession
     * @example
     * // Get one QuizSession
     * const quizSession = await prisma.quizSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizSessionFindFirstArgs>(args?: SelectSubset<T, QuizSessionFindFirstArgs<ExtArgs>>): Prisma__QuizSessionClient<$Result.GetResult<Prisma.$QuizSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizSessionFindFirstOrThrowArgs} args - Arguments to find a QuizSession
     * @example
     * // Get one QuizSession
     * const quizSession = await prisma.quizSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizSessionClient<$Result.GetResult<Prisma.$QuizSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuizSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizSessions
     * const quizSessions = await prisma.quizSession.findMany()
     * 
     * // Get first 10 QuizSessions
     * const quizSessions = await prisma.quizSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizSessionWithIdOnly = await prisma.quizSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizSessionFindManyArgs>(args?: SelectSubset<T, QuizSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuizSession.
     * @param {QuizSessionCreateArgs} args - Arguments to create a QuizSession.
     * @example
     * // Create one QuizSession
     * const QuizSession = await prisma.quizSession.create({
     *   data: {
     *     // ... data to create a QuizSession
     *   }
     * })
     * 
     */
    create<T extends QuizSessionCreateArgs>(args: SelectSubset<T, QuizSessionCreateArgs<ExtArgs>>): Prisma__QuizSessionClient<$Result.GetResult<Prisma.$QuizSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuizSessions.
     * @param {QuizSessionCreateManyArgs} args - Arguments to create many QuizSessions.
     * @example
     * // Create many QuizSessions
     * const quizSession = await prisma.quizSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizSessionCreateManyArgs>(args?: SelectSubset<T, QuizSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuizSessions and returns the data saved in the database.
     * @param {QuizSessionCreateManyAndReturnArgs} args - Arguments to create many QuizSessions.
     * @example
     * // Create many QuizSessions
     * const quizSession = await prisma.quizSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuizSessions and only return the `id`
     * const quizSessionWithIdOnly = await prisma.quizSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuizSession.
     * @param {QuizSessionDeleteArgs} args - Arguments to delete one QuizSession.
     * @example
     * // Delete one QuizSession
     * const QuizSession = await prisma.quizSession.delete({
     *   where: {
     *     // ... filter to delete one QuizSession
     *   }
     * })
     * 
     */
    delete<T extends QuizSessionDeleteArgs>(args: SelectSubset<T, QuizSessionDeleteArgs<ExtArgs>>): Prisma__QuizSessionClient<$Result.GetResult<Prisma.$QuizSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuizSession.
     * @param {QuizSessionUpdateArgs} args - Arguments to update one QuizSession.
     * @example
     * // Update one QuizSession
     * const quizSession = await prisma.quizSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizSessionUpdateArgs>(args: SelectSubset<T, QuizSessionUpdateArgs<ExtArgs>>): Prisma__QuizSessionClient<$Result.GetResult<Prisma.$QuizSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuizSessions.
     * @param {QuizSessionDeleteManyArgs} args - Arguments to filter QuizSessions to delete.
     * @example
     * // Delete a few QuizSessions
     * const { count } = await prisma.quizSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizSessionDeleteManyArgs>(args?: SelectSubset<T, QuizSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizSessions
     * const quizSession = await prisma.quizSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizSessionUpdateManyArgs>(args: SelectSubset<T, QuizSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizSessions and returns the data updated in the database.
     * @param {QuizSessionUpdateManyAndReturnArgs} args - Arguments to update many QuizSessions.
     * @example
     * // Update many QuizSessions
     * const quizSession = await prisma.quizSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuizSessions and only return the `id`
     * const quizSessionWithIdOnly = await prisma.quizSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuizSession.
     * @param {QuizSessionUpsertArgs} args - Arguments to update or create a QuizSession.
     * @example
     * // Update or create a QuizSession
     * const quizSession = await prisma.quizSession.upsert({
     *   create: {
     *     // ... data to create a QuizSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizSession we want to update
     *   }
     * })
     */
    upsert<T extends QuizSessionUpsertArgs>(args: SelectSubset<T, QuizSessionUpsertArgs<ExtArgs>>): Prisma__QuizSessionClient<$Result.GetResult<Prisma.$QuizSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuizSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizSessionCountArgs} args - Arguments to filter QuizSessions to count.
     * @example
     * // Count the number of QuizSessions
     * const count = await prisma.quizSession.count({
     *   where: {
     *     // ... the filter for the QuizSessions we want to count
     *   }
     * })
    **/
    count<T extends QuizSessionCountArgs>(
      args?: Subset<T, QuizSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizSessionAggregateArgs>(args: Subset<T, QuizSessionAggregateArgs>): Prisma.PrismaPromise<GetQuizSessionAggregateType<T>>

    /**
     * Group by QuizSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizSessionGroupByArgs['orderBy'] }
        : { orderBy?: QuizSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizSession model
   */
  readonly fields: QuizSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    responses<T extends QuizSession$responsesArgs<ExtArgs> = {}>(args?: Subset<T, QuizSession$responsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    interactions<T extends QuizSession$interactionsArgs<ExtArgs> = {}>(args?: Subset<T, QuizSession$interactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BehavioralInteractionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conversions<T extends QuizSession$conversionsArgs<ExtArgs> = {}>(args?: Subset<T, QuizSession$conversionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizConversionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizSession model
   */
  interface QuizSessionFieldRefs {
    readonly id: FieldRef<"QuizSession", 'String'>
    readonly sessionId: FieldRef<"QuizSession", 'String'>
    readonly quizId: FieldRef<"QuizSession", 'String'>
    readonly source: FieldRef<"QuizSession", 'String'>
    readonly utmSource: FieldRef<"QuizSession", 'String'>
    readonly utmMedium: FieldRef<"QuizSession", 'String'>
    readonly utmCampaign: FieldRef<"QuizSession", 'String'>
    readonly utmContent: FieldRef<"QuizSession", 'String'>
    readonly contentId: FieldRef<"QuizSession", 'String'>
    readonly campaignId: FieldRef<"QuizSession", 'String'>
    readonly deviceInfo: FieldRef<"QuizSession", 'Json'>
    readonly landingPage: FieldRef<"QuizSession", 'String'>
    readonly ipAddress: FieldRef<"QuizSession", 'String'>
    readonly userAgent: FieldRef<"QuizSession", 'String'>
    readonly status: FieldRef<"QuizSession", 'String'>
    readonly createdAt: FieldRef<"QuizSession", 'DateTime'>
    readonly startTime: FieldRef<"QuizSession", 'DateTime'>
    readonly endTime: FieldRef<"QuizSession", 'DateTime'>
    readonly completionRate: FieldRef<"QuizSession", 'Float'>
    readonly userName: FieldRef<"QuizSession", 'String'>
    readonly email: FieldRef<"QuizSession", 'String'>
    readonly phoneNumber: FieldRef<"QuizSession", 'String'>
    readonly companyName: FieldRef<"QuizSession", 'String'>
    readonly userType: FieldRef<"QuizSession", 'String'>
    readonly selectedBrand: FieldRef<"QuizSession", 'String'>
    readonly userSegment: FieldRef<"QuizSession", 'String'>
    readonly crewSize: FieldRef<"QuizSession", 'Int'>
    readonly leadQualityScore: FieldRef<"QuizSession", 'Float'>
    readonly version: FieldRef<"QuizSession", 'String'>
  }
    

  // Custom InputTypes
  /**
   * QuizSession findUnique
   */
  export type QuizSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSession
     */
    select?: QuizSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSession
     */
    omit?: QuizSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSessionInclude<ExtArgs> | null
    /**
     * Filter, which QuizSession to fetch.
     */
    where: QuizSessionWhereUniqueInput
  }

  /**
   * QuizSession findUniqueOrThrow
   */
  export type QuizSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSession
     */
    select?: QuizSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSession
     */
    omit?: QuizSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSessionInclude<ExtArgs> | null
    /**
     * Filter, which QuizSession to fetch.
     */
    where: QuizSessionWhereUniqueInput
  }

  /**
   * QuizSession findFirst
   */
  export type QuizSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSession
     */
    select?: QuizSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSession
     */
    omit?: QuizSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSessionInclude<ExtArgs> | null
    /**
     * Filter, which QuizSession to fetch.
     */
    where?: QuizSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizSessions to fetch.
     */
    orderBy?: QuizSessionOrderByWithRelationInput | QuizSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizSessions.
     */
    cursor?: QuizSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizSessions.
     */
    distinct?: QuizSessionScalarFieldEnum | QuizSessionScalarFieldEnum[]
  }

  /**
   * QuizSession findFirstOrThrow
   */
  export type QuizSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSession
     */
    select?: QuizSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSession
     */
    omit?: QuizSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSessionInclude<ExtArgs> | null
    /**
     * Filter, which QuizSession to fetch.
     */
    where?: QuizSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizSessions to fetch.
     */
    orderBy?: QuizSessionOrderByWithRelationInput | QuizSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizSessions.
     */
    cursor?: QuizSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizSessions.
     */
    distinct?: QuizSessionScalarFieldEnum | QuizSessionScalarFieldEnum[]
  }

  /**
   * QuizSession findMany
   */
  export type QuizSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSession
     */
    select?: QuizSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSession
     */
    omit?: QuizSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSessionInclude<ExtArgs> | null
    /**
     * Filter, which QuizSessions to fetch.
     */
    where?: QuizSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizSessions to fetch.
     */
    orderBy?: QuizSessionOrderByWithRelationInput | QuizSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizSessions.
     */
    cursor?: QuizSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizSessions.
     */
    skip?: number
    distinct?: QuizSessionScalarFieldEnum | QuizSessionScalarFieldEnum[]
  }

  /**
   * QuizSession create
   */
  export type QuizSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSession
     */
    select?: QuizSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSession
     */
    omit?: QuizSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a QuizSession.
     */
    data: XOR<QuizSessionCreateInput, QuizSessionUncheckedCreateInput>
  }

  /**
   * QuizSession createMany
   */
  export type QuizSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizSessions.
     */
    data: QuizSessionCreateManyInput | QuizSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizSession createManyAndReturn
   */
  export type QuizSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSession
     */
    select?: QuizSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSession
     */
    omit?: QuizSessionOmit<ExtArgs> | null
    /**
     * The data used to create many QuizSessions.
     */
    data: QuizSessionCreateManyInput | QuizSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizSession update
   */
  export type QuizSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSession
     */
    select?: QuizSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSession
     */
    omit?: QuizSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a QuizSession.
     */
    data: XOR<QuizSessionUpdateInput, QuizSessionUncheckedUpdateInput>
    /**
     * Choose, which QuizSession to update.
     */
    where: QuizSessionWhereUniqueInput
  }

  /**
   * QuizSession updateMany
   */
  export type QuizSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizSessions.
     */
    data: XOR<QuizSessionUpdateManyMutationInput, QuizSessionUncheckedUpdateManyInput>
    /**
     * Filter which QuizSessions to update
     */
    where?: QuizSessionWhereInput
    /**
     * Limit how many QuizSessions to update.
     */
    limit?: number
  }

  /**
   * QuizSession updateManyAndReturn
   */
  export type QuizSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSession
     */
    select?: QuizSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSession
     */
    omit?: QuizSessionOmit<ExtArgs> | null
    /**
     * The data used to update QuizSessions.
     */
    data: XOR<QuizSessionUpdateManyMutationInput, QuizSessionUncheckedUpdateManyInput>
    /**
     * Filter which QuizSessions to update
     */
    where?: QuizSessionWhereInput
    /**
     * Limit how many QuizSessions to update.
     */
    limit?: number
  }

  /**
   * QuizSession upsert
   */
  export type QuizSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSession
     */
    select?: QuizSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSession
     */
    omit?: QuizSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the QuizSession to update in case it exists.
     */
    where: QuizSessionWhereUniqueInput
    /**
     * In case the QuizSession found by the `where` argument doesn't exist, create a new QuizSession with this data.
     */
    create: XOR<QuizSessionCreateInput, QuizSessionUncheckedCreateInput>
    /**
     * In case the QuizSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizSessionUpdateInput, QuizSessionUncheckedUpdateInput>
  }

  /**
   * QuizSession delete
   */
  export type QuizSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSession
     */
    select?: QuizSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSession
     */
    omit?: QuizSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSessionInclude<ExtArgs> | null
    /**
     * Filter which QuizSession to delete.
     */
    where: QuizSessionWhereUniqueInput
  }

  /**
   * QuizSession deleteMany
   */
  export type QuizSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizSessions to delete
     */
    where?: QuizSessionWhereInput
    /**
     * Limit how many QuizSessions to delete.
     */
    limit?: number
  }

  /**
   * QuizSession.responses
   */
  export type QuizSession$responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResponse
     */
    select?: QuizResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResponse
     */
    omit?: QuizResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizResponseInclude<ExtArgs> | null
    where?: QuizResponseWhereInput
    orderBy?: QuizResponseOrderByWithRelationInput | QuizResponseOrderByWithRelationInput[]
    cursor?: QuizResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizResponseScalarFieldEnum | QuizResponseScalarFieldEnum[]
  }

  /**
   * QuizSession.interactions
   */
  export type QuizSession$interactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralInteraction
     */
    select?: BehavioralInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BehavioralInteraction
     */
    omit?: BehavioralInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehavioralInteractionInclude<ExtArgs> | null
    where?: BehavioralInteractionWhereInput
    orderBy?: BehavioralInteractionOrderByWithRelationInput | BehavioralInteractionOrderByWithRelationInput[]
    cursor?: BehavioralInteractionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BehavioralInteractionScalarFieldEnum | BehavioralInteractionScalarFieldEnum[]
  }

  /**
   * QuizSession.conversions
   */
  export type QuizSession$conversionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizConversion
     */
    select?: QuizConversionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizConversion
     */
    omit?: QuizConversionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizConversionInclude<ExtArgs> | null
    where?: QuizConversionWhereInput
    orderBy?: QuizConversionOrderByWithRelationInput | QuizConversionOrderByWithRelationInput[]
    cursor?: QuizConversionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizConversionScalarFieldEnum | QuizConversionScalarFieldEnum[]
  }

  /**
   * QuizSession without action
   */
  export type QuizSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSession
     */
    select?: QuizSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSession
     */
    omit?: QuizSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSessionInclude<ExtArgs> | null
  }


  /**
   * Model QuizResponse
   */

  export type AggregateQuizResponse = {
    _count: QuizResponseCountAggregateOutputType | null
    _avg: QuizResponseAvgAggregateOutputType | null
    _sum: QuizResponseSumAggregateOutputType | null
    _min: QuizResponseMinAggregateOutputType | null
    _max: QuizResponseMaxAggregateOutputType | null
  }

  export type QuizResponseAvgAggregateOutputType = {
    responseTime: number | null
  }

  export type QuizResponseSumAggregateOutputType = {
    responseTime: number | null
  }

  export type QuizResponseMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    questionId: string | null
    questionType: string | null
    responseTime: number | null
    createdAt: Date | null
  }

  export type QuizResponseMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    questionId: string | null
    questionType: string | null
    responseTime: number | null
    createdAt: Date | null
  }

  export type QuizResponseCountAggregateOutputType = {
    id: number
    sessionId: number
    questionId: number
    questionType: number
    responseValue: number
    responseTime: number
    createdAt: number
    _all: number
  }


  export type QuizResponseAvgAggregateInputType = {
    responseTime?: true
  }

  export type QuizResponseSumAggregateInputType = {
    responseTime?: true
  }

  export type QuizResponseMinAggregateInputType = {
    id?: true
    sessionId?: true
    questionId?: true
    questionType?: true
    responseTime?: true
    createdAt?: true
  }

  export type QuizResponseMaxAggregateInputType = {
    id?: true
    sessionId?: true
    questionId?: true
    questionType?: true
    responseTime?: true
    createdAt?: true
  }

  export type QuizResponseCountAggregateInputType = {
    id?: true
    sessionId?: true
    questionId?: true
    questionType?: true
    responseValue?: true
    responseTime?: true
    createdAt?: true
    _all?: true
  }

  export type QuizResponseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizResponse to aggregate.
     */
    where?: QuizResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizResponses to fetch.
     */
    orderBy?: QuizResponseOrderByWithRelationInput | QuizResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizResponses
    **/
    _count?: true | QuizResponseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizResponseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizResponseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizResponseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizResponseMaxAggregateInputType
  }

  export type GetQuizResponseAggregateType<T extends QuizResponseAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizResponse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizResponse[P]>
      : GetScalarType<T[P], AggregateQuizResponse[P]>
  }




  export type QuizResponseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizResponseWhereInput
    orderBy?: QuizResponseOrderByWithAggregationInput | QuizResponseOrderByWithAggregationInput[]
    by: QuizResponseScalarFieldEnum[] | QuizResponseScalarFieldEnum
    having?: QuizResponseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizResponseCountAggregateInputType | true
    _avg?: QuizResponseAvgAggregateInputType
    _sum?: QuizResponseSumAggregateInputType
    _min?: QuizResponseMinAggregateInputType
    _max?: QuizResponseMaxAggregateInputType
  }

  export type QuizResponseGroupByOutputType = {
    id: string
    sessionId: string
    questionId: string
    questionType: string
    responseValue: JsonValue
    responseTime: number | null
    createdAt: Date
    _count: QuizResponseCountAggregateOutputType | null
    _avg: QuizResponseAvgAggregateOutputType | null
    _sum: QuizResponseSumAggregateOutputType | null
    _min: QuizResponseMinAggregateOutputType | null
    _max: QuizResponseMaxAggregateOutputType | null
  }

  type GetQuizResponseGroupByPayload<T extends QuizResponseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizResponseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizResponseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizResponseGroupByOutputType[P]>
            : GetScalarType<T[P], QuizResponseGroupByOutputType[P]>
        }
      >
    >


  export type QuizResponseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    questionId?: boolean
    questionType?: boolean
    responseValue?: boolean
    responseTime?: boolean
    createdAt?: boolean
    session?: boolean | QuizSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizResponse"]>

  export type QuizResponseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    questionId?: boolean
    questionType?: boolean
    responseValue?: boolean
    responseTime?: boolean
    createdAt?: boolean
    session?: boolean | QuizSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizResponse"]>

  export type QuizResponseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    questionId?: boolean
    questionType?: boolean
    responseValue?: boolean
    responseTime?: boolean
    createdAt?: boolean
    session?: boolean | QuizSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizResponse"]>

  export type QuizResponseSelectScalar = {
    id?: boolean
    sessionId?: boolean
    questionId?: boolean
    questionType?: boolean
    responseValue?: boolean
    responseTime?: boolean
    createdAt?: boolean
  }

  export type QuizResponseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "questionId" | "questionType" | "responseValue" | "responseTime" | "createdAt", ExtArgs["result"]["quizResponse"]>
  export type QuizResponseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | QuizSessionDefaultArgs<ExtArgs>
  }
  export type QuizResponseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | QuizSessionDefaultArgs<ExtArgs>
  }
  export type QuizResponseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | QuizSessionDefaultArgs<ExtArgs>
  }

  export type $QuizResponsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizResponse"
    objects: {
      session: Prisma.$QuizSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      questionId: string
      questionType: string
      responseValue: Prisma.JsonValue
      responseTime: number | null
      createdAt: Date
    }, ExtArgs["result"]["quizResponse"]>
    composites: {}
  }

  type QuizResponseGetPayload<S extends boolean | null | undefined | QuizResponseDefaultArgs> = $Result.GetResult<Prisma.$QuizResponsePayload, S>

  type QuizResponseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizResponseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizResponseCountAggregateInputType | true
    }

  export interface QuizResponseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizResponse'], meta: { name: 'QuizResponse' } }
    /**
     * Find zero or one QuizResponse that matches the filter.
     * @param {QuizResponseFindUniqueArgs} args - Arguments to find a QuizResponse
     * @example
     * // Get one QuizResponse
     * const quizResponse = await prisma.quizResponse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizResponseFindUniqueArgs>(args: SelectSubset<T, QuizResponseFindUniqueArgs<ExtArgs>>): Prisma__QuizResponseClient<$Result.GetResult<Prisma.$QuizResponsePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuizResponse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizResponseFindUniqueOrThrowArgs} args - Arguments to find a QuizResponse
     * @example
     * // Get one QuizResponse
     * const quizResponse = await prisma.quizResponse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizResponseFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizResponseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizResponseClient<$Result.GetResult<Prisma.$QuizResponsePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizResponse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizResponseFindFirstArgs} args - Arguments to find a QuizResponse
     * @example
     * // Get one QuizResponse
     * const quizResponse = await prisma.quizResponse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizResponseFindFirstArgs>(args?: SelectSubset<T, QuizResponseFindFirstArgs<ExtArgs>>): Prisma__QuizResponseClient<$Result.GetResult<Prisma.$QuizResponsePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizResponse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizResponseFindFirstOrThrowArgs} args - Arguments to find a QuizResponse
     * @example
     * // Get one QuizResponse
     * const quizResponse = await prisma.quizResponse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizResponseFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizResponseFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizResponseClient<$Result.GetResult<Prisma.$QuizResponsePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuizResponses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizResponseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizResponses
     * const quizResponses = await prisma.quizResponse.findMany()
     * 
     * // Get first 10 QuizResponses
     * const quizResponses = await prisma.quizResponse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizResponseWithIdOnly = await prisma.quizResponse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizResponseFindManyArgs>(args?: SelectSubset<T, QuizResponseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuizResponse.
     * @param {QuizResponseCreateArgs} args - Arguments to create a QuizResponse.
     * @example
     * // Create one QuizResponse
     * const QuizResponse = await prisma.quizResponse.create({
     *   data: {
     *     // ... data to create a QuizResponse
     *   }
     * })
     * 
     */
    create<T extends QuizResponseCreateArgs>(args: SelectSubset<T, QuizResponseCreateArgs<ExtArgs>>): Prisma__QuizResponseClient<$Result.GetResult<Prisma.$QuizResponsePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuizResponses.
     * @param {QuizResponseCreateManyArgs} args - Arguments to create many QuizResponses.
     * @example
     * // Create many QuizResponses
     * const quizResponse = await prisma.quizResponse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizResponseCreateManyArgs>(args?: SelectSubset<T, QuizResponseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuizResponses and returns the data saved in the database.
     * @param {QuizResponseCreateManyAndReturnArgs} args - Arguments to create many QuizResponses.
     * @example
     * // Create many QuizResponses
     * const quizResponse = await prisma.quizResponse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuizResponses and only return the `id`
     * const quizResponseWithIdOnly = await prisma.quizResponse.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizResponseCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizResponseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizResponsePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuizResponse.
     * @param {QuizResponseDeleteArgs} args - Arguments to delete one QuizResponse.
     * @example
     * // Delete one QuizResponse
     * const QuizResponse = await prisma.quizResponse.delete({
     *   where: {
     *     // ... filter to delete one QuizResponse
     *   }
     * })
     * 
     */
    delete<T extends QuizResponseDeleteArgs>(args: SelectSubset<T, QuizResponseDeleteArgs<ExtArgs>>): Prisma__QuizResponseClient<$Result.GetResult<Prisma.$QuizResponsePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuizResponse.
     * @param {QuizResponseUpdateArgs} args - Arguments to update one QuizResponse.
     * @example
     * // Update one QuizResponse
     * const quizResponse = await prisma.quizResponse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizResponseUpdateArgs>(args: SelectSubset<T, QuizResponseUpdateArgs<ExtArgs>>): Prisma__QuizResponseClient<$Result.GetResult<Prisma.$QuizResponsePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuizResponses.
     * @param {QuizResponseDeleteManyArgs} args - Arguments to filter QuizResponses to delete.
     * @example
     * // Delete a few QuizResponses
     * const { count } = await prisma.quizResponse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizResponseDeleteManyArgs>(args?: SelectSubset<T, QuizResponseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizResponseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizResponses
     * const quizResponse = await prisma.quizResponse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizResponseUpdateManyArgs>(args: SelectSubset<T, QuizResponseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizResponses and returns the data updated in the database.
     * @param {QuizResponseUpdateManyAndReturnArgs} args - Arguments to update many QuizResponses.
     * @example
     * // Update many QuizResponses
     * const quizResponse = await prisma.quizResponse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuizResponses and only return the `id`
     * const quizResponseWithIdOnly = await prisma.quizResponse.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizResponseUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizResponseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizResponsePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuizResponse.
     * @param {QuizResponseUpsertArgs} args - Arguments to update or create a QuizResponse.
     * @example
     * // Update or create a QuizResponse
     * const quizResponse = await prisma.quizResponse.upsert({
     *   create: {
     *     // ... data to create a QuizResponse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizResponse we want to update
     *   }
     * })
     */
    upsert<T extends QuizResponseUpsertArgs>(args: SelectSubset<T, QuizResponseUpsertArgs<ExtArgs>>): Prisma__QuizResponseClient<$Result.GetResult<Prisma.$QuizResponsePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuizResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizResponseCountArgs} args - Arguments to filter QuizResponses to count.
     * @example
     * // Count the number of QuizResponses
     * const count = await prisma.quizResponse.count({
     *   where: {
     *     // ... the filter for the QuizResponses we want to count
     *   }
     * })
    **/
    count<T extends QuizResponseCountArgs>(
      args?: Subset<T, QuizResponseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizResponseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizResponseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizResponseAggregateArgs>(args: Subset<T, QuizResponseAggregateArgs>): Prisma.PrismaPromise<GetQuizResponseAggregateType<T>>

    /**
     * Group by QuizResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizResponseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizResponseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizResponseGroupByArgs['orderBy'] }
        : { orderBy?: QuizResponseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizResponseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizResponseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizResponse model
   */
  readonly fields: QuizResponseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizResponse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizResponseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends QuizSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizSessionDefaultArgs<ExtArgs>>): Prisma__QuizSessionClient<$Result.GetResult<Prisma.$QuizSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizResponse model
   */
  interface QuizResponseFieldRefs {
    readonly id: FieldRef<"QuizResponse", 'String'>
    readonly sessionId: FieldRef<"QuizResponse", 'String'>
    readonly questionId: FieldRef<"QuizResponse", 'String'>
    readonly questionType: FieldRef<"QuizResponse", 'String'>
    readonly responseValue: FieldRef<"QuizResponse", 'Json'>
    readonly responseTime: FieldRef<"QuizResponse", 'Int'>
    readonly createdAt: FieldRef<"QuizResponse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuizResponse findUnique
   */
  export type QuizResponseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResponse
     */
    select?: QuizResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResponse
     */
    omit?: QuizResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizResponseInclude<ExtArgs> | null
    /**
     * Filter, which QuizResponse to fetch.
     */
    where: QuizResponseWhereUniqueInput
  }

  /**
   * QuizResponse findUniqueOrThrow
   */
  export type QuizResponseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResponse
     */
    select?: QuizResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResponse
     */
    omit?: QuizResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizResponseInclude<ExtArgs> | null
    /**
     * Filter, which QuizResponse to fetch.
     */
    where: QuizResponseWhereUniqueInput
  }

  /**
   * QuizResponse findFirst
   */
  export type QuizResponseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResponse
     */
    select?: QuizResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResponse
     */
    omit?: QuizResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizResponseInclude<ExtArgs> | null
    /**
     * Filter, which QuizResponse to fetch.
     */
    where?: QuizResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizResponses to fetch.
     */
    orderBy?: QuizResponseOrderByWithRelationInput | QuizResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizResponses.
     */
    cursor?: QuizResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizResponses.
     */
    distinct?: QuizResponseScalarFieldEnum | QuizResponseScalarFieldEnum[]
  }

  /**
   * QuizResponse findFirstOrThrow
   */
  export type QuizResponseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResponse
     */
    select?: QuizResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResponse
     */
    omit?: QuizResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizResponseInclude<ExtArgs> | null
    /**
     * Filter, which QuizResponse to fetch.
     */
    where?: QuizResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizResponses to fetch.
     */
    orderBy?: QuizResponseOrderByWithRelationInput | QuizResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizResponses.
     */
    cursor?: QuizResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizResponses.
     */
    distinct?: QuizResponseScalarFieldEnum | QuizResponseScalarFieldEnum[]
  }

  /**
   * QuizResponse findMany
   */
  export type QuizResponseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResponse
     */
    select?: QuizResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResponse
     */
    omit?: QuizResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizResponseInclude<ExtArgs> | null
    /**
     * Filter, which QuizResponses to fetch.
     */
    where?: QuizResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizResponses to fetch.
     */
    orderBy?: QuizResponseOrderByWithRelationInput | QuizResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizResponses.
     */
    cursor?: QuizResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizResponses.
     */
    skip?: number
    distinct?: QuizResponseScalarFieldEnum | QuizResponseScalarFieldEnum[]
  }

  /**
   * QuizResponse create
   */
  export type QuizResponseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResponse
     */
    select?: QuizResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResponse
     */
    omit?: QuizResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizResponseInclude<ExtArgs> | null
    /**
     * The data needed to create a QuizResponse.
     */
    data: XOR<QuizResponseCreateInput, QuizResponseUncheckedCreateInput>
  }

  /**
   * QuizResponse createMany
   */
  export type QuizResponseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizResponses.
     */
    data: QuizResponseCreateManyInput | QuizResponseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizResponse createManyAndReturn
   */
  export type QuizResponseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResponse
     */
    select?: QuizResponseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResponse
     */
    omit?: QuizResponseOmit<ExtArgs> | null
    /**
     * The data used to create many QuizResponses.
     */
    data: QuizResponseCreateManyInput | QuizResponseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizResponseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizResponse update
   */
  export type QuizResponseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResponse
     */
    select?: QuizResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResponse
     */
    omit?: QuizResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizResponseInclude<ExtArgs> | null
    /**
     * The data needed to update a QuizResponse.
     */
    data: XOR<QuizResponseUpdateInput, QuizResponseUncheckedUpdateInput>
    /**
     * Choose, which QuizResponse to update.
     */
    where: QuizResponseWhereUniqueInput
  }

  /**
   * QuizResponse updateMany
   */
  export type QuizResponseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizResponses.
     */
    data: XOR<QuizResponseUpdateManyMutationInput, QuizResponseUncheckedUpdateManyInput>
    /**
     * Filter which QuizResponses to update
     */
    where?: QuizResponseWhereInput
    /**
     * Limit how many QuizResponses to update.
     */
    limit?: number
  }

  /**
   * QuizResponse updateManyAndReturn
   */
  export type QuizResponseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResponse
     */
    select?: QuizResponseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResponse
     */
    omit?: QuizResponseOmit<ExtArgs> | null
    /**
     * The data used to update QuizResponses.
     */
    data: XOR<QuizResponseUpdateManyMutationInput, QuizResponseUncheckedUpdateManyInput>
    /**
     * Filter which QuizResponses to update
     */
    where?: QuizResponseWhereInput
    /**
     * Limit how many QuizResponses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizResponseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizResponse upsert
   */
  export type QuizResponseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResponse
     */
    select?: QuizResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResponse
     */
    omit?: QuizResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizResponseInclude<ExtArgs> | null
    /**
     * The filter to search for the QuizResponse to update in case it exists.
     */
    where: QuizResponseWhereUniqueInput
    /**
     * In case the QuizResponse found by the `where` argument doesn't exist, create a new QuizResponse with this data.
     */
    create: XOR<QuizResponseCreateInput, QuizResponseUncheckedCreateInput>
    /**
     * In case the QuizResponse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizResponseUpdateInput, QuizResponseUncheckedUpdateInput>
  }

  /**
   * QuizResponse delete
   */
  export type QuizResponseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResponse
     */
    select?: QuizResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResponse
     */
    omit?: QuizResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizResponseInclude<ExtArgs> | null
    /**
     * Filter which QuizResponse to delete.
     */
    where: QuizResponseWhereUniqueInput
  }

  /**
   * QuizResponse deleteMany
   */
  export type QuizResponseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizResponses to delete
     */
    where?: QuizResponseWhereInput
    /**
     * Limit how many QuizResponses to delete.
     */
    limit?: number
  }

  /**
   * QuizResponse without action
   */
  export type QuizResponseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResponse
     */
    select?: QuizResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResponse
     */
    omit?: QuizResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizResponseInclude<ExtArgs> | null
  }


  /**
   * Model BehavioralInteraction
   */

  export type AggregateBehavioralInteraction = {
    _count: BehavioralInteractionCountAggregateOutputType | null
    _avg: BehavioralInteractionAvgAggregateOutputType | null
    _sum: BehavioralInteractionSumAggregateOutputType | null
    _min: BehavioralInteractionMinAggregateOutputType | null
    _max: BehavioralInteractionMaxAggregateOutputType | null
  }

  export type BehavioralInteractionAvgAggregateOutputType = {
    duration: number | null
  }

  export type BehavioralInteractionSumAggregateOutputType = {
    duration: number | null
  }

  export type BehavioralInteractionMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    interactionType: string | null
    element: string | null
    duration: number | null
    timestamp: Date | null
  }

  export type BehavioralInteractionMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    interactionType: string | null
    element: string | null
    duration: number | null
    timestamp: Date | null
  }

  export type BehavioralInteractionCountAggregateOutputType = {
    id: number
    sessionId: number
    interactionType: number
    element: number
    position: number
    viewport: number
    duration: number
    metadata: number
    timestamp: number
    _all: number
  }


  export type BehavioralInteractionAvgAggregateInputType = {
    duration?: true
  }

  export type BehavioralInteractionSumAggregateInputType = {
    duration?: true
  }

  export type BehavioralInteractionMinAggregateInputType = {
    id?: true
    sessionId?: true
    interactionType?: true
    element?: true
    duration?: true
    timestamp?: true
  }

  export type BehavioralInteractionMaxAggregateInputType = {
    id?: true
    sessionId?: true
    interactionType?: true
    element?: true
    duration?: true
    timestamp?: true
  }

  export type BehavioralInteractionCountAggregateInputType = {
    id?: true
    sessionId?: true
    interactionType?: true
    element?: true
    position?: true
    viewport?: true
    duration?: true
    metadata?: true
    timestamp?: true
    _all?: true
  }

  export type BehavioralInteractionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BehavioralInteraction to aggregate.
     */
    where?: BehavioralInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BehavioralInteractions to fetch.
     */
    orderBy?: BehavioralInteractionOrderByWithRelationInput | BehavioralInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BehavioralInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BehavioralInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BehavioralInteractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BehavioralInteractions
    **/
    _count?: true | BehavioralInteractionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BehavioralInteractionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BehavioralInteractionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BehavioralInteractionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BehavioralInteractionMaxAggregateInputType
  }

  export type GetBehavioralInteractionAggregateType<T extends BehavioralInteractionAggregateArgs> = {
        [P in keyof T & keyof AggregateBehavioralInteraction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBehavioralInteraction[P]>
      : GetScalarType<T[P], AggregateBehavioralInteraction[P]>
  }




  export type BehavioralInteractionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BehavioralInteractionWhereInput
    orderBy?: BehavioralInteractionOrderByWithAggregationInput | BehavioralInteractionOrderByWithAggregationInput[]
    by: BehavioralInteractionScalarFieldEnum[] | BehavioralInteractionScalarFieldEnum
    having?: BehavioralInteractionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BehavioralInteractionCountAggregateInputType | true
    _avg?: BehavioralInteractionAvgAggregateInputType
    _sum?: BehavioralInteractionSumAggregateInputType
    _min?: BehavioralInteractionMinAggregateInputType
    _max?: BehavioralInteractionMaxAggregateInputType
  }

  export type BehavioralInteractionGroupByOutputType = {
    id: string
    sessionId: string
    interactionType: string
    element: string | null
    position: JsonValue | null
    viewport: JsonValue | null
    duration: number | null
    metadata: JsonValue | null
    timestamp: Date
    _count: BehavioralInteractionCountAggregateOutputType | null
    _avg: BehavioralInteractionAvgAggregateOutputType | null
    _sum: BehavioralInteractionSumAggregateOutputType | null
    _min: BehavioralInteractionMinAggregateOutputType | null
    _max: BehavioralInteractionMaxAggregateOutputType | null
  }

  type GetBehavioralInteractionGroupByPayload<T extends BehavioralInteractionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BehavioralInteractionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BehavioralInteractionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BehavioralInteractionGroupByOutputType[P]>
            : GetScalarType<T[P], BehavioralInteractionGroupByOutputType[P]>
        }
      >
    >


  export type BehavioralInteractionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    interactionType?: boolean
    element?: boolean
    position?: boolean
    viewport?: boolean
    duration?: boolean
    metadata?: boolean
    timestamp?: boolean
    session?: boolean | QuizSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["behavioralInteraction"]>

  export type BehavioralInteractionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    interactionType?: boolean
    element?: boolean
    position?: boolean
    viewport?: boolean
    duration?: boolean
    metadata?: boolean
    timestamp?: boolean
    session?: boolean | QuizSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["behavioralInteraction"]>

  export type BehavioralInteractionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    interactionType?: boolean
    element?: boolean
    position?: boolean
    viewport?: boolean
    duration?: boolean
    metadata?: boolean
    timestamp?: boolean
    session?: boolean | QuizSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["behavioralInteraction"]>

  export type BehavioralInteractionSelectScalar = {
    id?: boolean
    sessionId?: boolean
    interactionType?: boolean
    element?: boolean
    position?: boolean
    viewport?: boolean
    duration?: boolean
    metadata?: boolean
    timestamp?: boolean
  }

  export type BehavioralInteractionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "interactionType" | "element" | "position" | "viewport" | "duration" | "metadata" | "timestamp", ExtArgs["result"]["behavioralInteraction"]>
  export type BehavioralInteractionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | QuizSessionDefaultArgs<ExtArgs>
  }
  export type BehavioralInteractionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | QuizSessionDefaultArgs<ExtArgs>
  }
  export type BehavioralInteractionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | QuizSessionDefaultArgs<ExtArgs>
  }

  export type $BehavioralInteractionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BehavioralInteraction"
    objects: {
      session: Prisma.$QuizSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      interactionType: string
      element: string | null
      position: Prisma.JsonValue | null
      viewport: Prisma.JsonValue | null
      duration: number | null
      metadata: Prisma.JsonValue | null
      timestamp: Date
    }, ExtArgs["result"]["behavioralInteraction"]>
    composites: {}
  }

  type BehavioralInteractionGetPayload<S extends boolean | null | undefined | BehavioralInteractionDefaultArgs> = $Result.GetResult<Prisma.$BehavioralInteractionPayload, S>

  type BehavioralInteractionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BehavioralInteractionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BehavioralInteractionCountAggregateInputType | true
    }

  export interface BehavioralInteractionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BehavioralInteraction'], meta: { name: 'BehavioralInteraction' } }
    /**
     * Find zero or one BehavioralInteraction that matches the filter.
     * @param {BehavioralInteractionFindUniqueArgs} args - Arguments to find a BehavioralInteraction
     * @example
     * // Get one BehavioralInteraction
     * const behavioralInteraction = await prisma.behavioralInteraction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BehavioralInteractionFindUniqueArgs>(args: SelectSubset<T, BehavioralInteractionFindUniqueArgs<ExtArgs>>): Prisma__BehavioralInteractionClient<$Result.GetResult<Prisma.$BehavioralInteractionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BehavioralInteraction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BehavioralInteractionFindUniqueOrThrowArgs} args - Arguments to find a BehavioralInteraction
     * @example
     * // Get one BehavioralInteraction
     * const behavioralInteraction = await prisma.behavioralInteraction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BehavioralInteractionFindUniqueOrThrowArgs>(args: SelectSubset<T, BehavioralInteractionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BehavioralInteractionClient<$Result.GetResult<Prisma.$BehavioralInteractionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BehavioralInteraction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehavioralInteractionFindFirstArgs} args - Arguments to find a BehavioralInteraction
     * @example
     * // Get one BehavioralInteraction
     * const behavioralInteraction = await prisma.behavioralInteraction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BehavioralInteractionFindFirstArgs>(args?: SelectSubset<T, BehavioralInteractionFindFirstArgs<ExtArgs>>): Prisma__BehavioralInteractionClient<$Result.GetResult<Prisma.$BehavioralInteractionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BehavioralInteraction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehavioralInteractionFindFirstOrThrowArgs} args - Arguments to find a BehavioralInteraction
     * @example
     * // Get one BehavioralInteraction
     * const behavioralInteraction = await prisma.behavioralInteraction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BehavioralInteractionFindFirstOrThrowArgs>(args?: SelectSubset<T, BehavioralInteractionFindFirstOrThrowArgs<ExtArgs>>): Prisma__BehavioralInteractionClient<$Result.GetResult<Prisma.$BehavioralInteractionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BehavioralInteractions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehavioralInteractionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BehavioralInteractions
     * const behavioralInteractions = await prisma.behavioralInteraction.findMany()
     * 
     * // Get first 10 BehavioralInteractions
     * const behavioralInteractions = await prisma.behavioralInteraction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const behavioralInteractionWithIdOnly = await prisma.behavioralInteraction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BehavioralInteractionFindManyArgs>(args?: SelectSubset<T, BehavioralInteractionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BehavioralInteractionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BehavioralInteraction.
     * @param {BehavioralInteractionCreateArgs} args - Arguments to create a BehavioralInteraction.
     * @example
     * // Create one BehavioralInteraction
     * const BehavioralInteraction = await prisma.behavioralInteraction.create({
     *   data: {
     *     // ... data to create a BehavioralInteraction
     *   }
     * })
     * 
     */
    create<T extends BehavioralInteractionCreateArgs>(args: SelectSubset<T, BehavioralInteractionCreateArgs<ExtArgs>>): Prisma__BehavioralInteractionClient<$Result.GetResult<Prisma.$BehavioralInteractionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BehavioralInteractions.
     * @param {BehavioralInteractionCreateManyArgs} args - Arguments to create many BehavioralInteractions.
     * @example
     * // Create many BehavioralInteractions
     * const behavioralInteraction = await prisma.behavioralInteraction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BehavioralInteractionCreateManyArgs>(args?: SelectSubset<T, BehavioralInteractionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BehavioralInteractions and returns the data saved in the database.
     * @param {BehavioralInteractionCreateManyAndReturnArgs} args - Arguments to create many BehavioralInteractions.
     * @example
     * // Create many BehavioralInteractions
     * const behavioralInteraction = await prisma.behavioralInteraction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BehavioralInteractions and only return the `id`
     * const behavioralInteractionWithIdOnly = await prisma.behavioralInteraction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BehavioralInteractionCreateManyAndReturnArgs>(args?: SelectSubset<T, BehavioralInteractionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BehavioralInteractionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BehavioralInteraction.
     * @param {BehavioralInteractionDeleteArgs} args - Arguments to delete one BehavioralInteraction.
     * @example
     * // Delete one BehavioralInteraction
     * const BehavioralInteraction = await prisma.behavioralInteraction.delete({
     *   where: {
     *     // ... filter to delete one BehavioralInteraction
     *   }
     * })
     * 
     */
    delete<T extends BehavioralInteractionDeleteArgs>(args: SelectSubset<T, BehavioralInteractionDeleteArgs<ExtArgs>>): Prisma__BehavioralInteractionClient<$Result.GetResult<Prisma.$BehavioralInteractionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BehavioralInteraction.
     * @param {BehavioralInteractionUpdateArgs} args - Arguments to update one BehavioralInteraction.
     * @example
     * // Update one BehavioralInteraction
     * const behavioralInteraction = await prisma.behavioralInteraction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BehavioralInteractionUpdateArgs>(args: SelectSubset<T, BehavioralInteractionUpdateArgs<ExtArgs>>): Prisma__BehavioralInteractionClient<$Result.GetResult<Prisma.$BehavioralInteractionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BehavioralInteractions.
     * @param {BehavioralInteractionDeleteManyArgs} args - Arguments to filter BehavioralInteractions to delete.
     * @example
     * // Delete a few BehavioralInteractions
     * const { count } = await prisma.behavioralInteraction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BehavioralInteractionDeleteManyArgs>(args?: SelectSubset<T, BehavioralInteractionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BehavioralInteractions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehavioralInteractionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BehavioralInteractions
     * const behavioralInteraction = await prisma.behavioralInteraction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BehavioralInteractionUpdateManyArgs>(args: SelectSubset<T, BehavioralInteractionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BehavioralInteractions and returns the data updated in the database.
     * @param {BehavioralInteractionUpdateManyAndReturnArgs} args - Arguments to update many BehavioralInteractions.
     * @example
     * // Update many BehavioralInteractions
     * const behavioralInteraction = await prisma.behavioralInteraction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BehavioralInteractions and only return the `id`
     * const behavioralInteractionWithIdOnly = await prisma.behavioralInteraction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BehavioralInteractionUpdateManyAndReturnArgs>(args: SelectSubset<T, BehavioralInteractionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BehavioralInteractionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BehavioralInteraction.
     * @param {BehavioralInteractionUpsertArgs} args - Arguments to update or create a BehavioralInteraction.
     * @example
     * // Update or create a BehavioralInteraction
     * const behavioralInteraction = await prisma.behavioralInteraction.upsert({
     *   create: {
     *     // ... data to create a BehavioralInteraction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BehavioralInteraction we want to update
     *   }
     * })
     */
    upsert<T extends BehavioralInteractionUpsertArgs>(args: SelectSubset<T, BehavioralInteractionUpsertArgs<ExtArgs>>): Prisma__BehavioralInteractionClient<$Result.GetResult<Prisma.$BehavioralInteractionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BehavioralInteractions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehavioralInteractionCountArgs} args - Arguments to filter BehavioralInteractions to count.
     * @example
     * // Count the number of BehavioralInteractions
     * const count = await prisma.behavioralInteraction.count({
     *   where: {
     *     // ... the filter for the BehavioralInteractions we want to count
     *   }
     * })
    **/
    count<T extends BehavioralInteractionCountArgs>(
      args?: Subset<T, BehavioralInteractionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BehavioralInteractionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BehavioralInteraction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehavioralInteractionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BehavioralInteractionAggregateArgs>(args: Subset<T, BehavioralInteractionAggregateArgs>): Prisma.PrismaPromise<GetBehavioralInteractionAggregateType<T>>

    /**
     * Group by BehavioralInteraction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehavioralInteractionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BehavioralInteractionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BehavioralInteractionGroupByArgs['orderBy'] }
        : { orderBy?: BehavioralInteractionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BehavioralInteractionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBehavioralInteractionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BehavioralInteraction model
   */
  readonly fields: BehavioralInteractionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BehavioralInteraction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BehavioralInteractionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends QuizSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizSessionDefaultArgs<ExtArgs>>): Prisma__QuizSessionClient<$Result.GetResult<Prisma.$QuizSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BehavioralInteraction model
   */
  interface BehavioralInteractionFieldRefs {
    readonly id: FieldRef<"BehavioralInteraction", 'String'>
    readonly sessionId: FieldRef<"BehavioralInteraction", 'String'>
    readonly interactionType: FieldRef<"BehavioralInteraction", 'String'>
    readonly element: FieldRef<"BehavioralInteraction", 'String'>
    readonly position: FieldRef<"BehavioralInteraction", 'Json'>
    readonly viewport: FieldRef<"BehavioralInteraction", 'Json'>
    readonly duration: FieldRef<"BehavioralInteraction", 'Int'>
    readonly metadata: FieldRef<"BehavioralInteraction", 'Json'>
    readonly timestamp: FieldRef<"BehavioralInteraction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BehavioralInteraction findUnique
   */
  export type BehavioralInteractionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralInteraction
     */
    select?: BehavioralInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BehavioralInteraction
     */
    omit?: BehavioralInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehavioralInteractionInclude<ExtArgs> | null
    /**
     * Filter, which BehavioralInteraction to fetch.
     */
    where: BehavioralInteractionWhereUniqueInput
  }

  /**
   * BehavioralInteraction findUniqueOrThrow
   */
  export type BehavioralInteractionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralInteraction
     */
    select?: BehavioralInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BehavioralInteraction
     */
    omit?: BehavioralInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehavioralInteractionInclude<ExtArgs> | null
    /**
     * Filter, which BehavioralInteraction to fetch.
     */
    where: BehavioralInteractionWhereUniqueInput
  }

  /**
   * BehavioralInteraction findFirst
   */
  export type BehavioralInteractionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralInteraction
     */
    select?: BehavioralInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BehavioralInteraction
     */
    omit?: BehavioralInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehavioralInteractionInclude<ExtArgs> | null
    /**
     * Filter, which BehavioralInteraction to fetch.
     */
    where?: BehavioralInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BehavioralInteractions to fetch.
     */
    orderBy?: BehavioralInteractionOrderByWithRelationInput | BehavioralInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BehavioralInteractions.
     */
    cursor?: BehavioralInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BehavioralInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BehavioralInteractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BehavioralInteractions.
     */
    distinct?: BehavioralInteractionScalarFieldEnum | BehavioralInteractionScalarFieldEnum[]
  }

  /**
   * BehavioralInteraction findFirstOrThrow
   */
  export type BehavioralInteractionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralInteraction
     */
    select?: BehavioralInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BehavioralInteraction
     */
    omit?: BehavioralInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehavioralInteractionInclude<ExtArgs> | null
    /**
     * Filter, which BehavioralInteraction to fetch.
     */
    where?: BehavioralInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BehavioralInteractions to fetch.
     */
    orderBy?: BehavioralInteractionOrderByWithRelationInput | BehavioralInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BehavioralInteractions.
     */
    cursor?: BehavioralInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BehavioralInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BehavioralInteractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BehavioralInteractions.
     */
    distinct?: BehavioralInteractionScalarFieldEnum | BehavioralInteractionScalarFieldEnum[]
  }

  /**
   * BehavioralInteraction findMany
   */
  export type BehavioralInteractionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralInteraction
     */
    select?: BehavioralInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BehavioralInteraction
     */
    omit?: BehavioralInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehavioralInteractionInclude<ExtArgs> | null
    /**
     * Filter, which BehavioralInteractions to fetch.
     */
    where?: BehavioralInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BehavioralInteractions to fetch.
     */
    orderBy?: BehavioralInteractionOrderByWithRelationInput | BehavioralInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BehavioralInteractions.
     */
    cursor?: BehavioralInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BehavioralInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BehavioralInteractions.
     */
    skip?: number
    distinct?: BehavioralInteractionScalarFieldEnum | BehavioralInteractionScalarFieldEnum[]
  }

  /**
   * BehavioralInteraction create
   */
  export type BehavioralInteractionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralInteraction
     */
    select?: BehavioralInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BehavioralInteraction
     */
    omit?: BehavioralInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehavioralInteractionInclude<ExtArgs> | null
    /**
     * The data needed to create a BehavioralInteraction.
     */
    data: XOR<BehavioralInteractionCreateInput, BehavioralInteractionUncheckedCreateInput>
  }

  /**
   * BehavioralInteraction createMany
   */
  export type BehavioralInteractionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BehavioralInteractions.
     */
    data: BehavioralInteractionCreateManyInput | BehavioralInteractionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BehavioralInteraction createManyAndReturn
   */
  export type BehavioralInteractionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralInteraction
     */
    select?: BehavioralInteractionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BehavioralInteraction
     */
    omit?: BehavioralInteractionOmit<ExtArgs> | null
    /**
     * The data used to create many BehavioralInteractions.
     */
    data: BehavioralInteractionCreateManyInput | BehavioralInteractionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehavioralInteractionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BehavioralInteraction update
   */
  export type BehavioralInteractionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralInteraction
     */
    select?: BehavioralInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BehavioralInteraction
     */
    omit?: BehavioralInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehavioralInteractionInclude<ExtArgs> | null
    /**
     * The data needed to update a BehavioralInteraction.
     */
    data: XOR<BehavioralInteractionUpdateInput, BehavioralInteractionUncheckedUpdateInput>
    /**
     * Choose, which BehavioralInteraction to update.
     */
    where: BehavioralInteractionWhereUniqueInput
  }

  /**
   * BehavioralInteraction updateMany
   */
  export type BehavioralInteractionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BehavioralInteractions.
     */
    data: XOR<BehavioralInteractionUpdateManyMutationInput, BehavioralInteractionUncheckedUpdateManyInput>
    /**
     * Filter which BehavioralInteractions to update
     */
    where?: BehavioralInteractionWhereInput
    /**
     * Limit how many BehavioralInteractions to update.
     */
    limit?: number
  }

  /**
   * BehavioralInteraction updateManyAndReturn
   */
  export type BehavioralInteractionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralInteraction
     */
    select?: BehavioralInteractionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BehavioralInteraction
     */
    omit?: BehavioralInteractionOmit<ExtArgs> | null
    /**
     * The data used to update BehavioralInteractions.
     */
    data: XOR<BehavioralInteractionUpdateManyMutationInput, BehavioralInteractionUncheckedUpdateManyInput>
    /**
     * Filter which BehavioralInteractions to update
     */
    where?: BehavioralInteractionWhereInput
    /**
     * Limit how many BehavioralInteractions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehavioralInteractionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BehavioralInteraction upsert
   */
  export type BehavioralInteractionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralInteraction
     */
    select?: BehavioralInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BehavioralInteraction
     */
    omit?: BehavioralInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehavioralInteractionInclude<ExtArgs> | null
    /**
     * The filter to search for the BehavioralInteraction to update in case it exists.
     */
    where: BehavioralInteractionWhereUniqueInput
    /**
     * In case the BehavioralInteraction found by the `where` argument doesn't exist, create a new BehavioralInteraction with this data.
     */
    create: XOR<BehavioralInteractionCreateInput, BehavioralInteractionUncheckedCreateInput>
    /**
     * In case the BehavioralInteraction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BehavioralInteractionUpdateInput, BehavioralInteractionUncheckedUpdateInput>
  }

  /**
   * BehavioralInteraction delete
   */
  export type BehavioralInteractionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralInteraction
     */
    select?: BehavioralInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BehavioralInteraction
     */
    omit?: BehavioralInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehavioralInteractionInclude<ExtArgs> | null
    /**
     * Filter which BehavioralInteraction to delete.
     */
    where: BehavioralInteractionWhereUniqueInput
  }

  /**
   * BehavioralInteraction deleteMany
   */
  export type BehavioralInteractionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BehavioralInteractions to delete
     */
    where?: BehavioralInteractionWhereInput
    /**
     * Limit how many BehavioralInteractions to delete.
     */
    limit?: number
  }

  /**
   * BehavioralInteraction without action
   */
  export type BehavioralInteractionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralInteraction
     */
    select?: BehavioralInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BehavioralInteraction
     */
    omit?: BehavioralInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehavioralInteractionInclude<ExtArgs> | null
  }


  /**
   * Model QuizConversion
   */

  export type AggregateQuizConversion = {
    _count: QuizConversionCountAggregateOutputType | null
    _avg: QuizConversionAvgAggregateOutputType | null
    _sum: QuizConversionSumAggregateOutputType | null
    _min: QuizConversionMinAggregateOutputType | null
    _max: QuizConversionMaxAggregateOutputType | null
  }

  export type QuizConversionAvgAggregateOutputType = {
    conversionValue: number | null
  }

  export type QuizConversionSumAggregateOutputType = {
    conversionValue: number | null
  }

  export type QuizConversionMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    conversionType: string | null
    conversionValue: number | null
    orderId: string | null
    createdAt: Date | null
  }

  export type QuizConversionMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    conversionType: string | null
    conversionValue: number | null
    orderId: string | null
    createdAt: Date | null
  }

  export type QuizConversionCountAggregateOutputType = {
    id: number
    sessionId: number
    conversionType: number
    conversionValue: number
    orderId: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type QuizConversionAvgAggregateInputType = {
    conversionValue?: true
  }

  export type QuizConversionSumAggregateInputType = {
    conversionValue?: true
  }

  export type QuizConversionMinAggregateInputType = {
    id?: true
    sessionId?: true
    conversionType?: true
    conversionValue?: true
    orderId?: true
    createdAt?: true
  }

  export type QuizConversionMaxAggregateInputType = {
    id?: true
    sessionId?: true
    conversionType?: true
    conversionValue?: true
    orderId?: true
    createdAt?: true
  }

  export type QuizConversionCountAggregateInputType = {
    id?: true
    sessionId?: true
    conversionType?: true
    conversionValue?: true
    orderId?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type QuizConversionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizConversion to aggregate.
     */
    where?: QuizConversionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizConversions to fetch.
     */
    orderBy?: QuizConversionOrderByWithRelationInput | QuizConversionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizConversionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizConversions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizConversions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizConversions
    **/
    _count?: true | QuizConversionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizConversionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizConversionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizConversionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizConversionMaxAggregateInputType
  }

  export type GetQuizConversionAggregateType<T extends QuizConversionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizConversion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizConversion[P]>
      : GetScalarType<T[P], AggregateQuizConversion[P]>
  }




  export type QuizConversionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizConversionWhereInput
    orderBy?: QuizConversionOrderByWithAggregationInput | QuizConversionOrderByWithAggregationInput[]
    by: QuizConversionScalarFieldEnum[] | QuizConversionScalarFieldEnum
    having?: QuizConversionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizConversionCountAggregateInputType | true
    _avg?: QuizConversionAvgAggregateInputType
    _sum?: QuizConversionSumAggregateInputType
    _min?: QuizConversionMinAggregateInputType
    _max?: QuizConversionMaxAggregateInputType
  }

  export type QuizConversionGroupByOutputType = {
    id: string
    sessionId: string
    conversionType: string
    conversionValue: number | null
    orderId: string | null
    metadata: JsonValue | null
    createdAt: Date
    _count: QuizConversionCountAggregateOutputType | null
    _avg: QuizConversionAvgAggregateOutputType | null
    _sum: QuizConversionSumAggregateOutputType | null
    _min: QuizConversionMinAggregateOutputType | null
    _max: QuizConversionMaxAggregateOutputType | null
  }

  type GetQuizConversionGroupByPayload<T extends QuizConversionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizConversionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizConversionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizConversionGroupByOutputType[P]>
            : GetScalarType<T[P], QuizConversionGroupByOutputType[P]>
        }
      >
    >


  export type QuizConversionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    conversionType?: boolean
    conversionValue?: boolean
    orderId?: boolean
    metadata?: boolean
    createdAt?: boolean
    session?: boolean | QuizSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizConversion"]>

  export type QuizConversionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    conversionType?: boolean
    conversionValue?: boolean
    orderId?: boolean
    metadata?: boolean
    createdAt?: boolean
    session?: boolean | QuizSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizConversion"]>

  export type QuizConversionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    conversionType?: boolean
    conversionValue?: boolean
    orderId?: boolean
    metadata?: boolean
    createdAt?: boolean
    session?: boolean | QuizSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizConversion"]>

  export type QuizConversionSelectScalar = {
    id?: boolean
    sessionId?: boolean
    conversionType?: boolean
    conversionValue?: boolean
    orderId?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type QuizConversionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "conversionType" | "conversionValue" | "orderId" | "metadata" | "createdAt", ExtArgs["result"]["quizConversion"]>
  export type QuizConversionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | QuizSessionDefaultArgs<ExtArgs>
  }
  export type QuizConversionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | QuizSessionDefaultArgs<ExtArgs>
  }
  export type QuizConversionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | QuizSessionDefaultArgs<ExtArgs>
  }

  export type $QuizConversionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizConversion"
    objects: {
      session: Prisma.$QuizSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      conversionType: string
      conversionValue: number | null
      orderId: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["quizConversion"]>
    composites: {}
  }

  type QuizConversionGetPayload<S extends boolean | null | undefined | QuizConversionDefaultArgs> = $Result.GetResult<Prisma.$QuizConversionPayload, S>

  type QuizConversionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizConversionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizConversionCountAggregateInputType | true
    }

  export interface QuizConversionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizConversion'], meta: { name: 'QuizConversion' } }
    /**
     * Find zero or one QuizConversion that matches the filter.
     * @param {QuizConversionFindUniqueArgs} args - Arguments to find a QuizConversion
     * @example
     * // Get one QuizConversion
     * const quizConversion = await prisma.quizConversion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizConversionFindUniqueArgs>(args: SelectSubset<T, QuizConversionFindUniqueArgs<ExtArgs>>): Prisma__QuizConversionClient<$Result.GetResult<Prisma.$QuizConversionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuizConversion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizConversionFindUniqueOrThrowArgs} args - Arguments to find a QuizConversion
     * @example
     * // Get one QuizConversion
     * const quizConversion = await prisma.quizConversion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizConversionFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizConversionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizConversionClient<$Result.GetResult<Prisma.$QuizConversionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizConversion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizConversionFindFirstArgs} args - Arguments to find a QuizConversion
     * @example
     * // Get one QuizConversion
     * const quizConversion = await prisma.quizConversion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizConversionFindFirstArgs>(args?: SelectSubset<T, QuizConversionFindFirstArgs<ExtArgs>>): Prisma__QuizConversionClient<$Result.GetResult<Prisma.$QuizConversionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizConversion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizConversionFindFirstOrThrowArgs} args - Arguments to find a QuizConversion
     * @example
     * // Get one QuizConversion
     * const quizConversion = await prisma.quizConversion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizConversionFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizConversionFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizConversionClient<$Result.GetResult<Prisma.$QuizConversionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuizConversions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizConversionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizConversions
     * const quizConversions = await prisma.quizConversion.findMany()
     * 
     * // Get first 10 QuizConversions
     * const quizConversions = await prisma.quizConversion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizConversionWithIdOnly = await prisma.quizConversion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizConversionFindManyArgs>(args?: SelectSubset<T, QuizConversionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizConversionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuizConversion.
     * @param {QuizConversionCreateArgs} args - Arguments to create a QuizConversion.
     * @example
     * // Create one QuizConversion
     * const QuizConversion = await prisma.quizConversion.create({
     *   data: {
     *     // ... data to create a QuizConversion
     *   }
     * })
     * 
     */
    create<T extends QuizConversionCreateArgs>(args: SelectSubset<T, QuizConversionCreateArgs<ExtArgs>>): Prisma__QuizConversionClient<$Result.GetResult<Prisma.$QuizConversionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuizConversions.
     * @param {QuizConversionCreateManyArgs} args - Arguments to create many QuizConversions.
     * @example
     * // Create many QuizConversions
     * const quizConversion = await prisma.quizConversion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizConversionCreateManyArgs>(args?: SelectSubset<T, QuizConversionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuizConversions and returns the data saved in the database.
     * @param {QuizConversionCreateManyAndReturnArgs} args - Arguments to create many QuizConversions.
     * @example
     * // Create many QuizConversions
     * const quizConversion = await prisma.quizConversion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuizConversions and only return the `id`
     * const quizConversionWithIdOnly = await prisma.quizConversion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizConversionCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizConversionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizConversionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuizConversion.
     * @param {QuizConversionDeleteArgs} args - Arguments to delete one QuizConversion.
     * @example
     * // Delete one QuizConversion
     * const QuizConversion = await prisma.quizConversion.delete({
     *   where: {
     *     // ... filter to delete one QuizConversion
     *   }
     * })
     * 
     */
    delete<T extends QuizConversionDeleteArgs>(args: SelectSubset<T, QuizConversionDeleteArgs<ExtArgs>>): Prisma__QuizConversionClient<$Result.GetResult<Prisma.$QuizConversionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuizConversion.
     * @param {QuizConversionUpdateArgs} args - Arguments to update one QuizConversion.
     * @example
     * // Update one QuizConversion
     * const quizConversion = await prisma.quizConversion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizConversionUpdateArgs>(args: SelectSubset<T, QuizConversionUpdateArgs<ExtArgs>>): Prisma__QuizConversionClient<$Result.GetResult<Prisma.$QuizConversionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuizConversions.
     * @param {QuizConversionDeleteManyArgs} args - Arguments to filter QuizConversions to delete.
     * @example
     * // Delete a few QuizConversions
     * const { count } = await prisma.quizConversion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizConversionDeleteManyArgs>(args?: SelectSubset<T, QuizConversionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizConversions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizConversionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizConversions
     * const quizConversion = await prisma.quizConversion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizConversionUpdateManyArgs>(args: SelectSubset<T, QuizConversionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizConversions and returns the data updated in the database.
     * @param {QuizConversionUpdateManyAndReturnArgs} args - Arguments to update many QuizConversions.
     * @example
     * // Update many QuizConversions
     * const quizConversion = await prisma.quizConversion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuizConversions and only return the `id`
     * const quizConversionWithIdOnly = await prisma.quizConversion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizConversionUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizConversionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizConversionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuizConversion.
     * @param {QuizConversionUpsertArgs} args - Arguments to update or create a QuizConversion.
     * @example
     * // Update or create a QuizConversion
     * const quizConversion = await prisma.quizConversion.upsert({
     *   create: {
     *     // ... data to create a QuizConversion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizConversion we want to update
     *   }
     * })
     */
    upsert<T extends QuizConversionUpsertArgs>(args: SelectSubset<T, QuizConversionUpsertArgs<ExtArgs>>): Prisma__QuizConversionClient<$Result.GetResult<Prisma.$QuizConversionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuizConversions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizConversionCountArgs} args - Arguments to filter QuizConversions to count.
     * @example
     * // Count the number of QuizConversions
     * const count = await prisma.quizConversion.count({
     *   where: {
     *     // ... the filter for the QuizConversions we want to count
     *   }
     * })
    **/
    count<T extends QuizConversionCountArgs>(
      args?: Subset<T, QuizConversionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizConversionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizConversion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizConversionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizConversionAggregateArgs>(args: Subset<T, QuizConversionAggregateArgs>): Prisma.PrismaPromise<GetQuizConversionAggregateType<T>>

    /**
     * Group by QuizConversion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizConversionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizConversionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizConversionGroupByArgs['orderBy'] }
        : { orderBy?: QuizConversionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizConversionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizConversionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizConversion model
   */
  readonly fields: QuizConversionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizConversion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizConversionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends QuizSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizSessionDefaultArgs<ExtArgs>>): Prisma__QuizSessionClient<$Result.GetResult<Prisma.$QuizSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizConversion model
   */
  interface QuizConversionFieldRefs {
    readonly id: FieldRef<"QuizConversion", 'String'>
    readonly sessionId: FieldRef<"QuizConversion", 'String'>
    readonly conversionType: FieldRef<"QuizConversion", 'String'>
    readonly conversionValue: FieldRef<"QuizConversion", 'Float'>
    readonly orderId: FieldRef<"QuizConversion", 'String'>
    readonly metadata: FieldRef<"QuizConversion", 'Json'>
    readonly createdAt: FieldRef<"QuizConversion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuizConversion findUnique
   */
  export type QuizConversionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizConversion
     */
    select?: QuizConversionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizConversion
     */
    omit?: QuizConversionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizConversionInclude<ExtArgs> | null
    /**
     * Filter, which QuizConversion to fetch.
     */
    where: QuizConversionWhereUniqueInput
  }

  /**
   * QuizConversion findUniqueOrThrow
   */
  export type QuizConversionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizConversion
     */
    select?: QuizConversionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizConversion
     */
    omit?: QuizConversionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizConversionInclude<ExtArgs> | null
    /**
     * Filter, which QuizConversion to fetch.
     */
    where: QuizConversionWhereUniqueInput
  }

  /**
   * QuizConversion findFirst
   */
  export type QuizConversionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizConversion
     */
    select?: QuizConversionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizConversion
     */
    omit?: QuizConversionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizConversionInclude<ExtArgs> | null
    /**
     * Filter, which QuizConversion to fetch.
     */
    where?: QuizConversionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizConversions to fetch.
     */
    orderBy?: QuizConversionOrderByWithRelationInput | QuizConversionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizConversions.
     */
    cursor?: QuizConversionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizConversions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizConversions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizConversions.
     */
    distinct?: QuizConversionScalarFieldEnum | QuizConversionScalarFieldEnum[]
  }

  /**
   * QuizConversion findFirstOrThrow
   */
  export type QuizConversionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizConversion
     */
    select?: QuizConversionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizConversion
     */
    omit?: QuizConversionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizConversionInclude<ExtArgs> | null
    /**
     * Filter, which QuizConversion to fetch.
     */
    where?: QuizConversionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizConversions to fetch.
     */
    orderBy?: QuizConversionOrderByWithRelationInput | QuizConversionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizConversions.
     */
    cursor?: QuizConversionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizConversions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizConversions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizConversions.
     */
    distinct?: QuizConversionScalarFieldEnum | QuizConversionScalarFieldEnum[]
  }

  /**
   * QuizConversion findMany
   */
  export type QuizConversionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizConversion
     */
    select?: QuizConversionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizConversion
     */
    omit?: QuizConversionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizConversionInclude<ExtArgs> | null
    /**
     * Filter, which QuizConversions to fetch.
     */
    where?: QuizConversionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizConversions to fetch.
     */
    orderBy?: QuizConversionOrderByWithRelationInput | QuizConversionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizConversions.
     */
    cursor?: QuizConversionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizConversions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizConversions.
     */
    skip?: number
    distinct?: QuizConversionScalarFieldEnum | QuizConversionScalarFieldEnum[]
  }

  /**
   * QuizConversion create
   */
  export type QuizConversionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizConversion
     */
    select?: QuizConversionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizConversion
     */
    omit?: QuizConversionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizConversionInclude<ExtArgs> | null
    /**
     * The data needed to create a QuizConversion.
     */
    data: XOR<QuizConversionCreateInput, QuizConversionUncheckedCreateInput>
  }

  /**
   * QuizConversion createMany
   */
  export type QuizConversionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizConversions.
     */
    data: QuizConversionCreateManyInput | QuizConversionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizConversion createManyAndReturn
   */
  export type QuizConversionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizConversion
     */
    select?: QuizConversionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizConversion
     */
    omit?: QuizConversionOmit<ExtArgs> | null
    /**
     * The data used to create many QuizConversions.
     */
    data: QuizConversionCreateManyInput | QuizConversionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizConversionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizConversion update
   */
  export type QuizConversionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizConversion
     */
    select?: QuizConversionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizConversion
     */
    omit?: QuizConversionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizConversionInclude<ExtArgs> | null
    /**
     * The data needed to update a QuizConversion.
     */
    data: XOR<QuizConversionUpdateInput, QuizConversionUncheckedUpdateInput>
    /**
     * Choose, which QuizConversion to update.
     */
    where: QuizConversionWhereUniqueInput
  }

  /**
   * QuizConversion updateMany
   */
  export type QuizConversionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizConversions.
     */
    data: XOR<QuizConversionUpdateManyMutationInput, QuizConversionUncheckedUpdateManyInput>
    /**
     * Filter which QuizConversions to update
     */
    where?: QuizConversionWhereInput
    /**
     * Limit how many QuizConversions to update.
     */
    limit?: number
  }

  /**
   * QuizConversion updateManyAndReturn
   */
  export type QuizConversionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizConversion
     */
    select?: QuizConversionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizConversion
     */
    omit?: QuizConversionOmit<ExtArgs> | null
    /**
     * The data used to update QuizConversions.
     */
    data: XOR<QuizConversionUpdateManyMutationInput, QuizConversionUncheckedUpdateManyInput>
    /**
     * Filter which QuizConversions to update
     */
    where?: QuizConversionWhereInput
    /**
     * Limit how many QuizConversions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizConversionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizConversion upsert
   */
  export type QuizConversionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizConversion
     */
    select?: QuizConversionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizConversion
     */
    omit?: QuizConversionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizConversionInclude<ExtArgs> | null
    /**
     * The filter to search for the QuizConversion to update in case it exists.
     */
    where: QuizConversionWhereUniqueInput
    /**
     * In case the QuizConversion found by the `where` argument doesn't exist, create a new QuizConversion with this data.
     */
    create: XOR<QuizConversionCreateInput, QuizConversionUncheckedCreateInput>
    /**
     * In case the QuizConversion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizConversionUpdateInput, QuizConversionUncheckedUpdateInput>
  }

  /**
   * QuizConversion delete
   */
  export type QuizConversionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizConversion
     */
    select?: QuizConversionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizConversion
     */
    omit?: QuizConversionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizConversionInclude<ExtArgs> | null
    /**
     * Filter which QuizConversion to delete.
     */
    where: QuizConversionWhereUniqueInput
  }

  /**
   * QuizConversion deleteMany
   */
  export type QuizConversionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizConversions to delete
     */
    where?: QuizConversionWhereInput
    /**
     * Limit how many QuizConversions to delete.
     */
    limit?: number
  }

  /**
   * QuizConversion without action
   */
  export type QuizConversionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizConversion
     */
    select?: QuizConversionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizConversion
     */
    omit?: QuizConversionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizConversionInclude<ExtArgs> | null
  }


  /**
   * Model ABTestExperiment
   */

  export type AggregateABTestExperiment = {
    _count: ABTestExperimentCountAggregateOutputType | null
    _min: ABTestExperimentMinAggregateOutputType | null
    _max: ABTestExperimentMaxAggregateOutputType | null
  }

  export type ABTestExperimentMinAggregateOutputType = {
    id: string | null
    name: string | null
    status: string | null
    startDate: Date | null
    endDate: Date | null
    testType: string | null
    winner: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ABTestExperimentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    status: string | null
    startDate: Date | null
    endDate: Date | null
    testType: string | null
    winner: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ABTestExperimentCountAggregateOutputType = {
    id: number
    name: number
    status: number
    startDate: number
    endDate: number
    testType: number
    control: number
    variants: number
    allocation: number
    metrics: number
    results: number
    winner: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ABTestExperimentMinAggregateInputType = {
    id?: true
    name?: true
    status?: true
    startDate?: true
    endDate?: true
    testType?: true
    winner?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ABTestExperimentMaxAggregateInputType = {
    id?: true
    name?: true
    status?: true
    startDate?: true
    endDate?: true
    testType?: true
    winner?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ABTestExperimentCountAggregateInputType = {
    id?: true
    name?: true
    status?: true
    startDate?: true
    endDate?: true
    testType?: true
    control?: true
    variants?: true
    allocation?: true
    metrics?: true
    results?: true
    winner?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ABTestExperimentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ABTestExperiment to aggregate.
     */
    where?: ABTestExperimentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ABTestExperiments to fetch.
     */
    orderBy?: ABTestExperimentOrderByWithRelationInput | ABTestExperimentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ABTestExperimentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ABTestExperiments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ABTestExperiments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ABTestExperiments
    **/
    _count?: true | ABTestExperimentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ABTestExperimentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ABTestExperimentMaxAggregateInputType
  }

  export type GetABTestExperimentAggregateType<T extends ABTestExperimentAggregateArgs> = {
        [P in keyof T & keyof AggregateABTestExperiment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateABTestExperiment[P]>
      : GetScalarType<T[P], AggregateABTestExperiment[P]>
  }




  export type ABTestExperimentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ABTestExperimentWhereInput
    orderBy?: ABTestExperimentOrderByWithAggregationInput | ABTestExperimentOrderByWithAggregationInput[]
    by: ABTestExperimentScalarFieldEnum[] | ABTestExperimentScalarFieldEnum
    having?: ABTestExperimentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ABTestExperimentCountAggregateInputType | true
    _min?: ABTestExperimentMinAggregateInputType
    _max?: ABTestExperimentMaxAggregateInputType
  }

  export type ABTestExperimentGroupByOutputType = {
    id: string
    name: string
    status: string
    startDate: Date | null
    endDate: Date | null
    testType: string
    control: JsonValue
    variants: JsonValue
    allocation: JsonValue
    metrics: JsonValue
    results: JsonValue | null
    winner: string | null
    createdAt: Date
    updatedAt: Date
    _count: ABTestExperimentCountAggregateOutputType | null
    _min: ABTestExperimentMinAggregateOutputType | null
    _max: ABTestExperimentMaxAggregateOutputType | null
  }

  type GetABTestExperimentGroupByPayload<T extends ABTestExperimentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ABTestExperimentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ABTestExperimentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ABTestExperimentGroupByOutputType[P]>
            : GetScalarType<T[P], ABTestExperimentGroupByOutputType[P]>
        }
      >
    >


  export type ABTestExperimentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    testType?: boolean
    control?: boolean
    variants?: boolean
    allocation?: boolean
    metrics?: boolean
    results?: boolean
    winner?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aBTestExperiment"]>

  export type ABTestExperimentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    testType?: boolean
    control?: boolean
    variants?: boolean
    allocation?: boolean
    metrics?: boolean
    results?: boolean
    winner?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aBTestExperiment"]>

  export type ABTestExperimentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    testType?: boolean
    control?: boolean
    variants?: boolean
    allocation?: boolean
    metrics?: boolean
    results?: boolean
    winner?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aBTestExperiment"]>

  export type ABTestExperimentSelectScalar = {
    id?: boolean
    name?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    testType?: boolean
    control?: boolean
    variants?: boolean
    allocation?: boolean
    metrics?: boolean
    results?: boolean
    winner?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ABTestExperimentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "status" | "startDate" | "endDate" | "testType" | "control" | "variants" | "allocation" | "metrics" | "results" | "winner" | "createdAt" | "updatedAt", ExtArgs["result"]["aBTestExperiment"]>

  export type $ABTestExperimentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ABTestExperiment"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      status: string
      startDate: Date | null
      endDate: Date | null
      testType: string
      control: Prisma.JsonValue
      variants: Prisma.JsonValue
      allocation: Prisma.JsonValue
      metrics: Prisma.JsonValue
      results: Prisma.JsonValue | null
      winner: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aBTestExperiment"]>
    composites: {}
  }

  type ABTestExperimentGetPayload<S extends boolean | null | undefined | ABTestExperimentDefaultArgs> = $Result.GetResult<Prisma.$ABTestExperimentPayload, S>

  type ABTestExperimentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ABTestExperimentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ABTestExperimentCountAggregateInputType | true
    }

  export interface ABTestExperimentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ABTestExperiment'], meta: { name: 'ABTestExperiment' } }
    /**
     * Find zero or one ABTestExperiment that matches the filter.
     * @param {ABTestExperimentFindUniqueArgs} args - Arguments to find a ABTestExperiment
     * @example
     * // Get one ABTestExperiment
     * const aBTestExperiment = await prisma.aBTestExperiment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ABTestExperimentFindUniqueArgs>(args: SelectSubset<T, ABTestExperimentFindUniqueArgs<ExtArgs>>): Prisma__ABTestExperimentClient<$Result.GetResult<Prisma.$ABTestExperimentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ABTestExperiment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ABTestExperimentFindUniqueOrThrowArgs} args - Arguments to find a ABTestExperiment
     * @example
     * // Get one ABTestExperiment
     * const aBTestExperiment = await prisma.aBTestExperiment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ABTestExperimentFindUniqueOrThrowArgs>(args: SelectSubset<T, ABTestExperimentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ABTestExperimentClient<$Result.GetResult<Prisma.$ABTestExperimentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ABTestExperiment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ABTestExperimentFindFirstArgs} args - Arguments to find a ABTestExperiment
     * @example
     * // Get one ABTestExperiment
     * const aBTestExperiment = await prisma.aBTestExperiment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ABTestExperimentFindFirstArgs>(args?: SelectSubset<T, ABTestExperimentFindFirstArgs<ExtArgs>>): Prisma__ABTestExperimentClient<$Result.GetResult<Prisma.$ABTestExperimentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ABTestExperiment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ABTestExperimentFindFirstOrThrowArgs} args - Arguments to find a ABTestExperiment
     * @example
     * // Get one ABTestExperiment
     * const aBTestExperiment = await prisma.aBTestExperiment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ABTestExperimentFindFirstOrThrowArgs>(args?: SelectSubset<T, ABTestExperimentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ABTestExperimentClient<$Result.GetResult<Prisma.$ABTestExperimentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ABTestExperiments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ABTestExperimentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ABTestExperiments
     * const aBTestExperiments = await prisma.aBTestExperiment.findMany()
     * 
     * // Get first 10 ABTestExperiments
     * const aBTestExperiments = await prisma.aBTestExperiment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aBTestExperimentWithIdOnly = await prisma.aBTestExperiment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ABTestExperimentFindManyArgs>(args?: SelectSubset<T, ABTestExperimentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ABTestExperimentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ABTestExperiment.
     * @param {ABTestExperimentCreateArgs} args - Arguments to create a ABTestExperiment.
     * @example
     * // Create one ABTestExperiment
     * const ABTestExperiment = await prisma.aBTestExperiment.create({
     *   data: {
     *     // ... data to create a ABTestExperiment
     *   }
     * })
     * 
     */
    create<T extends ABTestExperimentCreateArgs>(args: SelectSubset<T, ABTestExperimentCreateArgs<ExtArgs>>): Prisma__ABTestExperimentClient<$Result.GetResult<Prisma.$ABTestExperimentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ABTestExperiments.
     * @param {ABTestExperimentCreateManyArgs} args - Arguments to create many ABTestExperiments.
     * @example
     * // Create many ABTestExperiments
     * const aBTestExperiment = await prisma.aBTestExperiment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ABTestExperimentCreateManyArgs>(args?: SelectSubset<T, ABTestExperimentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ABTestExperiments and returns the data saved in the database.
     * @param {ABTestExperimentCreateManyAndReturnArgs} args - Arguments to create many ABTestExperiments.
     * @example
     * // Create many ABTestExperiments
     * const aBTestExperiment = await prisma.aBTestExperiment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ABTestExperiments and only return the `id`
     * const aBTestExperimentWithIdOnly = await prisma.aBTestExperiment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ABTestExperimentCreateManyAndReturnArgs>(args?: SelectSubset<T, ABTestExperimentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ABTestExperimentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ABTestExperiment.
     * @param {ABTestExperimentDeleteArgs} args - Arguments to delete one ABTestExperiment.
     * @example
     * // Delete one ABTestExperiment
     * const ABTestExperiment = await prisma.aBTestExperiment.delete({
     *   where: {
     *     // ... filter to delete one ABTestExperiment
     *   }
     * })
     * 
     */
    delete<T extends ABTestExperimentDeleteArgs>(args: SelectSubset<T, ABTestExperimentDeleteArgs<ExtArgs>>): Prisma__ABTestExperimentClient<$Result.GetResult<Prisma.$ABTestExperimentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ABTestExperiment.
     * @param {ABTestExperimentUpdateArgs} args - Arguments to update one ABTestExperiment.
     * @example
     * // Update one ABTestExperiment
     * const aBTestExperiment = await prisma.aBTestExperiment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ABTestExperimentUpdateArgs>(args: SelectSubset<T, ABTestExperimentUpdateArgs<ExtArgs>>): Prisma__ABTestExperimentClient<$Result.GetResult<Prisma.$ABTestExperimentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ABTestExperiments.
     * @param {ABTestExperimentDeleteManyArgs} args - Arguments to filter ABTestExperiments to delete.
     * @example
     * // Delete a few ABTestExperiments
     * const { count } = await prisma.aBTestExperiment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ABTestExperimentDeleteManyArgs>(args?: SelectSubset<T, ABTestExperimentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ABTestExperiments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ABTestExperimentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ABTestExperiments
     * const aBTestExperiment = await prisma.aBTestExperiment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ABTestExperimentUpdateManyArgs>(args: SelectSubset<T, ABTestExperimentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ABTestExperiments and returns the data updated in the database.
     * @param {ABTestExperimentUpdateManyAndReturnArgs} args - Arguments to update many ABTestExperiments.
     * @example
     * // Update many ABTestExperiments
     * const aBTestExperiment = await prisma.aBTestExperiment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ABTestExperiments and only return the `id`
     * const aBTestExperimentWithIdOnly = await prisma.aBTestExperiment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ABTestExperimentUpdateManyAndReturnArgs>(args: SelectSubset<T, ABTestExperimentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ABTestExperimentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ABTestExperiment.
     * @param {ABTestExperimentUpsertArgs} args - Arguments to update or create a ABTestExperiment.
     * @example
     * // Update or create a ABTestExperiment
     * const aBTestExperiment = await prisma.aBTestExperiment.upsert({
     *   create: {
     *     // ... data to create a ABTestExperiment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ABTestExperiment we want to update
     *   }
     * })
     */
    upsert<T extends ABTestExperimentUpsertArgs>(args: SelectSubset<T, ABTestExperimentUpsertArgs<ExtArgs>>): Prisma__ABTestExperimentClient<$Result.GetResult<Prisma.$ABTestExperimentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ABTestExperiments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ABTestExperimentCountArgs} args - Arguments to filter ABTestExperiments to count.
     * @example
     * // Count the number of ABTestExperiments
     * const count = await prisma.aBTestExperiment.count({
     *   where: {
     *     // ... the filter for the ABTestExperiments we want to count
     *   }
     * })
    **/
    count<T extends ABTestExperimentCountArgs>(
      args?: Subset<T, ABTestExperimentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ABTestExperimentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ABTestExperiment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ABTestExperimentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ABTestExperimentAggregateArgs>(args: Subset<T, ABTestExperimentAggregateArgs>): Prisma.PrismaPromise<GetABTestExperimentAggregateType<T>>

    /**
     * Group by ABTestExperiment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ABTestExperimentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ABTestExperimentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ABTestExperimentGroupByArgs['orderBy'] }
        : { orderBy?: ABTestExperimentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ABTestExperimentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetABTestExperimentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ABTestExperiment model
   */
  readonly fields: ABTestExperimentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ABTestExperiment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ABTestExperimentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ABTestExperiment model
   */
  interface ABTestExperimentFieldRefs {
    readonly id: FieldRef<"ABTestExperiment", 'String'>
    readonly name: FieldRef<"ABTestExperiment", 'String'>
    readonly status: FieldRef<"ABTestExperiment", 'String'>
    readonly startDate: FieldRef<"ABTestExperiment", 'DateTime'>
    readonly endDate: FieldRef<"ABTestExperiment", 'DateTime'>
    readonly testType: FieldRef<"ABTestExperiment", 'String'>
    readonly control: FieldRef<"ABTestExperiment", 'Json'>
    readonly variants: FieldRef<"ABTestExperiment", 'Json'>
    readonly allocation: FieldRef<"ABTestExperiment", 'Json'>
    readonly metrics: FieldRef<"ABTestExperiment", 'Json'>
    readonly results: FieldRef<"ABTestExperiment", 'Json'>
    readonly winner: FieldRef<"ABTestExperiment", 'String'>
    readonly createdAt: FieldRef<"ABTestExperiment", 'DateTime'>
    readonly updatedAt: FieldRef<"ABTestExperiment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ABTestExperiment findUnique
   */
  export type ABTestExperimentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTestExperiment
     */
    select?: ABTestExperimentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABTestExperiment
     */
    omit?: ABTestExperimentOmit<ExtArgs> | null
    /**
     * Filter, which ABTestExperiment to fetch.
     */
    where: ABTestExperimentWhereUniqueInput
  }

  /**
   * ABTestExperiment findUniqueOrThrow
   */
  export type ABTestExperimentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTestExperiment
     */
    select?: ABTestExperimentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABTestExperiment
     */
    omit?: ABTestExperimentOmit<ExtArgs> | null
    /**
     * Filter, which ABTestExperiment to fetch.
     */
    where: ABTestExperimentWhereUniqueInput
  }

  /**
   * ABTestExperiment findFirst
   */
  export type ABTestExperimentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTestExperiment
     */
    select?: ABTestExperimentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABTestExperiment
     */
    omit?: ABTestExperimentOmit<ExtArgs> | null
    /**
     * Filter, which ABTestExperiment to fetch.
     */
    where?: ABTestExperimentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ABTestExperiments to fetch.
     */
    orderBy?: ABTestExperimentOrderByWithRelationInput | ABTestExperimentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ABTestExperiments.
     */
    cursor?: ABTestExperimentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ABTestExperiments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ABTestExperiments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ABTestExperiments.
     */
    distinct?: ABTestExperimentScalarFieldEnum | ABTestExperimentScalarFieldEnum[]
  }

  /**
   * ABTestExperiment findFirstOrThrow
   */
  export type ABTestExperimentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTestExperiment
     */
    select?: ABTestExperimentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABTestExperiment
     */
    omit?: ABTestExperimentOmit<ExtArgs> | null
    /**
     * Filter, which ABTestExperiment to fetch.
     */
    where?: ABTestExperimentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ABTestExperiments to fetch.
     */
    orderBy?: ABTestExperimentOrderByWithRelationInput | ABTestExperimentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ABTestExperiments.
     */
    cursor?: ABTestExperimentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ABTestExperiments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ABTestExperiments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ABTestExperiments.
     */
    distinct?: ABTestExperimentScalarFieldEnum | ABTestExperimentScalarFieldEnum[]
  }

  /**
   * ABTestExperiment findMany
   */
  export type ABTestExperimentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTestExperiment
     */
    select?: ABTestExperimentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABTestExperiment
     */
    omit?: ABTestExperimentOmit<ExtArgs> | null
    /**
     * Filter, which ABTestExperiments to fetch.
     */
    where?: ABTestExperimentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ABTestExperiments to fetch.
     */
    orderBy?: ABTestExperimentOrderByWithRelationInput | ABTestExperimentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ABTestExperiments.
     */
    cursor?: ABTestExperimentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ABTestExperiments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ABTestExperiments.
     */
    skip?: number
    distinct?: ABTestExperimentScalarFieldEnum | ABTestExperimentScalarFieldEnum[]
  }

  /**
   * ABTestExperiment create
   */
  export type ABTestExperimentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTestExperiment
     */
    select?: ABTestExperimentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABTestExperiment
     */
    omit?: ABTestExperimentOmit<ExtArgs> | null
    /**
     * The data needed to create a ABTestExperiment.
     */
    data: XOR<ABTestExperimentCreateInput, ABTestExperimentUncheckedCreateInput>
  }

  /**
   * ABTestExperiment createMany
   */
  export type ABTestExperimentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ABTestExperiments.
     */
    data: ABTestExperimentCreateManyInput | ABTestExperimentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ABTestExperiment createManyAndReturn
   */
  export type ABTestExperimentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTestExperiment
     */
    select?: ABTestExperimentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ABTestExperiment
     */
    omit?: ABTestExperimentOmit<ExtArgs> | null
    /**
     * The data used to create many ABTestExperiments.
     */
    data: ABTestExperimentCreateManyInput | ABTestExperimentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ABTestExperiment update
   */
  export type ABTestExperimentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTestExperiment
     */
    select?: ABTestExperimentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABTestExperiment
     */
    omit?: ABTestExperimentOmit<ExtArgs> | null
    /**
     * The data needed to update a ABTestExperiment.
     */
    data: XOR<ABTestExperimentUpdateInput, ABTestExperimentUncheckedUpdateInput>
    /**
     * Choose, which ABTestExperiment to update.
     */
    where: ABTestExperimentWhereUniqueInput
  }

  /**
   * ABTestExperiment updateMany
   */
  export type ABTestExperimentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ABTestExperiments.
     */
    data: XOR<ABTestExperimentUpdateManyMutationInput, ABTestExperimentUncheckedUpdateManyInput>
    /**
     * Filter which ABTestExperiments to update
     */
    where?: ABTestExperimentWhereInput
    /**
     * Limit how many ABTestExperiments to update.
     */
    limit?: number
  }

  /**
   * ABTestExperiment updateManyAndReturn
   */
  export type ABTestExperimentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTestExperiment
     */
    select?: ABTestExperimentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ABTestExperiment
     */
    omit?: ABTestExperimentOmit<ExtArgs> | null
    /**
     * The data used to update ABTestExperiments.
     */
    data: XOR<ABTestExperimentUpdateManyMutationInput, ABTestExperimentUncheckedUpdateManyInput>
    /**
     * Filter which ABTestExperiments to update
     */
    where?: ABTestExperimentWhereInput
    /**
     * Limit how many ABTestExperiments to update.
     */
    limit?: number
  }

  /**
   * ABTestExperiment upsert
   */
  export type ABTestExperimentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTestExperiment
     */
    select?: ABTestExperimentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABTestExperiment
     */
    omit?: ABTestExperimentOmit<ExtArgs> | null
    /**
     * The filter to search for the ABTestExperiment to update in case it exists.
     */
    where: ABTestExperimentWhereUniqueInput
    /**
     * In case the ABTestExperiment found by the `where` argument doesn't exist, create a new ABTestExperiment with this data.
     */
    create: XOR<ABTestExperimentCreateInput, ABTestExperimentUncheckedCreateInput>
    /**
     * In case the ABTestExperiment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ABTestExperimentUpdateInput, ABTestExperimentUncheckedUpdateInput>
  }

  /**
   * ABTestExperiment delete
   */
  export type ABTestExperimentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTestExperiment
     */
    select?: ABTestExperimentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABTestExperiment
     */
    omit?: ABTestExperimentOmit<ExtArgs> | null
    /**
     * Filter which ABTestExperiment to delete.
     */
    where: ABTestExperimentWhereUniqueInput
  }

  /**
   * ABTestExperiment deleteMany
   */
  export type ABTestExperimentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ABTestExperiments to delete
     */
    where?: ABTestExperimentWhereInput
    /**
     * Limit how many ABTestExperiments to delete.
     */
    limit?: number
  }

  /**
   * ABTestExperiment without action
   */
  export type ABTestExperimentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTestExperiment
     */
    select?: ABTestExperimentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABTestExperiment
     */
    omit?: ABTestExperimentOmit<ExtArgs> | null
  }


  /**
   * Model QuizBrand
   */

  export type AggregateQuizBrand = {
    _count: QuizBrandCountAggregateOutputType | null
    _avg: QuizBrandAvgAggregateOutputType | null
    _sum: QuizBrandSumAggregateOutputType | null
    _min: QuizBrandMinAggregateOutputType | null
    _max: QuizBrandMaxAggregateOutputType | null
  }

  export type QuizBrandAvgAggregateOutputType = {
    marketShare: number | null
  }

  export type QuizBrandSumAggregateOutputType = {
    marketShare: number | null
  }

  export type QuizBrandMinAggregateOutputType = {
    id: string | null
    brandId: string | null
    name: string | null
    displayName: string | null
    color: string | null
    voltage: string | null
    marketShare: number | null
    category: string | null
    active: boolean | null
    createdAt: Date | null
  }

  export type QuizBrandMaxAggregateOutputType = {
    id: string | null
    brandId: string | null
    name: string | null
    displayName: string | null
    color: string | null
    voltage: string | null
    marketShare: number | null
    category: string | null
    active: boolean | null
    createdAt: Date | null
  }

  export type QuizBrandCountAggregateOutputType = {
    id: number
    brandId: number
    name: number
    displayName: number
    color: number
    voltage: number
    voltageOptions: number
    marketShare: number
    popularWith: number
    category: number
    active: number
    createdAt: number
    _all: number
  }


  export type QuizBrandAvgAggregateInputType = {
    marketShare?: true
  }

  export type QuizBrandSumAggregateInputType = {
    marketShare?: true
  }

  export type QuizBrandMinAggregateInputType = {
    id?: true
    brandId?: true
    name?: true
    displayName?: true
    color?: true
    voltage?: true
    marketShare?: true
    category?: true
    active?: true
    createdAt?: true
  }

  export type QuizBrandMaxAggregateInputType = {
    id?: true
    brandId?: true
    name?: true
    displayName?: true
    color?: true
    voltage?: true
    marketShare?: true
    category?: true
    active?: true
    createdAt?: true
  }

  export type QuizBrandCountAggregateInputType = {
    id?: true
    brandId?: true
    name?: true
    displayName?: true
    color?: true
    voltage?: true
    voltageOptions?: true
    marketShare?: true
    popularWith?: true
    category?: true
    active?: true
    createdAt?: true
    _all?: true
  }

  export type QuizBrandAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizBrand to aggregate.
     */
    where?: QuizBrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizBrands to fetch.
     */
    orderBy?: QuizBrandOrderByWithRelationInput | QuizBrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizBrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizBrands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizBrands
    **/
    _count?: true | QuizBrandCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizBrandAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizBrandSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizBrandMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizBrandMaxAggregateInputType
  }

  export type GetQuizBrandAggregateType<T extends QuizBrandAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizBrand]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizBrand[P]>
      : GetScalarType<T[P], AggregateQuizBrand[P]>
  }




  export type QuizBrandGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizBrandWhereInput
    orderBy?: QuizBrandOrderByWithAggregationInput | QuizBrandOrderByWithAggregationInput[]
    by: QuizBrandScalarFieldEnum[] | QuizBrandScalarFieldEnum
    having?: QuizBrandScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizBrandCountAggregateInputType | true
    _avg?: QuizBrandAvgAggregateInputType
    _sum?: QuizBrandSumAggregateInputType
    _min?: QuizBrandMinAggregateInputType
    _max?: QuizBrandMaxAggregateInputType
  }

  export type QuizBrandGroupByOutputType = {
    id: string
    brandId: string
    name: string
    displayName: string
    color: string
    voltage: string
    voltageOptions: JsonValue
    marketShare: number | null
    popularWith: JsonValue | null
    category: string | null
    active: boolean
    createdAt: Date
    _count: QuizBrandCountAggregateOutputType | null
    _avg: QuizBrandAvgAggregateOutputType | null
    _sum: QuizBrandSumAggregateOutputType | null
    _min: QuizBrandMinAggregateOutputType | null
    _max: QuizBrandMaxAggregateOutputType | null
  }

  type GetQuizBrandGroupByPayload<T extends QuizBrandGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizBrandGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizBrandGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizBrandGroupByOutputType[P]>
            : GetScalarType<T[P], QuizBrandGroupByOutputType[P]>
        }
      >
    >


  export type QuizBrandSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brandId?: boolean
    name?: boolean
    displayName?: boolean
    color?: boolean
    voltage?: boolean
    voltageOptions?: boolean
    marketShare?: boolean
    popularWith?: boolean
    category?: boolean
    active?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["quizBrand"]>

  export type QuizBrandSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brandId?: boolean
    name?: boolean
    displayName?: boolean
    color?: boolean
    voltage?: boolean
    voltageOptions?: boolean
    marketShare?: boolean
    popularWith?: boolean
    category?: boolean
    active?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["quizBrand"]>

  export type QuizBrandSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brandId?: boolean
    name?: boolean
    displayName?: boolean
    color?: boolean
    voltage?: boolean
    voltageOptions?: boolean
    marketShare?: boolean
    popularWith?: boolean
    category?: boolean
    active?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["quizBrand"]>

  export type QuizBrandSelectScalar = {
    id?: boolean
    brandId?: boolean
    name?: boolean
    displayName?: boolean
    color?: boolean
    voltage?: boolean
    voltageOptions?: boolean
    marketShare?: boolean
    popularWith?: boolean
    category?: boolean
    active?: boolean
    createdAt?: boolean
  }

  export type QuizBrandOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "brandId" | "name" | "displayName" | "color" | "voltage" | "voltageOptions" | "marketShare" | "popularWith" | "category" | "active" | "createdAt", ExtArgs["result"]["quizBrand"]>

  export type $QuizBrandPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizBrand"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      brandId: string
      name: string
      displayName: string
      color: string
      voltage: string
      voltageOptions: Prisma.JsonValue
      marketShare: number | null
      popularWith: Prisma.JsonValue | null
      category: string | null
      active: boolean
      createdAt: Date
    }, ExtArgs["result"]["quizBrand"]>
    composites: {}
  }

  type QuizBrandGetPayload<S extends boolean | null | undefined | QuizBrandDefaultArgs> = $Result.GetResult<Prisma.$QuizBrandPayload, S>

  type QuizBrandCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizBrandFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizBrandCountAggregateInputType | true
    }

  export interface QuizBrandDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizBrand'], meta: { name: 'QuizBrand' } }
    /**
     * Find zero or one QuizBrand that matches the filter.
     * @param {QuizBrandFindUniqueArgs} args - Arguments to find a QuizBrand
     * @example
     * // Get one QuizBrand
     * const quizBrand = await prisma.quizBrand.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizBrandFindUniqueArgs>(args: SelectSubset<T, QuizBrandFindUniqueArgs<ExtArgs>>): Prisma__QuizBrandClient<$Result.GetResult<Prisma.$QuizBrandPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuizBrand that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizBrandFindUniqueOrThrowArgs} args - Arguments to find a QuizBrand
     * @example
     * // Get one QuizBrand
     * const quizBrand = await prisma.quizBrand.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizBrandFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizBrandFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizBrandClient<$Result.GetResult<Prisma.$QuizBrandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizBrand that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizBrandFindFirstArgs} args - Arguments to find a QuizBrand
     * @example
     * // Get one QuizBrand
     * const quizBrand = await prisma.quizBrand.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizBrandFindFirstArgs>(args?: SelectSubset<T, QuizBrandFindFirstArgs<ExtArgs>>): Prisma__QuizBrandClient<$Result.GetResult<Prisma.$QuizBrandPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizBrand that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizBrandFindFirstOrThrowArgs} args - Arguments to find a QuizBrand
     * @example
     * // Get one QuizBrand
     * const quizBrand = await prisma.quizBrand.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizBrandFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizBrandFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizBrandClient<$Result.GetResult<Prisma.$QuizBrandPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuizBrands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizBrandFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizBrands
     * const quizBrands = await prisma.quizBrand.findMany()
     * 
     * // Get first 10 QuizBrands
     * const quizBrands = await prisma.quizBrand.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizBrandWithIdOnly = await prisma.quizBrand.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizBrandFindManyArgs>(args?: SelectSubset<T, QuizBrandFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizBrandPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuizBrand.
     * @param {QuizBrandCreateArgs} args - Arguments to create a QuizBrand.
     * @example
     * // Create one QuizBrand
     * const QuizBrand = await prisma.quizBrand.create({
     *   data: {
     *     // ... data to create a QuizBrand
     *   }
     * })
     * 
     */
    create<T extends QuizBrandCreateArgs>(args: SelectSubset<T, QuizBrandCreateArgs<ExtArgs>>): Prisma__QuizBrandClient<$Result.GetResult<Prisma.$QuizBrandPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuizBrands.
     * @param {QuizBrandCreateManyArgs} args - Arguments to create many QuizBrands.
     * @example
     * // Create many QuizBrands
     * const quizBrand = await prisma.quizBrand.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizBrandCreateManyArgs>(args?: SelectSubset<T, QuizBrandCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuizBrands and returns the data saved in the database.
     * @param {QuizBrandCreateManyAndReturnArgs} args - Arguments to create many QuizBrands.
     * @example
     * // Create many QuizBrands
     * const quizBrand = await prisma.quizBrand.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuizBrands and only return the `id`
     * const quizBrandWithIdOnly = await prisma.quizBrand.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizBrandCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizBrandCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizBrandPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuizBrand.
     * @param {QuizBrandDeleteArgs} args - Arguments to delete one QuizBrand.
     * @example
     * // Delete one QuizBrand
     * const QuizBrand = await prisma.quizBrand.delete({
     *   where: {
     *     // ... filter to delete one QuizBrand
     *   }
     * })
     * 
     */
    delete<T extends QuizBrandDeleteArgs>(args: SelectSubset<T, QuizBrandDeleteArgs<ExtArgs>>): Prisma__QuizBrandClient<$Result.GetResult<Prisma.$QuizBrandPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuizBrand.
     * @param {QuizBrandUpdateArgs} args - Arguments to update one QuizBrand.
     * @example
     * // Update one QuizBrand
     * const quizBrand = await prisma.quizBrand.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizBrandUpdateArgs>(args: SelectSubset<T, QuizBrandUpdateArgs<ExtArgs>>): Prisma__QuizBrandClient<$Result.GetResult<Prisma.$QuizBrandPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuizBrands.
     * @param {QuizBrandDeleteManyArgs} args - Arguments to filter QuizBrands to delete.
     * @example
     * // Delete a few QuizBrands
     * const { count } = await prisma.quizBrand.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizBrandDeleteManyArgs>(args?: SelectSubset<T, QuizBrandDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizBrands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizBrandUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizBrands
     * const quizBrand = await prisma.quizBrand.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizBrandUpdateManyArgs>(args: SelectSubset<T, QuizBrandUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizBrands and returns the data updated in the database.
     * @param {QuizBrandUpdateManyAndReturnArgs} args - Arguments to update many QuizBrands.
     * @example
     * // Update many QuizBrands
     * const quizBrand = await prisma.quizBrand.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuizBrands and only return the `id`
     * const quizBrandWithIdOnly = await prisma.quizBrand.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizBrandUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizBrandUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizBrandPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuizBrand.
     * @param {QuizBrandUpsertArgs} args - Arguments to update or create a QuizBrand.
     * @example
     * // Update or create a QuizBrand
     * const quizBrand = await prisma.quizBrand.upsert({
     *   create: {
     *     // ... data to create a QuizBrand
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizBrand we want to update
     *   }
     * })
     */
    upsert<T extends QuizBrandUpsertArgs>(args: SelectSubset<T, QuizBrandUpsertArgs<ExtArgs>>): Prisma__QuizBrandClient<$Result.GetResult<Prisma.$QuizBrandPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuizBrands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizBrandCountArgs} args - Arguments to filter QuizBrands to count.
     * @example
     * // Count the number of QuizBrands
     * const count = await prisma.quizBrand.count({
     *   where: {
     *     // ... the filter for the QuizBrands we want to count
     *   }
     * })
    **/
    count<T extends QuizBrandCountArgs>(
      args?: Subset<T, QuizBrandCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizBrandCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizBrand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizBrandAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizBrandAggregateArgs>(args: Subset<T, QuizBrandAggregateArgs>): Prisma.PrismaPromise<GetQuizBrandAggregateType<T>>

    /**
     * Group by QuizBrand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizBrandGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizBrandGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizBrandGroupByArgs['orderBy'] }
        : { orderBy?: QuizBrandGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizBrandGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizBrandGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizBrand model
   */
  readonly fields: QuizBrandFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizBrand.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizBrandClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizBrand model
   */
  interface QuizBrandFieldRefs {
    readonly id: FieldRef<"QuizBrand", 'String'>
    readonly brandId: FieldRef<"QuizBrand", 'String'>
    readonly name: FieldRef<"QuizBrand", 'String'>
    readonly displayName: FieldRef<"QuizBrand", 'String'>
    readonly color: FieldRef<"QuizBrand", 'String'>
    readonly voltage: FieldRef<"QuizBrand", 'String'>
    readonly voltageOptions: FieldRef<"QuizBrand", 'Json'>
    readonly marketShare: FieldRef<"QuizBrand", 'Float'>
    readonly popularWith: FieldRef<"QuizBrand", 'Json'>
    readonly category: FieldRef<"QuizBrand", 'String'>
    readonly active: FieldRef<"QuizBrand", 'Boolean'>
    readonly createdAt: FieldRef<"QuizBrand", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuizBrand findUnique
   */
  export type QuizBrandFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizBrand
     */
    select?: QuizBrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizBrand
     */
    omit?: QuizBrandOmit<ExtArgs> | null
    /**
     * Filter, which QuizBrand to fetch.
     */
    where: QuizBrandWhereUniqueInput
  }

  /**
   * QuizBrand findUniqueOrThrow
   */
  export type QuizBrandFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizBrand
     */
    select?: QuizBrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizBrand
     */
    omit?: QuizBrandOmit<ExtArgs> | null
    /**
     * Filter, which QuizBrand to fetch.
     */
    where: QuizBrandWhereUniqueInput
  }

  /**
   * QuizBrand findFirst
   */
  export type QuizBrandFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizBrand
     */
    select?: QuizBrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizBrand
     */
    omit?: QuizBrandOmit<ExtArgs> | null
    /**
     * Filter, which QuizBrand to fetch.
     */
    where?: QuizBrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizBrands to fetch.
     */
    orderBy?: QuizBrandOrderByWithRelationInput | QuizBrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizBrands.
     */
    cursor?: QuizBrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizBrands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizBrands.
     */
    distinct?: QuizBrandScalarFieldEnum | QuizBrandScalarFieldEnum[]
  }

  /**
   * QuizBrand findFirstOrThrow
   */
  export type QuizBrandFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizBrand
     */
    select?: QuizBrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizBrand
     */
    omit?: QuizBrandOmit<ExtArgs> | null
    /**
     * Filter, which QuizBrand to fetch.
     */
    where?: QuizBrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizBrands to fetch.
     */
    orderBy?: QuizBrandOrderByWithRelationInput | QuizBrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizBrands.
     */
    cursor?: QuizBrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizBrands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizBrands.
     */
    distinct?: QuizBrandScalarFieldEnum | QuizBrandScalarFieldEnum[]
  }

  /**
   * QuizBrand findMany
   */
  export type QuizBrandFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizBrand
     */
    select?: QuizBrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizBrand
     */
    omit?: QuizBrandOmit<ExtArgs> | null
    /**
     * Filter, which QuizBrands to fetch.
     */
    where?: QuizBrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizBrands to fetch.
     */
    orderBy?: QuizBrandOrderByWithRelationInput | QuizBrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizBrands.
     */
    cursor?: QuizBrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizBrands.
     */
    skip?: number
    distinct?: QuizBrandScalarFieldEnum | QuizBrandScalarFieldEnum[]
  }

  /**
   * QuizBrand create
   */
  export type QuizBrandCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizBrand
     */
    select?: QuizBrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizBrand
     */
    omit?: QuizBrandOmit<ExtArgs> | null
    /**
     * The data needed to create a QuizBrand.
     */
    data: XOR<QuizBrandCreateInput, QuizBrandUncheckedCreateInput>
  }

  /**
   * QuizBrand createMany
   */
  export type QuizBrandCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizBrands.
     */
    data: QuizBrandCreateManyInput | QuizBrandCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizBrand createManyAndReturn
   */
  export type QuizBrandCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizBrand
     */
    select?: QuizBrandSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizBrand
     */
    omit?: QuizBrandOmit<ExtArgs> | null
    /**
     * The data used to create many QuizBrands.
     */
    data: QuizBrandCreateManyInput | QuizBrandCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizBrand update
   */
  export type QuizBrandUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizBrand
     */
    select?: QuizBrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizBrand
     */
    omit?: QuizBrandOmit<ExtArgs> | null
    /**
     * The data needed to update a QuizBrand.
     */
    data: XOR<QuizBrandUpdateInput, QuizBrandUncheckedUpdateInput>
    /**
     * Choose, which QuizBrand to update.
     */
    where: QuizBrandWhereUniqueInput
  }

  /**
   * QuizBrand updateMany
   */
  export type QuizBrandUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizBrands.
     */
    data: XOR<QuizBrandUpdateManyMutationInput, QuizBrandUncheckedUpdateManyInput>
    /**
     * Filter which QuizBrands to update
     */
    where?: QuizBrandWhereInput
    /**
     * Limit how many QuizBrands to update.
     */
    limit?: number
  }

  /**
   * QuizBrand updateManyAndReturn
   */
  export type QuizBrandUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizBrand
     */
    select?: QuizBrandSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizBrand
     */
    omit?: QuizBrandOmit<ExtArgs> | null
    /**
     * The data used to update QuizBrands.
     */
    data: XOR<QuizBrandUpdateManyMutationInput, QuizBrandUncheckedUpdateManyInput>
    /**
     * Filter which QuizBrands to update
     */
    where?: QuizBrandWhereInput
    /**
     * Limit how many QuizBrands to update.
     */
    limit?: number
  }

  /**
   * QuizBrand upsert
   */
  export type QuizBrandUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizBrand
     */
    select?: QuizBrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizBrand
     */
    omit?: QuizBrandOmit<ExtArgs> | null
    /**
     * The filter to search for the QuizBrand to update in case it exists.
     */
    where: QuizBrandWhereUniqueInput
    /**
     * In case the QuizBrand found by the `where` argument doesn't exist, create a new QuizBrand with this data.
     */
    create: XOR<QuizBrandCreateInput, QuizBrandUncheckedCreateInput>
    /**
     * In case the QuizBrand was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizBrandUpdateInput, QuizBrandUncheckedUpdateInput>
  }

  /**
   * QuizBrand delete
   */
  export type QuizBrandDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizBrand
     */
    select?: QuizBrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizBrand
     */
    omit?: QuizBrandOmit<ExtArgs> | null
    /**
     * Filter which QuizBrand to delete.
     */
    where: QuizBrandWhereUniqueInput
  }

  /**
   * QuizBrand deleteMany
   */
  export type QuizBrandDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizBrands to delete
     */
    where?: QuizBrandWhereInput
    /**
     * Limit how many QuizBrands to delete.
     */
    limit?: number
  }

  /**
   * QuizBrand without action
   */
  export type QuizBrandDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizBrand
     */
    select?: QuizBrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizBrand
     */
    omit?: QuizBrandOmit<ExtArgs> | null
  }


  /**
   * Model QuizRoutingRule
   */

  export type AggregateQuizRoutingRule = {
    _count: QuizRoutingRuleCountAggregateOutputType | null
    _avg: QuizRoutingRuleAvgAggregateOutputType | null
    _sum: QuizRoutingRuleSumAggregateOutputType | null
    _min: QuizRoutingRuleMinAggregateOutputType | null
    _max: QuizRoutingRuleMaxAggregateOutputType | null
  }

  export type QuizRoutingRuleAvgAggregateOutputType = {
    priority: number | null
  }

  export type QuizRoutingRuleSumAggregateOutputType = {
    priority: number | null
  }

  export type QuizRoutingRuleMinAggregateOutputType = {
    id: string | null
    userType: string | null
    brand: string | null
    trade: string | null
    nextQuestionId: string | null
    priority: number | null
    active: boolean | null
    createdAt: Date | null
  }

  export type QuizRoutingRuleMaxAggregateOutputType = {
    id: string | null
    userType: string | null
    brand: string | null
    trade: string | null
    nextQuestionId: string | null
    priority: number | null
    active: boolean | null
    createdAt: Date | null
  }

  export type QuizRoutingRuleCountAggregateOutputType = {
    id: number
    userType: number
    brand: number
    trade: number
    nextQuestionId: number
    condition: number
    priority: number
    active: number
    createdAt: number
    _all: number
  }


  export type QuizRoutingRuleAvgAggregateInputType = {
    priority?: true
  }

  export type QuizRoutingRuleSumAggregateInputType = {
    priority?: true
  }

  export type QuizRoutingRuleMinAggregateInputType = {
    id?: true
    userType?: true
    brand?: true
    trade?: true
    nextQuestionId?: true
    priority?: true
    active?: true
    createdAt?: true
  }

  export type QuizRoutingRuleMaxAggregateInputType = {
    id?: true
    userType?: true
    brand?: true
    trade?: true
    nextQuestionId?: true
    priority?: true
    active?: true
    createdAt?: true
  }

  export type QuizRoutingRuleCountAggregateInputType = {
    id?: true
    userType?: true
    brand?: true
    trade?: true
    nextQuestionId?: true
    condition?: true
    priority?: true
    active?: true
    createdAt?: true
    _all?: true
  }

  export type QuizRoutingRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizRoutingRule to aggregate.
     */
    where?: QuizRoutingRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizRoutingRules to fetch.
     */
    orderBy?: QuizRoutingRuleOrderByWithRelationInput | QuizRoutingRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizRoutingRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizRoutingRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizRoutingRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizRoutingRules
    **/
    _count?: true | QuizRoutingRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizRoutingRuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizRoutingRuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizRoutingRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizRoutingRuleMaxAggregateInputType
  }

  export type GetQuizRoutingRuleAggregateType<T extends QuizRoutingRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizRoutingRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizRoutingRule[P]>
      : GetScalarType<T[P], AggregateQuizRoutingRule[P]>
  }




  export type QuizRoutingRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizRoutingRuleWhereInput
    orderBy?: QuizRoutingRuleOrderByWithAggregationInput | QuizRoutingRuleOrderByWithAggregationInput[]
    by: QuizRoutingRuleScalarFieldEnum[] | QuizRoutingRuleScalarFieldEnum
    having?: QuizRoutingRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizRoutingRuleCountAggregateInputType | true
    _avg?: QuizRoutingRuleAvgAggregateInputType
    _sum?: QuizRoutingRuleSumAggregateInputType
    _min?: QuizRoutingRuleMinAggregateInputType
    _max?: QuizRoutingRuleMaxAggregateInputType
  }

  export type QuizRoutingRuleGroupByOutputType = {
    id: string
    userType: string | null
    brand: string | null
    trade: string | null
    nextQuestionId: string
    condition: JsonValue | null
    priority: number
    active: boolean
    createdAt: Date
    _count: QuizRoutingRuleCountAggregateOutputType | null
    _avg: QuizRoutingRuleAvgAggregateOutputType | null
    _sum: QuizRoutingRuleSumAggregateOutputType | null
    _min: QuizRoutingRuleMinAggregateOutputType | null
    _max: QuizRoutingRuleMaxAggregateOutputType | null
  }

  type GetQuizRoutingRuleGroupByPayload<T extends QuizRoutingRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizRoutingRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizRoutingRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizRoutingRuleGroupByOutputType[P]>
            : GetScalarType<T[P], QuizRoutingRuleGroupByOutputType[P]>
        }
      >
    >


  export type QuizRoutingRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userType?: boolean
    brand?: boolean
    trade?: boolean
    nextQuestionId?: boolean
    condition?: boolean
    priority?: boolean
    active?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["quizRoutingRule"]>

  export type QuizRoutingRuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userType?: boolean
    brand?: boolean
    trade?: boolean
    nextQuestionId?: boolean
    condition?: boolean
    priority?: boolean
    active?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["quizRoutingRule"]>

  export type QuizRoutingRuleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userType?: boolean
    brand?: boolean
    trade?: boolean
    nextQuestionId?: boolean
    condition?: boolean
    priority?: boolean
    active?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["quizRoutingRule"]>

  export type QuizRoutingRuleSelectScalar = {
    id?: boolean
    userType?: boolean
    brand?: boolean
    trade?: boolean
    nextQuestionId?: boolean
    condition?: boolean
    priority?: boolean
    active?: boolean
    createdAt?: boolean
  }

  export type QuizRoutingRuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userType" | "brand" | "trade" | "nextQuestionId" | "condition" | "priority" | "active" | "createdAt", ExtArgs["result"]["quizRoutingRule"]>

  export type $QuizRoutingRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizRoutingRule"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userType: string | null
      brand: string | null
      trade: string | null
      nextQuestionId: string
      condition: Prisma.JsonValue | null
      priority: number
      active: boolean
      createdAt: Date
    }, ExtArgs["result"]["quizRoutingRule"]>
    composites: {}
  }

  type QuizRoutingRuleGetPayload<S extends boolean | null | undefined | QuizRoutingRuleDefaultArgs> = $Result.GetResult<Prisma.$QuizRoutingRulePayload, S>

  type QuizRoutingRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizRoutingRuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizRoutingRuleCountAggregateInputType | true
    }

  export interface QuizRoutingRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizRoutingRule'], meta: { name: 'QuizRoutingRule' } }
    /**
     * Find zero or one QuizRoutingRule that matches the filter.
     * @param {QuizRoutingRuleFindUniqueArgs} args - Arguments to find a QuizRoutingRule
     * @example
     * // Get one QuizRoutingRule
     * const quizRoutingRule = await prisma.quizRoutingRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizRoutingRuleFindUniqueArgs>(args: SelectSubset<T, QuizRoutingRuleFindUniqueArgs<ExtArgs>>): Prisma__QuizRoutingRuleClient<$Result.GetResult<Prisma.$QuizRoutingRulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuizRoutingRule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizRoutingRuleFindUniqueOrThrowArgs} args - Arguments to find a QuizRoutingRule
     * @example
     * // Get one QuizRoutingRule
     * const quizRoutingRule = await prisma.quizRoutingRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizRoutingRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizRoutingRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizRoutingRuleClient<$Result.GetResult<Prisma.$QuizRoutingRulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizRoutingRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizRoutingRuleFindFirstArgs} args - Arguments to find a QuizRoutingRule
     * @example
     * // Get one QuizRoutingRule
     * const quizRoutingRule = await prisma.quizRoutingRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizRoutingRuleFindFirstArgs>(args?: SelectSubset<T, QuizRoutingRuleFindFirstArgs<ExtArgs>>): Prisma__QuizRoutingRuleClient<$Result.GetResult<Prisma.$QuizRoutingRulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizRoutingRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizRoutingRuleFindFirstOrThrowArgs} args - Arguments to find a QuizRoutingRule
     * @example
     * // Get one QuizRoutingRule
     * const quizRoutingRule = await prisma.quizRoutingRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizRoutingRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizRoutingRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizRoutingRuleClient<$Result.GetResult<Prisma.$QuizRoutingRulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuizRoutingRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizRoutingRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizRoutingRules
     * const quizRoutingRules = await prisma.quizRoutingRule.findMany()
     * 
     * // Get first 10 QuizRoutingRules
     * const quizRoutingRules = await prisma.quizRoutingRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizRoutingRuleWithIdOnly = await prisma.quizRoutingRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizRoutingRuleFindManyArgs>(args?: SelectSubset<T, QuizRoutingRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizRoutingRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuizRoutingRule.
     * @param {QuizRoutingRuleCreateArgs} args - Arguments to create a QuizRoutingRule.
     * @example
     * // Create one QuizRoutingRule
     * const QuizRoutingRule = await prisma.quizRoutingRule.create({
     *   data: {
     *     // ... data to create a QuizRoutingRule
     *   }
     * })
     * 
     */
    create<T extends QuizRoutingRuleCreateArgs>(args: SelectSubset<T, QuizRoutingRuleCreateArgs<ExtArgs>>): Prisma__QuizRoutingRuleClient<$Result.GetResult<Prisma.$QuizRoutingRulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuizRoutingRules.
     * @param {QuizRoutingRuleCreateManyArgs} args - Arguments to create many QuizRoutingRules.
     * @example
     * // Create many QuizRoutingRules
     * const quizRoutingRule = await prisma.quizRoutingRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizRoutingRuleCreateManyArgs>(args?: SelectSubset<T, QuizRoutingRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuizRoutingRules and returns the data saved in the database.
     * @param {QuizRoutingRuleCreateManyAndReturnArgs} args - Arguments to create many QuizRoutingRules.
     * @example
     * // Create many QuizRoutingRules
     * const quizRoutingRule = await prisma.quizRoutingRule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuizRoutingRules and only return the `id`
     * const quizRoutingRuleWithIdOnly = await prisma.quizRoutingRule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizRoutingRuleCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizRoutingRuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizRoutingRulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuizRoutingRule.
     * @param {QuizRoutingRuleDeleteArgs} args - Arguments to delete one QuizRoutingRule.
     * @example
     * // Delete one QuizRoutingRule
     * const QuizRoutingRule = await prisma.quizRoutingRule.delete({
     *   where: {
     *     // ... filter to delete one QuizRoutingRule
     *   }
     * })
     * 
     */
    delete<T extends QuizRoutingRuleDeleteArgs>(args: SelectSubset<T, QuizRoutingRuleDeleteArgs<ExtArgs>>): Prisma__QuizRoutingRuleClient<$Result.GetResult<Prisma.$QuizRoutingRulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuizRoutingRule.
     * @param {QuizRoutingRuleUpdateArgs} args - Arguments to update one QuizRoutingRule.
     * @example
     * // Update one QuizRoutingRule
     * const quizRoutingRule = await prisma.quizRoutingRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizRoutingRuleUpdateArgs>(args: SelectSubset<T, QuizRoutingRuleUpdateArgs<ExtArgs>>): Prisma__QuizRoutingRuleClient<$Result.GetResult<Prisma.$QuizRoutingRulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuizRoutingRules.
     * @param {QuizRoutingRuleDeleteManyArgs} args - Arguments to filter QuizRoutingRules to delete.
     * @example
     * // Delete a few QuizRoutingRules
     * const { count } = await prisma.quizRoutingRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizRoutingRuleDeleteManyArgs>(args?: SelectSubset<T, QuizRoutingRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizRoutingRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizRoutingRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizRoutingRules
     * const quizRoutingRule = await prisma.quizRoutingRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizRoutingRuleUpdateManyArgs>(args: SelectSubset<T, QuizRoutingRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizRoutingRules and returns the data updated in the database.
     * @param {QuizRoutingRuleUpdateManyAndReturnArgs} args - Arguments to update many QuizRoutingRules.
     * @example
     * // Update many QuizRoutingRules
     * const quizRoutingRule = await prisma.quizRoutingRule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuizRoutingRules and only return the `id`
     * const quizRoutingRuleWithIdOnly = await prisma.quizRoutingRule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizRoutingRuleUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizRoutingRuleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizRoutingRulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuizRoutingRule.
     * @param {QuizRoutingRuleUpsertArgs} args - Arguments to update or create a QuizRoutingRule.
     * @example
     * // Update or create a QuizRoutingRule
     * const quizRoutingRule = await prisma.quizRoutingRule.upsert({
     *   create: {
     *     // ... data to create a QuizRoutingRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizRoutingRule we want to update
     *   }
     * })
     */
    upsert<T extends QuizRoutingRuleUpsertArgs>(args: SelectSubset<T, QuizRoutingRuleUpsertArgs<ExtArgs>>): Prisma__QuizRoutingRuleClient<$Result.GetResult<Prisma.$QuizRoutingRulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuizRoutingRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizRoutingRuleCountArgs} args - Arguments to filter QuizRoutingRules to count.
     * @example
     * // Count the number of QuizRoutingRules
     * const count = await prisma.quizRoutingRule.count({
     *   where: {
     *     // ... the filter for the QuizRoutingRules we want to count
     *   }
     * })
    **/
    count<T extends QuizRoutingRuleCountArgs>(
      args?: Subset<T, QuizRoutingRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizRoutingRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizRoutingRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizRoutingRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizRoutingRuleAggregateArgs>(args: Subset<T, QuizRoutingRuleAggregateArgs>): Prisma.PrismaPromise<GetQuizRoutingRuleAggregateType<T>>

    /**
     * Group by QuizRoutingRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizRoutingRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizRoutingRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizRoutingRuleGroupByArgs['orderBy'] }
        : { orderBy?: QuizRoutingRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizRoutingRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizRoutingRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizRoutingRule model
   */
  readonly fields: QuizRoutingRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizRoutingRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizRoutingRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizRoutingRule model
   */
  interface QuizRoutingRuleFieldRefs {
    readonly id: FieldRef<"QuizRoutingRule", 'String'>
    readonly userType: FieldRef<"QuizRoutingRule", 'String'>
    readonly brand: FieldRef<"QuizRoutingRule", 'String'>
    readonly trade: FieldRef<"QuizRoutingRule", 'String'>
    readonly nextQuestionId: FieldRef<"QuizRoutingRule", 'String'>
    readonly condition: FieldRef<"QuizRoutingRule", 'Json'>
    readonly priority: FieldRef<"QuizRoutingRule", 'Int'>
    readonly active: FieldRef<"QuizRoutingRule", 'Boolean'>
    readonly createdAt: FieldRef<"QuizRoutingRule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuizRoutingRule findUnique
   */
  export type QuizRoutingRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizRoutingRule
     */
    select?: QuizRoutingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizRoutingRule
     */
    omit?: QuizRoutingRuleOmit<ExtArgs> | null
    /**
     * Filter, which QuizRoutingRule to fetch.
     */
    where: QuizRoutingRuleWhereUniqueInput
  }

  /**
   * QuizRoutingRule findUniqueOrThrow
   */
  export type QuizRoutingRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizRoutingRule
     */
    select?: QuizRoutingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizRoutingRule
     */
    omit?: QuizRoutingRuleOmit<ExtArgs> | null
    /**
     * Filter, which QuizRoutingRule to fetch.
     */
    where: QuizRoutingRuleWhereUniqueInput
  }

  /**
   * QuizRoutingRule findFirst
   */
  export type QuizRoutingRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizRoutingRule
     */
    select?: QuizRoutingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizRoutingRule
     */
    omit?: QuizRoutingRuleOmit<ExtArgs> | null
    /**
     * Filter, which QuizRoutingRule to fetch.
     */
    where?: QuizRoutingRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizRoutingRules to fetch.
     */
    orderBy?: QuizRoutingRuleOrderByWithRelationInput | QuizRoutingRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizRoutingRules.
     */
    cursor?: QuizRoutingRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizRoutingRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizRoutingRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizRoutingRules.
     */
    distinct?: QuizRoutingRuleScalarFieldEnum | QuizRoutingRuleScalarFieldEnum[]
  }

  /**
   * QuizRoutingRule findFirstOrThrow
   */
  export type QuizRoutingRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizRoutingRule
     */
    select?: QuizRoutingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizRoutingRule
     */
    omit?: QuizRoutingRuleOmit<ExtArgs> | null
    /**
     * Filter, which QuizRoutingRule to fetch.
     */
    where?: QuizRoutingRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizRoutingRules to fetch.
     */
    orderBy?: QuizRoutingRuleOrderByWithRelationInput | QuizRoutingRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizRoutingRules.
     */
    cursor?: QuizRoutingRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizRoutingRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizRoutingRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizRoutingRules.
     */
    distinct?: QuizRoutingRuleScalarFieldEnum | QuizRoutingRuleScalarFieldEnum[]
  }

  /**
   * QuizRoutingRule findMany
   */
  export type QuizRoutingRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizRoutingRule
     */
    select?: QuizRoutingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizRoutingRule
     */
    omit?: QuizRoutingRuleOmit<ExtArgs> | null
    /**
     * Filter, which QuizRoutingRules to fetch.
     */
    where?: QuizRoutingRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizRoutingRules to fetch.
     */
    orderBy?: QuizRoutingRuleOrderByWithRelationInput | QuizRoutingRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizRoutingRules.
     */
    cursor?: QuizRoutingRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizRoutingRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizRoutingRules.
     */
    skip?: number
    distinct?: QuizRoutingRuleScalarFieldEnum | QuizRoutingRuleScalarFieldEnum[]
  }

  /**
   * QuizRoutingRule create
   */
  export type QuizRoutingRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizRoutingRule
     */
    select?: QuizRoutingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizRoutingRule
     */
    omit?: QuizRoutingRuleOmit<ExtArgs> | null
    /**
     * The data needed to create a QuizRoutingRule.
     */
    data: XOR<QuizRoutingRuleCreateInput, QuizRoutingRuleUncheckedCreateInput>
  }

  /**
   * QuizRoutingRule createMany
   */
  export type QuizRoutingRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizRoutingRules.
     */
    data: QuizRoutingRuleCreateManyInput | QuizRoutingRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizRoutingRule createManyAndReturn
   */
  export type QuizRoutingRuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizRoutingRule
     */
    select?: QuizRoutingRuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizRoutingRule
     */
    omit?: QuizRoutingRuleOmit<ExtArgs> | null
    /**
     * The data used to create many QuizRoutingRules.
     */
    data: QuizRoutingRuleCreateManyInput | QuizRoutingRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizRoutingRule update
   */
  export type QuizRoutingRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizRoutingRule
     */
    select?: QuizRoutingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizRoutingRule
     */
    omit?: QuizRoutingRuleOmit<ExtArgs> | null
    /**
     * The data needed to update a QuizRoutingRule.
     */
    data: XOR<QuizRoutingRuleUpdateInput, QuizRoutingRuleUncheckedUpdateInput>
    /**
     * Choose, which QuizRoutingRule to update.
     */
    where: QuizRoutingRuleWhereUniqueInput
  }

  /**
   * QuizRoutingRule updateMany
   */
  export type QuizRoutingRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizRoutingRules.
     */
    data: XOR<QuizRoutingRuleUpdateManyMutationInput, QuizRoutingRuleUncheckedUpdateManyInput>
    /**
     * Filter which QuizRoutingRules to update
     */
    where?: QuizRoutingRuleWhereInput
    /**
     * Limit how many QuizRoutingRules to update.
     */
    limit?: number
  }

  /**
   * QuizRoutingRule updateManyAndReturn
   */
  export type QuizRoutingRuleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizRoutingRule
     */
    select?: QuizRoutingRuleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizRoutingRule
     */
    omit?: QuizRoutingRuleOmit<ExtArgs> | null
    /**
     * The data used to update QuizRoutingRules.
     */
    data: XOR<QuizRoutingRuleUpdateManyMutationInput, QuizRoutingRuleUncheckedUpdateManyInput>
    /**
     * Filter which QuizRoutingRules to update
     */
    where?: QuizRoutingRuleWhereInput
    /**
     * Limit how many QuizRoutingRules to update.
     */
    limit?: number
  }

  /**
   * QuizRoutingRule upsert
   */
  export type QuizRoutingRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizRoutingRule
     */
    select?: QuizRoutingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizRoutingRule
     */
    omit?: QuizRoutingRuleOmit<ExtArgs> | null
    /**
     * The filter to search for the QuizRoutingRule to update in case it exists.
     */
    where: QuizRoutingRuleWhereUniqueInput
    /**
     * In case the QuizRoutingRule found by the `where` argument doesn't exist, create a new QuizRoutingRule with this data.
     */
    create: XOR<QuizRoutingRuleCreateInput, QuizRoutingRuleUncheckedCreateInput>
    /**
     * In case the QuizRoutingRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizRoutingRuleUpdateInput, QuizRoutingRuleUncheckedUpdateInput>
  }

  /**
   * QuizRoutingRule delete
   */
  export type QuizRoutingRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizRoutingRule
     */
    select?: QuizRoutingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizRoutingRule
     */
    omit?: QuizRoutingRuleOmit<ExtArgs> | null
    /**
     * Filter which QuizRoutingRule to delete.
     */
    where: QuizRoutingRuleWhereUniqueInput
  }

  /**
   * QuizRoutingRule deleteMany
   */
  export type QuizRoutingRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizRoutingRules to delete
     */
    where?: QuizRoutingRuleWhereInput
    /**
     * Limit how many QuizRoutingRules to delete.
     */
    limit?: number
  }

  /**
   * QuizRoutingRule without action
   */
  export type QuizRoutingRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizRoutingRule
     */
    select?: QuizRoutingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizRoutingRule
     */
    omit?: QuizRoutingRuleOmit<ExtArgs> | null
  }


  /**
   * Model QuizIntervention
   */

  export type AggregateQuizIntervention = {
    _count: QuizInterventionCountAggregateOutputType | null
    _min: QuizInterventionMinAggregateOutputType | null
    _max: QuizInterventionMaxAggregateOutputType | null
  }

  export type QuizInterventionMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    interventionType: string | null
    triggerReason: string | null
    questionId: string | null
    shownAt: Date | null
    userAction: string | null
    actionTimestamp: Date | null
  }

  export type QuizInterventionMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    interventionType: string | null
    triggerReason: string | null
    questionId: string | null
    shownAt: Date | null
    userAction: string | null
    actionTimestamp: Date | null
  }

  export type QuizInterventionCountAggregateOutputType = {
    id: number
    sessionId: number
    interventionType: number
    triggerReason: number
    questionId: number
    shownAt: number
    userAction: number
    actionTimestamp: number
    _all: number
  }


  export type QuizInterventionMinAggregateInputType = {
    id?: true
    sessionId?: true
    interventionType?: true
    triggerReason?: true
    questionId?: true
    shownAt?: true
    userAction?: true
    actionTimestamp?: true
  }

  export type QuizInterventionMaxAggregateInputType = {
    id?: true
    sessionId?: true
    interventionType?: true
    triggerReason?: true
    questionId?: true
    shownAt?: true
    userAction?: true
    actionTimestamp?: true
  }

  export type QuizInterventionCountAggregateInputType = {
    id?: true
    sessionId?: true
    interventionType?: true
    triggerReason?: true
    questionId?: true
    shownAt?: true
    userAction?: true
    actionTimestamp?: true
    _all?: true
  }

  export type QuizInterventionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizIntervention to aggregate.
     */
    where?: QuizInterventionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizInterventions to fetch.
     */
    orderBy?: QuizInterventionOrderByWithRelationInput | QuizInterventionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizInterventionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizInterventions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizInterventions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizInterventions
    **/
    _count?: true | QuizInterventionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizInterventionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizInterventionMaxAggregateInputType
  }

  export type GetQuizInterventionAggregateType<T extends QuizInterventionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizIntervention]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizIntervention[P]>
      : GetScalarType<T[P], AggregateQuizIntervention[P]>
  }




  export type QuizInterventionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizInterventionWhereInput
    orderBy?: QuizInterventionOrderByWithAggregationInput | QuizInterventionOrderByWithAggregationInput[]
    by: QuizInterventionScalarFieldEnum[] | QuizInterventionScalarFieldEnum
    having?: QuizInterventionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizInterventionCountAggregateInputType | true
    _min?: QuizInterventionMinAggregateInputType
    _max?: QuizInterventionMaxAggregateInputType
  }

  export type QuizInterventionGroupByOutputType = {
    id: string
    sessionId: string
    interventionType: string
    triggerReason: string
    questionId: string | null
    shownAt: Date
    userAction: string | null
    actionTimestamp: Date | null
    _count: QuizInterventionCountAggregateOutputType | null
    _min: QuizInterventionMinAggregateOutputType | null
    _max: QuizInterventionMaxAggregateOutputType | null
  }

  type GetQuizInterventionGroupByPayload<T extends QuizInterventionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizInterventionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizInterventionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizInterventionGroupByOutputType[P]>
            : GetScalarType<T[P], QuizInterventionGroupByOutputType[P]>
        }
      >
    >


  export type QuizInterventionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    interventionType?: boolean
    triggerReason?: boolean
    questionId?: boolean
    shownAt?: boolean
    userAction?: boolean
    actionTimestamp?: boolean
  }, ExtArgs["result"]["quizIntervention"]>

  export type QuizInterventionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    interventionType?: boolean
    triggerReason?: boolean
    questionId?: boolean
    shownAt?: boolean
    userAction?: boolean
    actionTimestamp?: boolean
  }, ExtArgs["result"]["quizIntervention"]>

  export type QuizInterventionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    interventionType?: boolean
    triggerReason?: boolean
    questionId?: boolean
    shownAt?: boolean
    userAction?: boolean
    actionTimestamp?: boolean
  }, ExtArgs["result"]["quizIntervention"]>

  export type QuizInterventionSelectScalar = {
    id?: boolean
    sessionId?: boolean
    interventionType?: boolean
    triggerReason?: boolean
    questionId?: boolean
    shownAt?: boolean
    userAction?: boolean
    actionTimestamp?: boolean
  }

  export type QuizInterventionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "interventionType" | "triggerReason" | "questionId" | "shownAt" | "userAction" | "actionTimestamp", ExtArgs["result"]["quizIntervention"]>

  export type $QuizInterventionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizIntervention"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      interventionType: string
      triggerReason: string
      questionId: string | null
      shownAt: Date
      userAction: string | null
      actionTimestamp: Date | null
    }, ExtArgs["result"]["quizIntervention"]>
    composites: {}
  }

  type QuizInterventionGetPayload<S extends boolean | null | undefined | QuizInterventionDefaultArgs> = $Result.GetResult<Prisma.$QuizInterventionPayload, S>

  type QuizInterventionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizInterventionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizInterventionCountAggregateInputType | true
    }

  export interface QuizInterventionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizIntervention'], meta: { name: 'QuizIntervention' } }
    /**
     * Find zero or one QuizIntervention that matches the filter.
     * @param {QuizInterventionFindUniqueArgs} args - Arguments to find a QuizIntervention
     * @example
     * // Get one QuizIntervention
     * const quizIntervention = await prisma.quizIntervention.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizInterventionFindUniqueArgs>(args: SelectSubset<T, QuizInterventionFindUniqueArgs<ExtArgs>>): Prisma__QuizInterventionClient<$Result.GetResult<Prisma.$QuizInterventionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuizIntervention that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizInterventionFindUniqueOrThrowArgs} args - Arguments to find a QuizIntervention
     * @example
     * // Get one QuizIntervention
     * const quizIntervention = await prisma.quizIntervention.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizInterventionFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizInterventionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizInterventionClient<$Result.GetResult<Prisma.$QuizInterventionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizIntervention that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizInterventionFindFirstArgs} args - Arguments to find a QuizIntervention
     * @example
     * // Get one QuizIntervention
     * const quizIntervention = await prisma.quizIntervention.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizInterventionFindFirstArgs>(args?: SelectSubset<T, QuizInterventionFindFirstArgs<ExtArgs>>): Prisma__QuizInterventionClient<$Result.GetResult<Prisma.$QuizInterventionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizIntervention that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizInterventionFindFirstOrThrowArgs} args - Arguments to find a QuizIntervention
     * @example
     * // Get one QuizIntervention
     * const quizIntervention = await prisma.quizIntervention.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizInterventionFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizInterventionFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizInterventionClient<$Result.GetResult<Prisma.$QuizInterventionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuizInterventions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizInterventionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizInterventions
     * const quizInterventions = await prisma.quizIntervention.findMany()
     * 
     * // Get first 10 QuizInterventions
     * const quizInterventions = await prisma.quizIntervention.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizInterventionWithIdOnly = await prisma.quizIntervention.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizInterventionFindManyArgs>(args?: SelectSubset<T, QuizInterventionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizInterventionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuizIntervention.
     * @param {QuizInterventionCreateArgs} args - Arguments to create a QuizIntervention.
     * @example
     * // Create one QuizIntervention
     * const QuizIntervention = await prisma.quizIntervention.create({
     *   data: {
     *     // ... data to create a QuizIntervention
     *   }
     * })
     * 
     */
    create<T extends QuizInterventionCreateArgs>(args: SelectSubset<T, QuizInterventionCreateArgs<ExtArgs>>): Prisma__QuizInterventionClient<$Result.GetResult<Prisma.$QuizInterventionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuizInterventions.
     * @param {QuizInterventionCreateManyArgs} args - Arguments to create many QuizInterventions.
     * @example
     * // Create many QuizInterventions
     * const quizIntervention = await prisma.quizIntervention.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizInterventionCreateManyArgs>(args?: SelectSubset<T, QuizInterventionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuizInterventions and returns the data saved in the database.
     * @param {QuizInterventionCreateManyAndReturnArgs} args - Arguments to create many QuizInterventions.
     * @example
     * // Create many QuizInterventions
     * const quizIntervention = await prisma.quizIntervention.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuizInterventions and only return the `id`
     * const quizInterventionWithIdOnly = await prisma.quizIntervention.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizInterventionCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizInterventionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizInterventionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuizIntervention.
     * @param {QuizInterventionDeleteArgs} args - Arguments to delete one QuizIntervention.
     * @example
     * // Delete one QuizIntervention
     * const QuizIntervention = await prisma.quizIntervention.delete({
     *   where: {
     *     // ... filter to delete one QuizIntervention
     *   }
     * })
     * 
     */
    delete<T extends QuizInterventionDeleteArgs>(args: SelectSubset<T, QuizInterventionDeleteArgs<ExtArgs>>): Prisma__QuizInterventionClient<$Result.GetResult<Prisma.$QuizInterventionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuizIntervention.
     * @param {QuizInterventionUpdateArgs} args - Arguments to update one QuizIntervention.
     * @example
     * // Update one QuizIntervention
     * const quizIntervention = await prisma.quizIntervention.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizInterventionUpdateArgs>(args: SelectSubset<T, QuizInterventionUpdateArgs<ExtArgs>>): Prisma__QuizInterventionClient<$Result.GetResult<Prisma.$QuizInterventionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuizInterventions.
     * @param {QuizInterventionDeleteManyArgs} args - Arguments to filter QuizInterventions to delete.
     * @example
     * // Delete a few QuizInterventions
     * const { count } = await prisma.quizIntervention.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizInterventionDeleteManyArgs>(args?: SelectSubset<T, QuizInterventionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizInterventions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizInterventionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizInterventions
     * const quizIntervention = await prisma.quizIntervention.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizInterventionUpdateManyArgs>(args: SelectSubset<T, QuizInterventionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizInterventions and returns the data updated in the database.
     * @param {QuizInterventionUpdateManyAndReturnArgs} args - Arguments to update many QuizInterventions.
     * @example
     * // Update many QuizInterventions
     * const quizIntervention = await prisma.quizIntervention.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuizInterventions and only return the `id`
     * const quizInterventionWithIdOnly = await prisma.quizIntervention.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizInterventionUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizInterventionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizInterventionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuizIntervention.
     * @param {QuizInterventionUpsertArgs} args - Arguments to update or create a QuizIntervention.
     * @example
     * // Update or create a QuizIntervention
     * const quizIntervention = await prisma.quizIntervention.upsert({
     *   create: {
     *     // ... data to create a QuizIntervention
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizIntervention we want to update
     *   }
     * })
     */
    upsert<T extends QuizInterventionUpsertArgs>(args: SelectSubset<T, QuizInterventionUpsertArgs<ExtArgs>>): Prisma__QuizInterventionClient<$Result.GetResult<Prisma.$QuizInterventionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuizInterventions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizInterventionCountArgs} args - Arguments to filter QuizInterventions to count.
     * @example
     * // Count the number of QuizInterventions
     * const count = await prisma.quizIntervention.count({
     *   where: {
     *     // ... the filter for the QuizInterventions we want to count
     *   }
     * })
    **/
    count<T extends QuizInterventionCountArgs>(
      args?: Subset<T, QuizInterventionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizInterventionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizIntervention.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizInterventionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizInterventionAggregateArgs>(args: Subset<T, QuizInterventionAggregateArgs>): Prisma.PrismaPromise<GetQuizInterventionAggregateType<T>>

    /**
     * Group by QuizIntervention.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizInterventionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizInterventionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizInterventionGroupByArgs['orderBy'] }
        : { orderBy?: QuizInterventionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizInterventionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizInterventionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizIntervention model
   */
  readonly fields: QuizInterventionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizIntervention.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizInterventionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizIntervention model
   */
  interface QuizInterventionFieldRefs {
    readonly id: FieldRef<"QuizIntervention", 'String'>
    readonly sessionId: FieldRef<"QuizIntervention", 'String'>
    readonly interventionType: FieldRef<"QuizIntervention", 'String'>
    readonly triggerReason: FieldRef<"QuizIntervention", 'String'>
    readonly questionId: FieldRef<"QuizIntervention", 'String'>
    readonly shownAt: FieldRef<"QuizIntervention", 'DateTime'>
    readonly userAction: FieldRef<"QuizIntervention", 'String'>
    readonly actionTimestamp: FieldRef<"QuizIntervention", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuizIntervention findUnique
   */
  export type QuizInterventionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizIntervention
     */
    select?: QuizInterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizIntervention
     */
    omit?: QuizInterventionOmit<ExtArgs> | null
    /**
     * Filter, which QuizIntervention to fetch.
     */
    where: QuizInterventionWhereUniqueInput
  }

  /**
   * QuizIntervention findUniqueOrThrow
   */
  export type QuizInterventionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizIntervention
     */
    select?: QuizInterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizIntervention
     */
    omit?: QuizInterventionOmit<ExtArgs> | null
    /**
     * Filter, which QuizIntervention to fetch.
     */
    where: QuizInterventionWhereUniqueInput
  }

  /**
   * QuizIntervention findFirst
   */
  export type QuizInterventionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizIntervention
     */
    select?: QuizInterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizIntervention
     */
    omit?: QuizInterventionOmit<ExtArgs> | null
    /**
     * Filter, which QuizIntervention to fetch.
     */
    where?: QuizInterventionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizInterventions to fetch.
     */
    orderBy?: QuizInterventionOrderByWithRelationInput | QuizInterventionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizInterventions.
     */
    cursor?: QuizInterventionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizInterventions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizInterventions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizInterventions.
     */
    distinct?: QuizInterventionScalarFieldEnum | QuizInterventionScalarFieldEnum[]
  }

  /**
   * QuizIntervention findFirstOrThrow
   */
  export type QuizInterventionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizIntervention
     */
    select?: QuizInterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizIntervention
     */
    omit?: QuizInterventionOmit<ExtArgs> | null
    /**
     * Filter, which QuizIntervention to fetch.
     */
    where?: QuizInterventionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizInterventions to fetch.
     */
    orderBy?: QuizInterventionOrderByWithRelationInput | QuizInterventionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizInterventions.
     */
    cursor?: QuizInterventionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizInterventions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizInterventions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizInterventions.
     */
    distinct?: QuizInterventionScalarFieldEnum | QuizInterventionScalarFieldEnum[]
  }

  /**
   * QuizIntervention findMany
   */
  export type QuizInterventionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizIntervention
     */
    select?: QuizInterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizIntervention
     */
    omit?: QuizInterventionOmit<ExtArgs> | null
    /**
     * Filter, which QuizInterventions to fetch.
     */
    where?: QuizInterventionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizInterventions to fetch.
     */
    orderBy?: QuizInterventionOrderByWithRelationInput | QuizInterventionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizInterventions.
     */
    cursor?: QuizInterventionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizInterventions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizInterventions.
     */
    skip?: number
    distinct?: QuizInterventionScalarFieldEnum | QuizInterventionScalarFieldEnum[]
  }

  /**
   * QuizIntervention create
   */
  export type QuizInterventionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizIntervention
     */
    select?: QuizInterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizIntervention
     */
    omit?: QuizInterventionOmit<ExtArgs> | null
    /**
     * The data needed to create a QuizIntervention.
     */
    data: XOR<QuizInterventionCreateInput, QuizInterventionUncheckedCreateInput>
  }

  /**
   * QuizIntervention createMany
   */
  export type QuizInterventionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizInterventions.
     */
    data: QuizInterventionCreateManyInput | QuizInterventionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizIntervention createManyAndReturn
   */
  export type QuizInterventionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizIntervention
     */
    select?: QuizInterventionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizIntervention
     */
    omit?: QuizInterventionOmit<ExtArgs> | null
    /**
     * The data used to create many QuizInterventions.
     */
    data: QuizInterventionCreateManyInput | QuizInterventionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizIntervention update
   */
  export type QuizInterventionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizIntervention
     */
    select?: QuizInterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizIntervention
     */
    omit?: QuizInterventionOmit<ExtArgs> | null
    /**
     * The data needed to update a QuizIntervention.
     */
    data: XOR<QuizInterventionUpdateInput, QuizInterventionUncheckedUpdateInput>
    /**
     * Choose, which QuizIntervention to update.
     */
    where: QuizInterventionWhereUniqueInput
  }

  /**
   * QuizIntervention updateMany
   */
  export type QuizInterventionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizInterventions.
     */
    data: XOR<QuizInterventionUpdateManyMutationInput, QuizInterventionUncheckedUpdateManyInput>
    /**
     * Filter which QuizInterventions to update
     */
    where?: QuizInterventionWhereInput
    /**
     * Limit how many QuizInterventions to update.
     */
    limit?: number
  }

  /**
   * QuizIntervention updateManyAndReturn
   */
  export type QuizInterventionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizIntervention
     */
    select?: QuizInterventionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizIntervention
     */
    omit?: QuizInterventionOmit<ExtArgs> | null
    /**
     * The data used to update QuizInterventions.
     */
    data: XOR<QuizInterventionUpdateManyMutationInput, QuizInterventionUncheckedUpdateManyInput>
    /**
     * Filter which QuizInterventions to update
     */
    where?: QuizInterventionWhereInput
    /**
     * Limit how many QuizInterventions to update.
     */
    limit?: number
  }

  /**
   * QuizIntervention upsert
   */
  export type QuizInterventionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizIntervention
     */
    select?: QuizInterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizIntervention
     */
    omit?: QuizInterventionOmit<ExtArgs> | null
    /**
     * The filter to search for the QuizIntervention to update in case it exists.
     */
    where: QuizInterventionWhereUniqueInput
    /**
     * In case the QuizIntervention found by the `where` argument doesn't exist, create a new QuizIntervention with this data.
     */
    create: XOR<QuizInterventionCreateInput, QuizInterventionUncheckedCreateInput>
    /**
     * In case the QuizIntervention was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizInterventionUpdateInput, QuizInterventionUncheckedUpdateInput>
  }

  /**
   * QuizIntervention delete
   */
  export type QuizInterventionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizIntervention
     */
    select?: QuizInterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizIntervention
     */
    omit?: QuizInterventionOmit<ExtArgs> | null
    /**
     * Filter which QuizIntervention to delete.
     */
    where: QuizInterventionWhereUniqueInput
  }

  /**
   * QuizIntervention deleteMany
   */
  export type QuizInterventionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizInterventions to delete
     */
    where?: QuizInterventionWhereInput
    /**
     * Limit how many QuizInterventions to delete.
     */
    limit?: number
  }

  /**
   * QuizIntervention without action
   */
  export type QuizInterventionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizIntervention
     */
    select?: QuizInterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizIntervention
     */
    omit?: QuizInterventionOmit<ExtArgs> | null
  }


  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceAvgAggregateOutputType = {
    basePrice: number | null
    leadTime: number | null
  }

  export type ServiceSumAggregateOutputType = {
    basePrice: number | null
    leadTime: number | null
  }

  export type ServiceMinAggregateOutputType = {
    id: string | null
    serviceCode: string | null
    name: string | null
    description: string | null
    category: string | null
    basePrice: number | null
    pricingModel: string | null
    currency: string | null
    leadTime: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: string | null
    serviceCode: string | null
    name: string | null
    description: string | null
    category: string | null
    basePrice: number | null
    pricingModel: string | null
    currency: string | null
    leadTime: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    serviceCode: number
    name: number
    description: number
    category: number
    basePrice: number
    pricingModel: number
    currency: number
    specifications: number
    portfolio: number
    leadTime: number
    capacity: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceAvgAggregateInputType = {
    basePrice?: true
    leadTime?: true
  }

  export type ServiceSumAggregateInputType = {
    basePrice?: true
    leadTime?: true
  }

  export type ServiceMinAggregateInputType = {
    id?: true
    serviceCode?: true
    name?: true
    description?: true
    category?: true
    basePrice?: true
    pricingModel?: true
    currency?: true
    leadTime?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    serviceCode?: true
    name?: true
    description?: true
    category?: true
    basePrice?: true
    pricingModel?: true
    currency?: true
    leadTime?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    serviceCode?: true
    name?: true
    description?: true
    category?: true
    basePrice?: true
    pricingModel?: true
    currency?: true
    specifications?: true
    portfolio?: true
    leadTime?: true
    capacity?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _avg?: ServiceAvgAggregateInputType
    _sum?: ServiceSumAggregateInputType
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: string
    serviceCode: string
    name: string
    description: string | null
    category: string
    basePrice: number | null
    pricingModel: string
    currency: string
    specifications: JsonValue | null
    portfolio: JsonValue | null
    leadTime: number | null
    capacity: JsonValue | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceCode?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    basePrice?: boolean
    pricingModel?: boolean
    currency?: boolean
    specifications?: boolean
    portfolio?: boolean
    leadTime?: boolean
    capacity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projects?: boolean | Service$projectsArgs<ExtArgs>
    quotes?: boolean | Service$quotesArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceCode?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    basePrice?: boolean
    pricingModel?: boolean
    currency?: boolean
    specifications?: boolean
    portfolio?: boolean
    leadTime?: boolean
    capacity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceCode?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    basePrice?: boolean
    pricingModel?: boolean
    currency?: boolean
    specifications?: boolean
    portfolio?: boolean
    leadTime?: boolean
    capacity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    id?: boolean
    serviceCode?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    basePrice?: boolean
    pricingModel?: boolean
    currency?: boolean
    specifications?: boolean
    portfolio?: boolean
    leadTime?: boolean
    capacity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "serviceCode" | "name" | "description" | "category" | "basePrice" | "pricingModel" | "currency" | "specifications" | "portfolio" | "leadTime" | "capacity" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["service"]>
  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | Service$projectsArgs<ExtArgs>
    quotes?: boolean | Service$quotesArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      projects: Prisma.$ProjectPayload<ExtArgs>[]
      quotes: Prisma.$QuotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      serviceCode: string
      name: string
      description: string | null
      category: string
      basePrice: number | null
      pricingModel: string
      currency: string
      specifications: Prisma.JsonValue | null
      portfolio: Prisma.JsonValue | null
      leadTime: number | null
      capacity: Prisma.JsonValue | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Services and returns the data saved in the database.
     * @param {ServiceCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services and returns the data updated in the database.
     * @param {ServiceUpdateManyAndReturnArgs} args - Arguments to update many Services.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projects<T extends Service$projectsArgs<ExtArgs> = {}>(args?: Subset<T, Service$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quotes<T extends Service$quotesArgs<ExtArgs> = {}>(args?: Subset<T, Service$quotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'String'>
    readonly serviceCode: FieldRef<"Service", 'String'>
    readonly name: FieldRef<"Service", 'String'>
    readonly description: FieldRef<"Service", 'String'>
    readonly category: FieldRef<"Service", 'String'>
    readonly basePrice: FieldRef<"Service", 'Float'>
    readonly pricingModel: FieldRef<"Service", 'String'>
    readonly currency: FieldRef<"Service", 'String'>
    readonly specifications: FieldRef<"Service", 'Json'>
    readonly portfolio: FieldRef<"Service", 'Json'>
    readonly leadTime: FieldRef<"Service", 'Int'>
    readonly capacity: FieldRef<"Service", 'Json'>
    readonly isActive: FieldRef<"Service", 'Boolean'>
    readonly createdAt: FieldRef<"Service", 'DateTime'>
    readonly updatedAt: FieldRef<"Service", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service createManyAndReturn
   */
  export type ServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Service updateManyAndReturn
   */
  export type ServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to delete.
     */
    limit?: number
  }

  /**
   * Service.projects
   */
  export type Service$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Service.quotes
   */
  export type Service$quotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    where?: QuoteWhereInput
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    cursor?: QuoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectAvgAggregateOutputType = {
    quotedAmount: number | null
    actualCost: number | null
    invoicedAmount: number | null
    paidAmount: number | null
  }

  export type ProjectSumAggregateOutputType = {
    quotedAmount: number | null
    actualCost: number | null
    invoicedAmount: number | null
    paidAmount: number | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    projectRef: string | null
    clientId: string | null
    name: string | null
    description: string | null
    service: string | null
    status: string | null
    currentStage: string | null
    quotedAmount: number | null
    actualCost: number | null
    invoicedAmount: number | null
    paidAmount: number | null
    startDate: Date | null
    targetDate: Date | null
    completedDate: Date | null
    location: string | null
    notes: string | null
    priority: string | null
    orderId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    serviceId: string | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    projectRef: string | null
    clientId: string | null
    name: string | null
    description: string | null
    service: string | null
    status: string | null
    currentStage: string | null
    quotedAmount: number | null
    actualCost: number | null
    invoicedAmount: number | null
    paidAmount: number | null
    startDate: Date | null
    targetDate: Date | null
    completedDate: Date | null
    location: string | null
    notes: string | null
    priority: string | null
    orderId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    serviceId: string | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    projectRef: number
    clientId: number
    name: number
    description: number
    service: number
    status: number
    currentStage: number
    stagesCompleted: number
    quotedAmount: number
    actualCost: number
    invoicedAmount: number
    paidAmount: number
    startDate: number
    targetDate: number
    completedDate: number
    location: number
    notes: number
    priority: number
    orderId: number
    createdAt: number
    updatedAt: number
    serviceId: number
    _all: number
  }


  export type ProjectAvgAggregateInputType = {
    quotedAmount?: true
    actualCost?: true
    invoicedAmount?: true
    paidAmount?: true
  }

  export type ProjectSumAggregateInputType = {
    quotedAmount?: true
    actualCost?: true
    invoicedAmount?: true
    paidAmount?: true
  }

  export type ProjectMinAggregateInputType = {
    id?: true
    projectRef?: true
    clientId?: true
    name?: true
    description?: true
    service?: true
    status?: true
    currentStage?: true
    quotedAmount?: true
    actualCost?: true
    invoicedAmount?: true
    paidAmount?: true
    startDate?: true
    targetDate?: true
    completedDate?: true
    location?: true
    notes?: true
    priority?: true
    orderId?: true
    createdAt?: true
    updatedAt?: true
    serviceId?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    projectRef?: true
    clientId?: true
    name?: true
    description?: true
    service?: true
    status?: true
    currentStage?: true
    quotedAmount?: true
    actualCost?: true
    invoicedAmount?: true
    paidAmount?: true
    startDate?: true
    targetDate?: true
    completedDate?: true
    location?: true
    notes?: true
    priority?: true
    orderId?: true
    createdAt?: true
    updatedAt?: true
    serviceId?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    projectRef?: true
    clientId?: true
    name?: true
    description?: true
    service?: true
    status?: true
    currentStage?: true
    stagesCompleted?: true
    quotedAmount?: true
    actualCost?: true
    invoicedAmount?: true
    paidAmount?: true
    startDate?: true
    targetDate?: true
    completedDate?: true
    location?: true
    notes?: true
    priority?: true
    orderId?: true
    createdAt?: true
    updatedAt?: true
    serviceId?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _avg?: ProjectAvgAggregateInputType
    _sum?: ProjectSumAggregateInputType
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    projectRef: string
    clientId: string
    name: string
    description: string | null
    service: string
    status: string
    currentStage: string
    stagesCompleted: string[]
    quotedAmount: number | null
    actualCost: number | null
    invoicedAmount: number | null
    paidAmount: number | null
    startDate: Date | null
    targetDate: Date | null
    completedDate: Date | null
    location: string | null
    notes: string | null
    priority: string
    orderId: string | null
    createdAt: Date
    updatedAt: Date
    serviceId: string | null
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectRef?: boolean
    clientId?: boolean
    name?: boolean
    description?: boolean
    service?: boolean
    status?: boolean
    currentStage?: boolean
    stagesCompleted?: boolean
    quotedAmount?: boolean
    actualCost?: boolean
    invoicedAmount?: boolean
    paidAmount?: boolean
    startDate?: boolean
    targetDate?: boolean
    completedDate?: boolean
    location?: boolean
    notes?: boolean
    priority?: boolean
    orderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serviceId?: boolean
    client?: boolean | CustomerDefaultArgs<ExtArgs>
    documents?: boolean | Project$documentsArgs<ExtArgs>
    stages?: boolean | Project$stagesArgs<ExtArgs>
    costs?: boolean | Project$costsArgs<ExtArgs>
    order?: boolean | Project$orderArgs<ExtArgs>
    Service?: boolean | Project$ServiceArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectRef?: boolean
    clientId?: boolean
    name?: boolean
    description?: boolean
    service?: boolean
    status?: boolean
    currentStage?: boolean
    stagesCompleted?: boolean
    quotedAmount?: boolean
    actualCost?: boolean
    invoicedAmount?: boolean
    paidAmount?: boolean
    startDate?: boolean
    targetDate?: boolean
    completedDate?: boolean
    location?: boolean
    notes?: boolean
    priority?: boolean
    orderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serviceId?: boolean
    client?: boolean | CustomerDefaultArgs<ExtArgs>
    order?: boolean | Project$orderArgs<ExtArgs>
    Service?: boolean | Project$ServiceArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectRef?: boolean
    clientId?: boolean
    name?: boolean
    description?: boolean
    service?: boolean
    status?: boolean
    currentStage?: boolean
    stagesCompleted?: boolean
    quotedAmount?: boolean
    actualCost?: boolean
    invoicedAmount?: boolean
    paidAmount?: boolean
    startDate?: boolean
    targetDate?: boolean
    completedDate?: boolean
    location?: boolean
    notes?: boolean
    priority?: boolean
    orderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serviceId?: boolean
    client?: boolean | CustomerDefaultArgs<ExtArgs>
    order?: boolean | Project$orderArgs<ExtArgs>
    Service?: boolean | Project$ServiceArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    projectRef?: boolean
    clientId?: boolean
    name?: boolean
    description?: boolean
    service?: boolean
    status?: boolean
    currentStage?: boolean
    stagesCompleted?: boolean
    quotedAmount?: boolean
    actualCost?: boolean
    invoicedAmount?: boolean
    paidAmount?: boolean
    startDate?: boolean
    targetDate?: boolean
    completedDate?: boolean
    location?: boolean
    notes?: boolean
    priority?: boolean
    orderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serviceId?: boolean
  }

  export type ProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectRef" | "clientId" | "name" | "description" | "service" | "status" | "currentStage" | "stagesCompleted" | "quotedAmount" | "actualCost" | "invoicedAmount" | "paidAmount" | "startDate" | "targetDate" | "completedDate" | "location" | "notes" | "priority" | "orderId" | "createdAt" | "updatedAt" | "serviceId", ExtArgs["result"]["project"]>
  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | CustomerDefaultArgs<ExtArgs>
    documents?: boolean | Project$documentsArgs<ExtArgs>
    stages?: boolean | Project$stagesArgs<ExtArgs>
    costs?: boolean | Project$costsArgs<ExtArgs>
    order?: boolean | Project$orderArgs<ExtArgs>
    Service?: boolean | Project$ServiceArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | CustomerDefaultArgs<ExtArgs>
    order?: boolean | Project$orderArgs<ExtArgs>
    Service?: boolean | Project$ServiceArgs<ExtArgs>
  }
  export type ProjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | CustomerDefaultArgs<ExtArgs>
    order?: boolean | Project$orderArgs<ExtArgs>
    Service?: boolean | Project$ServiceArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      client: Prisma.$CustomerPayload<ExtArgs>
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      stages: Prisma.$ProjectStagePayload<ExtArgs>[]
      costs: Prisma.$MaterialCostPayload<ExtArgs>[]
      order: Prisma.$OrderPayload<ExtArgs> | null
      Service: Prisma.$ServicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectRef: string
      clientId: string
      name: string
      description: string | null
      service: string
      status: string
      currentStage: string
      stagesCompleted: string[]
      quotedAmount: number | null
      actualCost: number | null
      invoicedAmount: number | null
      paidAmount: number | null
      startDate: Date | null
      targetDate: Date | null
      completedDate: Date | null
      location: string | null
      notes: string | null
      priority: string
      orderId: string | null
      createdAt: Date
      updatedAt: Date
      serviceId: string | null
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects and returns the data updated in the database.
     * @param {ProjectUpdateManyAndReturnArgs} args - Arguments to update many Projects.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    documents<T extends Project$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Project$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stages<T extends Project$stagesArgs<ExtArgs> = {}>(args?: Subset<T, Project$stagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectStagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    costs<T extends Project$costsArgs<ExtArgs> = {}>(args?: Subset<T, Project$costsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialCostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    order<T extends Project$orderArgs<ExtArgs> = {}>(args?: Subset<T, Project$orderArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Service<T extends Project$ServiceArgs<ExtArgs> = {}>(args?: Subset<T, Project$ServiceArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly projectRef: FieldRef<"Project", 'String'>
    readonly clientId: FieldRef<"Project", 'String'>
    readonly name: FieldRef<"Project", 'String'>
    readonly description: FieldRef<"Project", 'String'>
    readonly service: FieldRef<"Project", 'String'>
    readonly status: FieldRef<"Project", 'String'>
    readonly currentStage: FieldRef<"Project", 'String'>
    readonly stagesCompleted: FieldRef<"Project", 'String[]'>
    readonly quotedAmount: FieldRef<"Project", 'Float'>
    readonly actualCost: FieldRef<"Project", 'Float'>
    readonly invoicedAmount: FieldRef<"Project", 'Float'>
    readonly paidAmount: FieldRef<"Project", 'Float'>
    readonly startDate: FieldRef<"Project", 'DateTime'>
    readonly targetDate: FieldRef<"Project", 'DateTime'>
    readonly completedDate: FieldRef<"Project", 'DateTime'>
    readonly location: FieldRef<"Project", 'String'>
    readonly notes: FieldRef<"Project", 'String'>
    readonly priority: FieldRef<"Project", 'String'>
    readonly orderId: FieldRef<"Project", 'String'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
    readonly serviceId: FieldRef<"Project", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
  }

  /**
   * Project updateManyAndReturn
   */
  export type ProjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to delete.
     */
    limit?: number
  }

  /**
   * Project.documents
   */
  export type Project$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Project.stages
   */
  export type Project$stagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStage
     */
    select?: ProjectStageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStage
     */
    omit?: ProjectStageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStageInclude<ExtArgs> | null
    where?: ProjectStageWhereInput
    orderBy?: ProjectStageOrderByWithRelationInput | ProjectStageOrderByWithRelationInput[]
    cursor?: ProjectStageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectStageScalarFieldEnum | ProjectStageScalarFieldEnum[]
  }

  /**
   * Project.costs
   */
  export type Project$costsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialCost
     */
    select?: MaterialCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialCost
     */
    omit?: MaterialCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialCostInclude<ExtArgs> | null
    where?: MaterialCostWhereInput
    orderBy?: MaterialCostOrderByWithRelationInput | MaterialCostOrderByWithRelationInput[]
    cursor?: MaterialCostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialCostScalarFieldEnum | MaterialCostScalarFieldEnum[]
  }

  /**
   * Project.order
   */
  export type Project$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
  }

  /**
   * Project.Service
   */
  export type Project$ServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model ProjectStage
   */

  export type AggregateProjectStage = {
    _count: ProjectStageCountAggregateOutputType | null
    _avg: ProjectStageAvgAggregateOutputType | null
    _sum: ProjectStageSumAggregateOutputType | null
    _min: ProjectStageMinAggregateOutputType | null
    _max: ProjectStageMaxAggregateOutputType | null
  }

  export type ProjectStageAvgAggregateOutputType = {
    order: number | null
  }

  export type ProjectStageSumAggregateOutputType = {
    order: number | null
  }

  export type ProjectStageMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    stageName: string | null
    status: string | null
    notes: string | null
    completedAt: Date | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectStageMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    stageName: string | null
    status: string | null
    notes: string | null
    completedAt: Date | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectStageCountAggregateOutputType = {
    id: number
    projectId: number
    stageName: number
    status: number
    notes: number
    completedAt: number
    order: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectStageAvgAggregateInputType = {
    order?: true
  }

  export type ProjectStageSumAggregateInputType = {
    order?: true
  }

  export type ProjectStageMinAggregateInputType = {
    id?: true
    projectId?: true
    stageName?: true
    status?: true
    notes?: true
    completedAt?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectStageMaxAggregateInputType = {
    id?: true
    projectId?: true
    stageName?: true
    status?: true
    notes?: true
    completedAt?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectStageCountAggregateInputType = {
    id?: true
    projectId?: true
    stageName?: true
    status?: true
    notes?: true
    completedAt?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectStageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectStage to aggregate.
     */
    where?: ProjectStageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectStages to fetch.
     */
    orderBy?: ProjectStageOrderByWithRelationInput | ProjectStageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectStageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectStages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectStages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectStages
    **/
    _count?: true | ProjectStageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectStageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectStageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectStageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectStageMaxAggregateInputType
  }

  export type GetProjectStageAggregateType<T extends ProjectStageAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectStage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectStage[P]>
      : GetScalarType<T[P], AggregateProjectStage[P]>
  }




  export type ProjectStageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectStageWhereInput
    orderBy?: ProjectStageOrderByWithAggregationInput | ProjectStageOrderByWithAggregationInput[]
    by: ProjectStageScalarFieldEnum[] | ProjectStageScalarFieldEnum
    having?: ProjectStageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectStageCountAggregateInputType | true
    _avg?: ProjectStageAvgAggregateInputType
    _sum?: ProjectStageSumAggregateInputType
    _min?: ProjectStageMinAggregateInputType
    _max?: ProjectStageMaxAggregateInputType
  }

  export type ProjectStageGroupByOutputType = {
    id: string
    projectId: string
    stageName: string
    status: string
    notes: string | null
    completedAt: Date | null
    order: number
    createdAt: Date
    updatedAt: Date
    _count: ProjectStageCountAggregateOutputType | null
    _avg: ProjectStageAvgAggregateOutputType | null
    _sum: ProjectStageSumAggregateOutputType | null
    _min: ProjectStageMinAggregateOutputType | null
    _max: ProjectStageMaxAggregateOutputType | null
  }

  type GetProjectStageGroupByPayload<T extends ProjectStageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectStageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectStageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectStageGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectStageGroupByOutputType[P]>
        }
      >
    >


  export type ProjectStageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    stageName?: boolean
    status?: boolean
    notes?: boolean
    completedAt?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectStage"]>

  export type ProjectStageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    stageName?: boolean
    status?: boolean
    notes?: boolean
    completedAt?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectStage"]>

  export type ProjectStageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    stageName?: boolean
    status?: boolean
    notes?: boolean
    completedAt?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectStage"]>

  export type ProjectStageSelectScalar = {
    id?: boolean
    projectId?: boolean
    stageName?: boolean
    status?: boolean
    notes?: boolean
    completedAt?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectStageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "stageName" | "status" | "notes" | "completedAt" | "order" | "createdAt" | "updatedAt", ExtArgs["result"]["projectStage"]>
  export type ProjectStageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ProjectStageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ProjectStageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ProjectStagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectStage"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      stageName: string
      status: string
      notes: string | null
      completedAt: Date | null
      order: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["projectStage"]>
    composites: {}
  }

  type ProjectStageGetPayload<S extends boolean | null | undefined | ProjectStageDefaultArgs> = $Result.GetResult<Prisma.$ProjectStagePayload, S>

  type ProjectStageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectStageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectStageCountAggregateInputType | true
    }

  export interface ProjectStageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectStage'], meta: { name: 'ProjectStage' } }
    /**
     * Find zero or one ProjectStage that matches the filter.
     * @param {ProjectStageFindUniqueArgs} args - Arguments to find a ProjectStage
     * @example
     * // Get one ProjectStage
     * const projectStage = await prisma.projectStage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectStageFindUniqueArgs>(args: SelectSubset<T, ProjectStageFindUniqueArgs<ExtArgs>>): Prisma__ProjectStageClient<$Result.GetResult<Prisma.$ProjectStagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectStage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectStageFindUniqueOrThrowArgs} args - Arguments to find a ProjectStage
     * @example
     * // Get one ProjectStage
     * const projectStage = await prisma.projectStage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectStageFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectStageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectStageClient<$Result.GetResult<Prisma.$ProjectStagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectStage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStageFindFirstArgs} args - Arguments to find a ProjectStage
     * @example
     * // Get one ProjectStage
     * const projectStage = await prisma.projectStage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectStageFindFirstArgs>(args?: SelectSubset<T, ProjectStageFindFirstArgs<ExtArgs>>): Prisma__ProjectStageClient<$Result.GetResult<Prisma.$ProjectStagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectStage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStageFindFirstOrThrowArgs} args - Arguments to find a ProjectStage
     * @example
     * // Get one ProjectStage
     * const projectStage = await prisma.projectStage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectStageFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectStageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectStageClient<$Result.GetResult<Prisma.$ProjectStagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectStages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectStages
     * const projectStages = await prisma.projectStage.findMany()
     * 
     * // Get first 10 ProjectStages
     * const projectStages = await prisma.projectStage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectStageWithIdOnly = await prisma.projectStage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectStageFindManyArgs>(args?: SelectSubset<T, ProjectStageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectStagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectStage.
     * @param {ProjectStageCreateArgs} args - Arguments to create a ProjectStage.
     * @example
     * // Create one ProjectStage
     * const ProjectStage = await prisma.projectStage.create({
     *   data: {
     *     // ... data to create a ProjectStage
     *   }
     * })
     * 
     */
    create<T extends ProjectStageCreateArgs>(args: SelectSubset<T, ProjectStageCreateArgs<ExtArgs>>): Prisma__ProjectStageClient<$Result.GetResult<Prisma.$ProjectStagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectStages.
     * @param {ProjectStageCreateManyArgs} args - Arguments to create many ProjectStages.
     * @example
     * // Create many ProjectStages
     * const projectStage = await prisma.projectStage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectStageCreateManyArgs>(args?: SelectSubset<T, ProjectStageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectStages and returns the data saved in the database.
     * @param {ProjectStageCreateManyAndReturnArgs} args - Arguments to create many ProjectStages.
     * @example
     * // Create many ProjectStages
     * const projectStage = await prisma.projectStage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectStages and only return the `id`
     * const projectStageWithIdOnly = await prisma.projectStage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectStageCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectStageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectStagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectStage.
     * @param {ProjectStageDeleteArgs} args - Arguments to delete one ProjectStage.
     * @example
     * // Delete one ProjectStage
     * const ProjectStage = await prisma.projectStage.delete({
     *   where: {
     *     // ... filter to delete one ProjectStage
     *   }
     * })
     * 
     */
    delete<T extends ProjectStageDeleteArgs>(args: SelectSubset<T, ProjectStageDeleteArgs<ExtArgs>>): Prisma__ProjectStageClient<$Result.GetResult<Prisma.$ProjectStagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectStage.
     * @param {ProjectStageUpdateArgs} args - Arguments to update one ProjectStage.
     * @example
     * // Update one ProjectStage
     * const projectStage = await prisma.projectStage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectStageUpdateArgs>(args: SelectSubset<T, ProjectStageUpdateArgs<ExtArgs>>): Prisma__ProjectStageClient<$Result.GetResult<Prisma.$ProjectStagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectStages.
     * @param {ProjectStageDeleteManyArgs} args - Arguments to filter ProjectStages to delete.
     * @example
     * // Delete a few ProjectStages
     * const { count } = await prisma.projectStage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectStageDeleteManyArgs>(args?: SelectSubset<T, ProjectStageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectStages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectStages
     * const projectStage = await prisma.projectStage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectStageUpdateManyArgs>(args: SelectSubset<T, ProjectStageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectStages and returns the data updated in the database.
     * @param {ProjectStageUpdateManyAndReturnArgs} args - Arguments to update many ProjectStages.
     * @example
     * // Update many ProjectStages
     * const projectStage = await prisma.projectStage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectStages and only return the `id`
     * const projectStageWithIdOnly = await prisma.projectStage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectStageUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectStageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectStagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectStage.
     * @param {ProjectStageUpsertArgs} args - Arguments to update or create a ProjectStage.
     * @example
     * // Update or create a ProjectStage
     * const projectStage = await prisma.projectStage.upsert({
     *   create: {
     *     // ... data to create a ProjectStage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectStage we want to update
     *   }
     * })
     */
    upsert<T extends ProjectStageUpsertArgs>(args: SelectSubset<T, ProjectStageUpsertArgs<ExtArgs>>): Prisma__ProjectStageClient<$Result.GetResult<Prisma.$ProjectStagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectStages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStageCountArgs} args - Arguments to filter ProjectStages to count.
     * @example
     * // Count the number of ProjectStages
     * const count = await prisma.projectStage.count({
     *   where: {
     *     // ... the filter for the ProjectStages we want to count
     *   }
     * })
    **/
    count<T extends ProjectStageCountArgs>(
      args?: Subset<T, ProjectStageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectStageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectStage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectStageAggregateArgs>(args: Subset<T, ProjectStageAggregateArgs>): Prisma.PrismaPromise<GetProjectStageAggregateType<T>>

    /**
     * Group by ProjectStage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectStageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectStageGroupByArgs['orderBy'] }
        : { orderBy?: ProjectStageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectStageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectStageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectStage model
   */
  readonly fields: ProjectStageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectStage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectStageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectStage model
   */
  interface ProjectStageFieldRefs {
    readonly id: FieldRef<"ProjectStage", 'String'>
    readonly projectId: FieldRef<"ProjectStage", 'String'>
    readonly stageName: FieldRef<"ProjectStage", 'String'>
    readonly status: FieldRef<"ProjectStage", 'String'>
    readonly notes: FieldRef<"ProjectStage", 'String'>
    readonly completedAt: FieldRef<"ProjectStage", 'DateTime'>
    readonly order: FieldRef<"ProjectStage", 'Int'>
    readonly createdAt: FieldRef<"ProjectStage", 'DateTime'>
    readonly updatedAt: FieldRef<"ProjectStage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectStage findUnique
   */
  export type ProjectStageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStage
     */
    select?: ProjectStageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStage
     */
    omit?: ProjectStageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStageInclude<ExtArgs> | null
    /**
     * Filter, which ProjectStage to fetch.
     */
    where: ProjectStageWhereUniqueInput
  }

  /**
   * ProjectStage findUniqueOrThrow
   */
  export type ProjectStageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStage
     */
    select?: ProjectStageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStage
     */
    omit?: ProjectStageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStageInclude<ExtArgs> | null
    /**
     * Filter, which ProjectStage to fetch.
     */
    where: ProjectStageWhereUniqueInput
  }

  /**
   * ProjectStage findFirst
   */
  export type ProjectStageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStage
     */
    select?: ProjectStageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStage
     */
    omit?: ProjectStageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStageInclude<ExtArgs> | null
    /**
     * Filter, which ProjectStage to fetch.
     */
    where?: ProjectStageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectStages to fetch.
     */
    orderBy?: ProjectStageOrderByWithRelationInput | ProjectStageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectStages.
     */
    cursor?: ProjectStageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectStages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectStages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectStages.
     */
    distinct?: ProjectStageScalarFieldEnum | ProjectStageScalarFieldEnum[]
  }

  /**
   * ProjectStage findFirstOrThrow
   */
  export type ProjectStageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStage
     */
    select?: ProjectStageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStage
     */
    omit?: ProjectStageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStageInclude<ExtArgs> | null
    /**
     * Filter, which ProjectStage to fetch.
     */
    where?: ProjectStageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectStages to fetch.
     */
    orderBy?: ProjectStageOrderByWithRelationInput | ProjectStageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectStages.
     */
    cursor?: ProjectStageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectStages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectStages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectStages.
     */
    distinct?: ProjectStageScalarFieldEnum | ProjectStageScalarFieldEnum[]
  }

  /**
   * ProjectStage findMany
   */
  export type ProjectStageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStage
     */
    select?: ProjectStageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStage
     */
    omit?: ProjectStageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStageInclude<ExtArgs> | null
    /**
     * Filter, which ProjectStages to fetch.
     */
    where?: ProjectStageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectStages to fetch.
     */
    orderBy?: ProjectStageOrderByWithRelationInput | ProjectStageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectStages.
     */
    cursor?: ProjectStageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectStages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectStages.
     */
    skip?: number
    distinct?: ProjectStageScalarFieldEnum | ProjectStageScalarFieldEnum[]
  }

  /**
   * ProjectStage create
   */
  export type ProjectStageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStage
     */
    select?: ProjectStageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStage
     */
    omit?: ProjectStageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStageInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectStage.
     */
    data: XOR<ProjectStageCreateInput, ProjectStageUncheckedCreateInput>
  }

  /**
   * ProjectStage createMany
   */
  export type ProjectStageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectStages.
     */
    data: ProjectStageCreateManyInput | ProjectStageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectStage createManyAndReturn
   */
  export type ProjectStageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStage
     */
    select?: ProjectStageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStage
     */
    omit?: ProjectStageOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectStages.
     */
    data: ProjectStageCreateManyInput | ProjectStageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectStage update
   */
  export type ProjectStageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStage
     */
    select?: ProjectStageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStage
     */
    omit?: ProjectStageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStageInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectStage.
     */
    data: XOR<ProjectStageUpdateInput, ProjectStageUncheckedUpdateInput>
    /**
     * Choose, which ProjectStage to update.
     */
    where: ProjectStageWhereUniqueInput
  }

  /**
   * ProjectStage updateMany
   */
  export type ProjectStageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectStages.
     */
    data: XOR<ProjectStageUpdateManyMutationInput, ProjectStageUncheckedUpdateManyInput>
    /**
     * Filter which ProjectStages to update
     */
    where?: ProjectStageWhereInput
    /**
     * Limit how many ProjectStages to update.
     */
    limit?: number
  }

  /**
   * ProjectStage updateManyAndReturn
   */
  export type ProjectStageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStage
     */
    select?: ProjectStageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStage
     */
    omit?: ProjectStageOmit<ExtArgs> | null
    /**
     * The data used to update ProjectStages.
     */
    data: XOR<ProjectStageUpdateManyMutationInput, ProjectStageUncheckedUpdateManyInput>
    /**
     * Filter which ProjectStages to update
     */
    where?: ProjectStageWhereInput
    /**
     * Limit how many ProjectStages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectStage upsert
   */
  export type ProjectStageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStage
     */
    select?: ProjectStageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStage
     */
    omit?: ProjectStageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStageInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectStage to update in case it exists.
     */
    where: ProjectStageWhereUniqueInput
    /**
     * In case the ProjectStage found by the `where` argument doesn't exist, create a new ProjectStage with this data.
     */
    create: XOR<ProjectStageCreateInput, ProjectStageUncheckedCreateInput>
    /**
     * In case the ProjectStage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectStageUpdateInput, ProjectStageUncheckedUpdateInput>
  }

  /**
   * ProjectStage delete
   */
  export type ProjectStageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStage
     */
    select?: ProjectStageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStage
     */
    omit?: ProjectStageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStageInclude<ExtArgs> | null
    /**
     * Filter which ProjectStage to delete.
     */
    where: ProjectStageWhereUniqueInput
  }

  /**
   * ProjectStage deleteMany
   */
  export type ProjectStageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectStages to delete
     */
    where?: ProjectStageWhereInput
    /**
     * Limit how many ProjectStages to delete.
     */
    limit?: number
  }

  /**
   * ProjectStage without action
   */
  export type ProjectStageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStage
     */
    select?: ProjectStageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStage
     */
    omit?: ProjectStageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStageInclude<ExtArgs> | null
  }


  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type DocumentSumAggregateOutputType = {
    fileSize: number | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    filename: string | null
    originalName: string | null
    fileType: string | null
    fileSize: number | null
    fileUrl: string | null
    uploadedAt: Date | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    filename: string | null
    originalName: string | null
    fileType: string | null
    fileSize: number | null
    fileUrl: string | null
    uploadedAt: Date | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    projectId: number
    filename: number
    originalName: number
    fileType: number
    fileSize: number
    fileUrl: number
    uploadedAt: number
    _all: number
  }


  export type DocumentAvgAggregateInputType = {
    fileSize?: true
  }

  export type DocumentSumAggregateInputType = {
    fileSize?: true
  }

  export type DocumentMinAggregateInputType = {
    id?: true
    projectId?: true
    filename?: true
    originalName?: true
    fileType?: true
    fileSize?: true
    fileUrl?: true
    uploadedAt?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    projectId?: true
    filename?: true
    originalName?: true
    fileType?: true
    fileSize?: true
    fileUrl?: true
    uploadedAt?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    projectId?: true
    filename?: true
    originalName?: true
    fileType?: true
    fileSize?: true
    fileUrl?: true
    uploadedAt?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _avg?: DocumentAvgAggregateInputType
    _sum?: DocumentSumAggregateInputType
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: string
    projectId: string
    filename: string
    originalName: string
    fileType: string
    fileSize: number | null
    fileUrl: string | null
    uploadedAt: Date
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    filename?: boolean
    originalName?: boolean
    fileType?: boolean
    fileSize?: boolean
    fileUrl?: boolean
    uploadedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    generations?: boolean | Document$generationsArgs<ExtArgs>
    _count?: boolean | DocumentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    filename?: boolean
    originalName?: boolean
    fileType?: boolean
    fileSize?: boolean
    fileUrl?: boolean
    uploadedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    filename?: boolean
    originalName?: boolean
    fileType?: boolean
    fileSize?: boolean
    fileUrl?: boolean
    uploadedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    projectId?: boolean
    filename?: boolean
    originalName?: boolean
    fileType?: boolean
    fileSize?: boolean
    fileUrl?: boolean
    uploadedAt?: boolean
  }

  export type DocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "filename" | "originalName" | "fileType" | "fileSize" | "fileUrl" | "uploadedAt", ExtArgs["result"]["document"]>
  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    generations?: boolean | Document$generationsArgs<ExtArgs>
    _count?: boolean | DocumentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type DocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      generations: Prisma.$DocumentGenerationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      filename: string
      originalName: string
      fileType: string
      fileSize: number | null
      fileUrl: string | null
      uploadedAt: Date
    }, ExtArgs["result"]["document"]>
    composites: {}
  }

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFindManyArgs>(args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
     */
    create<T extends DocumentCreateArgs>(args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCreateManyArgs>(args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {DocumentCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
     */
    delete<T extends DocumentDeleteArgs>(args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUpdateArgs>(args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentDeleteManyArgs>(args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUpdateManyArgs>(args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents and returns the data updated in the database.
     * @param {DocumentUpdateManyAndReturnArgs} args - Arguments to update many Documents.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    generations<T extends Document$generationsArgs<ExtArgs> = {}>(args?: Subset<T, Document$generationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentGenerationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Document model
   */
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'String'>
    readonly projectId: FieldRef<"Document", 'String'>
    readonly filename: FieldRef<"Document", 'String'>
    readonly originalName: FieldRef<"Document", 'String'>
    readonly fileType: FieldRef<"Document", 'String'>
    readonly fileSize: FieldRef<"Document", 'Int'>
    readonly fileUrl: FieldRef<"Document", 'String'>
    readonly uploadedAt: FieldRef<"Document", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Document createManyAndReturn
   */
  export type DocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
  }

  /**
   * Document updateManyAndReturn
   */
  export type DocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to delete.
     */
    limit?: number
  }

  /**
   * Document.generations
   */
  export type Document$generationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentGeneration
     */
    select?: DocumentGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentGeneration
     */
    omit?: DocumentGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentGenerationInclude<ExtArgs> | null
    where?: DocumentGenerationWhereInput
    orderBy?: DocumentGenerationOrderByWithRelationInput | DocumentGenerationOrderByWithRelationInput[]
    cursor?: DocumentGenerationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentGenerationScalarFieldEnum | DocumentGenerationScalarFieldEnum[]
  }

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
  }


  /**
   * Model DocumentGeneration
   */

  export type AggregateDocumentGeneration = {
    _count: DocumentGenerationCountAggregateOutputType | null
    _min: DocumentGenerationMinAggregateOutputType | null
    _max: DocumentGenerationMaxAggregateOutputType | null
  }

  export type DocumentGenerationMinAggregateOutputType = {
    id: string | null
    documentId: string | null
    documentType: string | null
    documentNumber: string | null
    templateData: string | null
    status: string | null
    generatedBy: string | null
    generatedAt: Date | null
    autoSend: boolean | null
    emailSent: boolean | null
    emailSentAt: Date | null
    recipientEmail: string | null
    fileUrl: string | null
    errorMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentGenerationMaxAggregateOutputType = {
    id: string | null
    documentId: string | null
    documentType: string | null
    documentNumber: string | null
    templateData: string | null
    status: string | null
    generatedBy: string | null
    generatedAt: Date | null
    autoSend: boolean | null
    emailSent: boolean | null
    emailSentAt: Date | null
    recipientEmail: string | null
    fileUrl: string | null
    errorMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentGenerationCountAggregateOutputType = {
    id: number
    documentId: number
    documentType: number
    documentNumber: number
    templateData: number
    status: number
    generatedBy: number
    generatedAt: number
    autoSend: number
    emailSent: number
    emailSentAt: number
    recipientEmail: number
    fileUrl: number
    errorMessage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DocumentGenerationMinAggregateInputType = {
    id?: true
    documentId?: true
    documentType?: true
    documentNumber?: true
    templateData?: true
    status?: true
    generatedBy?: true
    generatedAt?: true
    autoSend?: true
    emailSent?: true
    emailSentAt?: true
    recipientEmail?: true
    fileUrl?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentGenerationMaxAggregateInputType = {
    id?: true
    documentId?: true
    documentType?: true
    documentNumber?: true
    templateData?: true
    status?: true
    generatedBy?: true
    generatedAt?: true
    autoSend?: true
    emailSent?: true
    emailSentAt?: true
    recipientEmail?: true
    fileUrl?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentGenerationCountAggregateInputType = {
    id?: true
    documentId?: true
    documentType?: true
    documentNumber?: true
    templateData?: true
    status?: true
    generatedBy?: true
    generatedAt?: true
    autoSend?: true
    emailSent?: true
    emailSentAt?: true
    recipientEmail?: true
    fileUrl?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DocumentGenerationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentGeneration to aggregate.
     */
    where?: DocumentGenerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentGenerations to fetch.
     */
    orderBy?: DocumentGenerationOrderByWithRelationInput | DocumentGenerationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentGenerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentGenerations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentGenerations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentGenerations
    **/
    _count?: true | DocumentGenerationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentGenerationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentGenerationMaxAggregateInputType
  }

  export type GetDocumentGenerationAggregateType<T extends DocumentGenerationAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentGeneration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentGeneration[P]>
      : GetScalarType<T[P], AggregateDocumentGeneration[P]>
  }




  export type DocumentGenerationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentGenerationWhereInput
    orderBy?: DocumentGenerationOrderByWithAggregationInput | DocumentGenerationOrderByWithAggregationInput[]
    by: DocumentGenerationScalarFieldEnum[] | DocumentGenerationScalarFieldEnum
    having?: DocumentGenerationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentGenerationCountAggregateInputType | true
    _min?: DocumentGenerationMinAggregateInputType
    _max?: DocumentGenerationMaxAggregateInputType
  }

  export type DocumentGenerationGroupByOutputType = {
    id: string
    documentId: string
    documentType: string
    documentNumber: string
    templateData: string
    status: string
    generatedBy: string | null
    generatedAt: Date | null
    autoSend: boolean
    emailSent: boolean
    emailSentAt: Date | null
    recipientEmail: string | null
    fileUrl: string | null
    errorMessage: string | null
    createdAt: Date
    updatedAt: Date
    _count: DocumentGenerationCountAggregateOutputType | null
    _min: DocumentGenerationMinAggregateOutputType | null
    _max: DocumentGenerationMaxAggregateOutputType | null
  }

  type GetDocumentGenerationGroupByPayload<T extends DocumentGenerationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGenerationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGenerationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGenerationGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGenerationGroupByOutputType[P]>
        }
      >
    >


  export type DocumentGenerationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    documentType?: boolean
    documentNumber?: boolean
    templateData?: boolean
    status?: boolean
    generatedBy?: boolean
    generatedAt?: boolean
    autoSend?: boolean
    emailSent?: boolean
    emailSentAt?: boolean
    recipientEmail?: boolean
    fileUrl?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentGeneration"]>

  export type DocumentGenerationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    documentType?: boolean
    documentNumber?: boolean
    templateData?: boolean
    status?: boolean
    generatedBy?: boolean
    generatedAt?: boolean
    autoSend?: boolean
    emailSent?: boolean
    emailSentAt?: boolean
    recipientEmail?: boolean
    fileUrl?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentGeneration"]>

  export type DocumentGenerationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    documentType?: boolean
    documentNumber?: boolean
    templateData?: boolean
    status?: boolean
    generatedBy?: boolean
    generatedAt?: boolean
    autoSend?: boolean
    emailSent?: boolean
    emailSentAt?: boolean
    recipientEmail?: boolean
    fileUrl?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentGeneration"]>

  export type DocumentGenerationSelectScalar = {
    id?: boolean
    documentId?: boolean
    documentType?: boolean
    documentNumber?: boolean
    templateData?: boolean
    status?: boolean
    generatedBy?: boolean
    generatedAt?: boolean
    autoSend?: boolean
    emailSent?: boolean
    emailSentAt?: boolean
    recipientEmail?: boolean
    fileUrl?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DocumentGenerationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "documentId" | "documentType" | "documentNumber" | "templateData" | "status" | "generatedBy" | "generatedAt" | "autoSend" | "emailSent" | "emailSentAt" | "recipientEmail" | "fileUrl" | "errorMessage" | "createdAt" | "updatedAt", ExtArgs["result"]["documentGeneration"]>
  export type DocumentGenerationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }
  export type DocumentGenerationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }
  export type DocumentGenerationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }

  export type $DocumentGenerationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DocumentGeneration"
    objects: {
      document: Prisma.$DocumentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      documentId: string
      documentType: string
      documentNumber: string
      templateData: string
      status: string
      generatedBy: string | null
      generatedAt: Date | null
      autoSend: boolean
      emailSent: boolean
      emailSentAt: Date | null
      recipientEmail: string | null
      fileUrl: string | null
      errorMessage: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["documentGeneration"]>
    composites: {}
  }

  type DocumentGenerationGetPayload<S extends boolean | null | undefined | DocumentGenerationDefaultArgs> = $Result.GetResult<Prisma.$DocumentGenerationPayload, S>

  type DocumentGenerationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentGenerationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentGenerationCountAggregateInputType | true
    }

  export interface DocumentGenerationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DocumentGeneration'], meta: { name: 'DocumentGeneration' } }
    /**
     * Find zero or one DocumentGeneration that matches the filter.
     * @param {DocumentGenerationFindUniqueArgs} args - Arguments to find a DocumentGeneration
     * @example
     * // Get one DocumentGeneration
     * const documentGeneration = await prisma.documentGeneration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentGenerationFindUniqueArgs>(args: SelectSubset<T, DocumentGenerationFindUniqueArgs<ExtArgs>>): Prisma__DocumentGenerationClient<$Result.GetResult<Prisma.$DocumentGenerationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DocumentGeneration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentGenerationFindUniqueOrThrowArgs} args - Arguments to find a DocumentGeneration
     * @example
     * // Get one DocumentGeneration
     * const documentGeneration = await prisma.documentGeneration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentGenerationFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentGenerationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentGenerationClient<$Result.GetResult<Prisma.$DocumentGenerationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentGeneration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGenerationFindFirstArgs} args - Arguments to find a DocumentGeneration
     * @example
     * // Get one DocumentGeneration
     * const documentGeneration = await prisma.documentGeneration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentGenerationFindFirstArgs>(args?: SelectSubset<T, DocumentGenerationFindFirstArgs<ExtArgs>>): Prisma__DocumentGenerationClient<$Result.GetResult<Prisma.$DocumentGenerationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentGeneration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGenerationFindFirstOrThrowArgs} args - Arguments to find a DocumentGeneration
     * @example
     * // Get one DocumentGeneration
     * const documentGeneration = await prisma.documentGeneration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentGenerationFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentGenerationFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentGenerationClient<$Result.GetResult<Prisma.$DocumentGenerationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DocumentGenerations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGenerationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentGenerations
     * const documentGenerations = await prisma.documentGeneration.findMany()
     * 
     * // Get first 10 DocumentGenerations
     * const documentGenerations = await prisma.documentGeneration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentGenerationWithIdOnly = await prisma.documentGeneration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentGenerationFindManyArgs>(args?: SelectSubset<T, DocumentGenerationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentGenerationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DocumentGeneration.
     * @param {DocumentGenerationCreateArgs} args - Arguments to create a DocumentGeneration.
     * @example
     * // Create one DocumentGeneration
     * const DocumentGeneration = await prisma.documentGeneration.create({
     *   data: {
     *     // ... data to create a DocumentGeneration
     *   }
     * })
     * 
     */
    create<T extends DocumentGenerationCreateArgs>(args: SelectSubset<T, DocumentGenerationCreateArgs<ExtArgs>>): Prisma__DocumentGenerationClient<$Result.GetResult<Prisma.$DocumentGenerationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DocumentGenerations.
     * @param {DocumentGenerationCreateManyArgs} args - Arguments to create many DocumentGenerations.
     * @example
     * // Create many DocumentGenerations
     * const documentGeneration = await prisma.documentGeneration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentGenerationCreateManyArgs>(args?: SelectSubset<T, DocumentGenerationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DocumentGenerations and returns the data saved in the database.
     * @param {DocumentGenerationCreateManyAndReturnArgs} args - Arguments to create many DocumentGenerations.
     * @example
     * // Create many DocumentGenerations
     * const documentGeneration = await prisma.documentGeneration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DocumentGenerations and only return the `id`
     * const documentGenerationWithIdOnly = await prisma.documentGeneration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentGenerationCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentGenerationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentGenerationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DocumentGeneration.
     * @param {DocumentGenerationDeleteArgs} args - Arguments to delete one DocumentGeneration.
     * @example
     * // Delete one DocumentGeneration
     * const DocumentGeneration = await prisma.documentGeneration.delete({
     *   where: {
     *     // ... filter to delete one DocumentGeneration
     *   }
     * })
     * 
     */
    delete<T extends DocumentGenerationDeleteArgs>(args: SelectSubset<T, DocumentGenerationDeleteArgs<ExtArgs>>): Prisma__DocumentGenerationClient<$Result.GetResult<Prisma.$DocumentGenerationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DocumentGeneration.
     * @param {DocumentGenerationUpdateArgs} args - Arguments to update one DocumentGeneration.
     * @example
     * // Update one DocumentGeneration
     * const documentGeneration = await prisma.documentGeneration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentGenerationUpdateArgs>(args: SelectSubset<T, DocumentGenerationUpdateArgs<ExtArgs>>): Prisma__DocumentGenerationClient<$Result.GetResult<Prisma.$DocumentGenerationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DocumentGenerations.
     * @param {DocumentGenerationDeleteManyArgs} args - Arguments to filter DocumentGenerations to delete.
     * @example
     * // Delete a few DocumentGenerations
     * const { count } = await prisma.documentGeneration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentGenerationDeleteManyArgs>(args?: SelectSubset<T, DocumentGenerationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentGenerations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGenerationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentGenerations
     * const documentGeneration = await prisma.documentGeneration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentGenerationUpdateManyArgs>(args: SelectSubset<T, DocumentGenerationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentGenerations and returns the data updated in the database.
     * @param {DocumentGenerationUpdateManyAndReturnArgs} args - Arguments to update many DocumentGenerations.
     * @example
     * // Update many DocumentGenerations
     * const documentGeneration = await prisma.documentGeneration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DocumentGenerations and only return the `id`
     * const documentGenerationWithIdOnly = await prisma.documentGeneration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentGenerationUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentGenerationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentGenerationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DocumentGeneration.
     * @param {DocumentGenerationUpsertArgs} args - Arguments to update or create a DocumentGeneration.
     * @example
     * // Update or create a DocumentGeneration
     * const documentGeneration = await prisma.documentGeneration.upsert({
     *   create: {
     *     // ... data to create a DocumentGeneration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentGeneration we want to update
     *   }
     * })
     */
    upsert<T extends DocumentGenerationUpsertArgs>(args: SelectSubset<T, DocumentGenerationUpsertArgs<ExtArgs>>): Prisma__DocumentGenerationClient<$Result.GetResult<Prisma.$DocumentGenerationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DocumentGenerations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGenerationCountArgs} args - Arguments to filter DocumentGenerations to count.
     * @example
     * // Count the number of DocumentGenerations
     * const count = await prisma.documentGeneration.count({
     *   where: {
     *     // ... the filter for the DocumentGenerations we want to count
     *   }
     * })
    **/
    count<T extends DocumentGenerationCountArgs>(
      args?: Subset<T, DocumentGenerationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentGenerationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentGeneration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGenerationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentGenerationAggregateArgs>(args: Subset<T, DocumentGenerationAggregateArgs>): Prisma.PrismaPromise<GetDocumentGenerationAggregateType<T>>

    /**
     * Group by DocumentGeneration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGenerationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGenerationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGenerationGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGenerationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGenerationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGenerationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DocumentGeneration model
   */
  readonly fields: DocumentGenerationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentGeneration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentGenerationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    document<T extends DocumentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DocumentDefaultArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DocumentGeneration model
   */
  interface DocumentGenerationFieldRefs {
    readonly id: FieldRef<"DocumentGeneration", 'String'>
    readonly documentId: FieldRef<"DocumentGeneration", 'String'>
    readonly documentType: FieldRef<"DocumentGeneration", 'String'>
    readonly documentNumber: FieldRef<"DocumentGeneration", 'String'>
    readonly templateData: FieldRef<"DocumentGeneration", 'String'>
    readonly status: FieldRef<"DocumentGeneration", 'String'>
    readonly generatedBy: FieldRef<"DocumentGeneration", 'String'>
    readonly generatedAt: FieldRef<"DocumentGeneration", 'DateTime'>
    readonly autoSend: FieldRef<"DocumentGeneration", 'Boolean'>
    readonly emailSent: FieldRef<"DocumentGeneration", 'Boolean'>
    readonly emailSentAt: FieldRef<"DocumentGeneration", 'DateTime'>
    readonly recipientEmail: FieldRef<"DocumentGeneration", 'String'>
    readonly fileUrl: FieldRef<"DocumentGeneration", 'String'>
    readonly errorMessage: FieldRef<"DocumentGeneration", 'String'>
    readonly createdAt: FieldRef<"DocumentGeneration", 'DateTime'>
    readonly updatedAt: FieldRef<"DocumentGeneration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DocumentGeneration findUnique
   */
  export type DocumentGenerationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentGeneration
     */
    select?: DocumentGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentGeneration
     */
    omit?: DocumentGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentGenerationInclude<ExtArgs> | null
    /**
     * Filter, which DocumentGeneration to fetch.
     */
    where: DocumentGenerationWhereUniqueInput
  }

  /**
   * DocumentGeneration findUniqueOrThrow
   */
  export type DocumentGenerationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentGeneration
     */
    select?: DocumentGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentGeneration
     */
    omit?: DocumentGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentGenerationInclude<ExtArgs> | null
    /**
     * Filter, which DocumentGeneration to fetch.
     */
    where: DocumentGenerationWhereUniqueInput
  }

  /**
   * DocumentGeneration findFirst
   */
  export type DocumentGenerationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentGeneration
     */
    select?: DocumentGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentGeneration
     */
    omit?: DocumentGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentGenerationInclude<ExtArgs> | null
    /**
     * Filter, which DocumentGeneration to fetch.
     */
    where?: DocumentGenerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentGenerations to fetch.
     */
    orderBy?: DocumentGenerationOrderByWithRelationInput | DocumentGenerationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentGenerations.
     */
    cursor?: DocumentGenerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentGenerations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentGenerations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentGenerations.
     */
    distinct?: DocumentGenerationScalarFieldEnum | DocumentGenerationScalarFieldEnum[]
  }

  /**
   * DocumentGeneration findFirstOrThrow
   */
  export type DocumentGenerationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentGeneration
     */
    select?: DocumentGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentGeneration
     */
    omit?: DocumentGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentGenerationInclude<ExtArgs> | null
    /**
     * Filter, which DocumentGeneration to fetch.
     */
    where?: DocumentGenerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentGenerations to fetch.
     */
    orderBy?: DocumentGenerationOrderByWithRelationInput | DocumentGenerationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentGenerations.
     */
    cursor?: DocumentGenerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentGenerations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentGenerations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentGenerations.
     */
    distinct?: DocumentGenerationScalarFieldEnum | DocumentGenerationScalarFieldEnum[]
  }

  /**
   * DocumentGeneration findMany
   */
  export type DocumentGenerationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentGeneration
     */
    select?: DocumentGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentGeneration
     */
    omit?: DocumentGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentGenerationInclude<ExtArgs> | null
    /**
     * Filter, which DocumentGenerations to fetch.
     */
    where?: DocumentGenerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentGenerations to fetch.
     */
    orderBy?: DocumentGenerationOrderByWithRelationInput | DocumentGenerationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentGenerations.
     */
    cursor?: DocumentGenerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentGenerations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentGenerations.
     */
    skip?: number
    distinct?: DocumentGenerationScalarFieldEnum | DocumentGenerationScalarFieldEnum[]
  }

  /**
   * DocumentGeneration create
   */
  export type DocumentGenerationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentGeneration
     */
    select?: DocumentGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentGeneration
     */
    omit?: DocumentGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentGenerationInclude<ExtArgs> | null
    /**
     * The data needed to create a DocumentGeneration.
     */
    data: XOR<DocumentGenerationCreateInput, DocumentGenerationUncheckedCreateInput>
  }

  /**
   * DocumentGeneration createMany
   */
  export type DocumentGenerationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DocumentGenerations.
     */
    data: DocumentGenerationCreateManyInput | DocumentGenerationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DocumentGeneration createManyAndReturn
   */
  export type DocumentGenerationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentGeneration
     */
    select?: DocumentGenerationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentGeneration
     */
    omit?: DocumentGenerationOmit<ExtArgs> | null
    /**
     * The data used to create many DocumentGenerations.
     */
    data: DocumentGenerationCreateManyInput | DocumentGenerationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentGenerationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentGeneration update
   */
  export type DocumentGenerationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentGeneration
     */
    select?: DocumentGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentGeneration
     */
    omit?: DocumentGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentGenerationInclude<ExtArgs> | null
    /**
     * The data needed to update a DocumentGeneration.
     */
    data: XOR<DocumentGenerationUpdateInput, DocumentGenerationUncheckedUpdateInput>
    /**
     * Choose, which DocumentGeneration to update.
     */
    where: DocumentGenerationWhereUniqueInput
  }

  /**
   * DocumentGeneration updateMany
   */
  export type DocumentGenerationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DocumentGenerations.
     */
    data: XOR<DocumentGenerationUpdateManyMutationInput, DocumentGenerationUncheckedUpdateManyInput>
    /**
     * Filter which DocumentGenerations to update
     */
    where?: DocumentGenerationWhereInput
    /**
     * Limit how many DocumentGenerations to update.
     */
    limit?: number
  }

  /**
   * DocumentGeneration updateManyAndReturn
   */
  export type DocumentGenerationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentGeneration
     */
    select?: DocumentGenerationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentGeneration
     */
    omit?: DocumentGenerationOmit<ExtArgs> | null
    /**
     * The data used to update DocumentGenerations.
     */
    data: XOR<DocumentGenerationUpdateManyMutationInput, DocumentGenerationUncheckedUpdateManyInput>
    /**
     * Filter which DocumentGenerations to update
     */
    where?: DocumentGenerationWhereInput
    /**
     * Limit how many DocumentGenerations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentGenerationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentGeneration upsert
   */
  export type DocumentGenerationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentGeneration
     */
    select?: DocumentGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentGeneration
     */
    omit?: DocumentGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentGenerationInclude<ExtArgs> | null
    /**
     * The filter to search for the DocumentGeneration to update in case it exists.
     */
    where: DocumentGenerationWhereUniqueInput
    /**
     * In case the DocumentGeneration found by the `where` argument doesn't exist, create a new DocumentGeneration with this data.
     */
    create: XOR<DocumentGenerationCreateInput, DocumentGenerationUncheckedCreateInput>
    /**
     * In case the DocumentGeneration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentGenerationUpdateInput, DocumentGenerationUncheckedUpdateInput>
  }

  /**
   * DocumentGeneration delete
   */
  export type DocumentGenerationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentGeneration
     */
    select?: DocumentGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentGeneration
     */
    omit?: DocumentGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentGenerationInclude<ExtArgs> | null
    /**
     * Filter which DocumentGeneration to delete.
     */
    where: DocumentGenerationWhereUniqueInput
  }

  /**
   * DocumentGeneration deleteMany
   */
  export type DocumentGenerationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentGenerations to delete
     */
    where?: DocumentGenerationWhereInput
    /**
     * Limit how many DocumentGenerations to delete.
     */
    limit?: number
  }

  /**
   * DocumentGeneration without action
   */
  export type DocumentGenerationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentGeneration
     */
    select?: DocumentGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentGeneration
     */
    omit?: DocumentGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentGenerationInclude<ExtArgs> | null
  }


  /**
   * Model Quote
   */

  export type AggregateQuote = {
    _count: QuoteCountAggregateOutputType | null
    _avg: QuoteAvgAggregateOutputType | null
    _sum: QuoteSumAggregateOutputType | null
    _min: QuoteMinAggregateOutputType | null
    _max: QuoteMaxAggregateOutputType | null
  }

  export type QuoteAvgAggregateOutputType = {
    subtotal: number | null
    tax: number | null
    total: number | null
  }

  export type QuoteSumAggregateOutputType = {
    subtotal: number | null
    tax: number | null
    total: number | null
  }

  export type QuoteMinAggregateOutputType = {
    id: string | null
    quoteNumber: string | null
    customerId: string | null
    title: string | null
    description: string | null
    subtotal: number | null
    tax: number | null
    total: number | null
    currency: string | null
    validUntil: Date | null
    status: string | null
    terms: string | null
    notes: string | null
    convertedToProjectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    serviceId: string | null
  }

  export type QuoteMaxAggregateOutputType = {
    id: string | null
    quoteNumber: string | null
    customerId: string | null
    title: string | null
    description: string | null
    subtotal: number | null
    tax: number | null
    total: number | null
    currency: string | null
    validUntil: Date | null
    status: string | null
    terms: string | null
    notes: string | null
    convertedToProjectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    serviceId: string | null
  }

  export type QuoteCountAggregateOutputType = {
    id: number
    quoteNumber: number
    customerId: number
    title: number
    description: number
    services: number
    subtotal: number
    tax: number
    total: number
    currency: number
    validUntil: number
    status: number
    terms: number
    notes: number
    convertedToProjectId: number
    createdAt: number
    updatedAt: number
    serviceId: number
    _all: number
  }


  export type QuoteAvgAggregateInputType = {
    subtotal?: true
    tax?: true
    total?: true
  }

  export type QuoteSumAggregateInputType = {
    subtotal?: true
    tax?: true
    total?: true
  }

  export type QuoteMinAggregateInputType = {
    id?: true
    quoteNumber?: true
    customerId?: true
    title?: true
    description?: true
    subtotal?: true
    tax?: true
    total?: true
    currency?: true
    validUntil?: true
    status?: true
    terms?: true
    notes?: true
    convertedToProjectId?: true
    createdAt?: true
    updatedAt?: true
    serviceId?: true
  }

  export type QuoteMaxAggregateInputType = {
    id?: true
    quoteNumber?: true
    customerId?: true
    title?: true
    description?: true
    subtotal?: true
    tax?: true
    total?: true
    currency?: true
    validUntil?: true
    status?: true
    terms?: true
    notes?: true
    convertedToProjectId?: true
    createdAt?: true
    updatedAt?: true
    serviceId?: true
  }

  export type QuoteCountAggregateInputType = {
    id?: true
    quoteNumber?: true
    customerId?: true
    title?: true
    description?: true
    services?: true
    subtotal?: true
    tax?: true
    total?: true
    currency?: true
    validUntil?: true
    status?: true
    terms?: true
    notes?: true
    convertedToProjectId?: true
    createdAt?: true
    updatedAt?: true
    serviceId?: true
    _all?: true
  }

  export type QuoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quote to aggregate.
     */
    where?: QuoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Quotes
    **/
    _count?: true | QuoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuoteMaxAggregateInputType
  }

  export type GetQuoteAggregateType<T extends QuoteAggregateArgs> = {
        [P in keyof T & keyof AggregateQuote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuote[P]>
      : GetScalarType<T[P], AggregateQuote[P]>
  }




  export type QuoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteWhereInput
    orderBy?: QuoteOrderByWithAggregationInput | QuoteOrderByWithAggregationInput[]
    by: QuoteScalarFieldEnum[] | QuoteScalarFieldEnum
    having?: QuoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuoteCountAggregateInputType | true
    _avg?: QuoteAvgAggregateInputType
    _sum?: QuoteSumAggregateInputType
    _min?: QuoteMinAggregateInputType
    _max?: QuoteMaxAggregateInputType
  }

  export type QuoteGroupByOutputType = {
    id: string
    quoteNumber: string
    customerId: string
    title: string
    description: string | null
    services: JsonValue
    subtotal: number
    tax: number
    total: number
    currency: string
    validUntil: Date
    status: string
    terms: string | null
    notes: string | null
    convertedToProjectId: string | null
    createdAt: Date
    updatedAt: Date
    serviceId: string | null
    _count: QuoteCountAggregateOutputType | null
    _avg: QuoteAvgAggregateOutputType | null
    _sum: QuoteSumAggregateOutputType | null
    _min: QuoteMinAggregateOutputType | null
    _max: QuoteMaxAggregateOutputType | null
  }

  type GetQuoteGroupByPayload<T extends QuoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuoteGroupByOutputType[P]>
            : GetScalarType<T[P], QuoteGroupByOutputType[P]>
        }
      >
    >


  export type QuoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quoteNumber?: boolean
    customerId?: boolean
    title?: boolean
    description?: boolean
    services?: boolean
    subtotal?: boolean
    tax?: boolean
    total?: boolean
    currency?: boolean
    validUntil?: boolean
    status?: boolean
    terms?: boolean
    notes?: boolean
    convertedToProjectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serviceId?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    Service?: boolean | Quote$ServiceArgs<ExtArgs>
  }, ExtArgs["result"]["quote"]>

  export type QuoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quoteNumber?: boolean
    customerId?: boolean
    title?: boolean
    description?: boolean
    services?: boolean
    subtotal?: boolean
    tax?: boolean
    total?: boolean
    currency?: boolean
    validUntil?: boolean
    status?: boolean
    terms?: boolean
    notes?: boolean
    convertedToProjectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serviceId?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    Service?: boolean | Quote$ServiceArgs<ExtArgs>
  }, ExtArgs["result"]["quote"]>

  export type QuoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quoteNumber?: boolean
    customerId?: boolean
    title?: boolean
    description?: boolean
    services?: boolean
    subtotal?: boolean
    tax?: boolean
    total?: boolean
    currency?: boolean
    validUntil?: boolean
    status?: boolean
    terms?: boolean
    notes?: boolean
    convertedToProjectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serviceId?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    Service?: boolean | Quote$ServiceArgs<ExtArgs>
  }, ExtArgs["result"]["quote"]>

  export type QuoteSelectScalar = {
    id?: boolean
    quoteNumber?: boolean
    customerId?: boolean
    title?: boolean
    description?: boolean
    services?: boolean
    subtotal?: boolean
    tax?: boolean
    total?: boolean
    currency?: boolean
    validUntil?: boolean
    status?: boolean
    terms?: boolean
    notes?: boolean
    convertedToProjectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serviceId?: boolean
  }

  export type QuoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quoteNumber" | "customerId" | "title" | "description" | "services" | "subtotal" | "tax" | "total" | "currency" | "validUntil" | "status" | "terms" | "notes" | "convertedToProjectId" | "createdAt" | "updatedAt" | "serviceId", ExtArgs["result"]["quote"]>
  export type QuoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    Service?: boolean | Quote$ServiceArgs<ExtArgs>
  }
  export type QuoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    Service?: boolean | Quote$ServiceArgs<ExtArgs>
  }
  export type QuoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    Service?: boolean | Quote$ServiceArgs<ExtArgs>
  }

  export type $QuotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Quote"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      Service: Prisma.$ServicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      quoteNumber: string
      customerId: string
      title: string
      description: string | null
      services: Prisma.JsonValue
      subtotal: number
      tax: number
      total: number
      currency: string
      validUntil: Date
      status: string
      terms: string | null
      notes: string | null
      convertedToProjectId: string | null
      createdAt: Date
      updatedAt: Date
      serviceId: string | null
    }, ExtArgs["result"]["quote"]>
    composites: {}
  }

  type QuoteGetPayload<S extends boolean | null | undefined | QuoteDefaultArgs> = $Result.GetResult<Prisma.$QuotePayload, S>

  type QuoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuoteCountAggregateInputType | true
    }

  export interface QuoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Quote'], meta: { name: 'Quote' } }
    /**
     * Find zero or one Quote that matches the filter.
     * @param {QuoteFindUniqueArgs} args - Arguments to find a Quote
     * @example
     * // Get one Quote
     * const quote = await prisma.quote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuoteFindUniqueArgs>(args: SelectSubset<T, QuoteFindUniqueArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Quote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuoteFindUniqueOrThrowArgs} args - Arguments to find a Quote
     * @example
     * // Get one Quote
     * const quote = await prisma.quote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuoteFindUniqueOrThrowArgs>(args: SelectSubset<T, QuoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteFindFirstArgs} args - Arguments to find a Quote
     * @example
     * // Get one Quote
     * const quote = await prisma.quote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuoteFindFirstArgs>(args?: SelectSubset<T, QuoteFindFirstArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteFindFirstOrThrowArgs} args - Arguments to find a Quote
     * @example
     * // Get one Quote
     * const quote = await prisma.quote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuoteFindFirstOrThrowArgs>(args?: SelectSubset<T, QuoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Quotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quotes
     * const quotes = await prisma.quote.findMany()
     * 
     * // Get first 10 Quotes
     * const quotes = await prisma.quote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quoteWithIdOnly = await prisma.quote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuoteFindManyArgs>(args?: SelectSubset<T, QuoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Quote.
     * @param {QuoteCreateArgs} args - Arguments to create a Quote.
     * @example
     * // Create one Quote
     * const Quote = await prisma.quote.create({
     *   data: {
     *     // ... data to create a Quote
     *   }
     * })
     * 
     */
    create<T extends QuoteCreateArgs>(args: SelectSubset<T, QuoteCreateArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Quotes.
     * @param {QuoteCreateManyArgs} args - Arguments to create many Quotes.
     * @example
     * // Create many Quotes
     * const quote = await prisma.quote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuoteCreateManyArgs>(args?: SelectSubset<T, QuoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Quotes and returns the data saved in the database.
     * @param {QuoteCreateManyAndReturnArgs} args - Arguments to create many Quotes.
     * @example
     * // Create many Quotes
     * const quote = await prisma.quote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Quotes and only return the `id`
     * const quoteWithIdOnly = await prisma.quote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuoteCreateManyAndReturnArgs>(args?: SelectSubset<T, QuoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Quote.
     * @param {QuoteDeleteArgs} args - Arguments to delete one Quote.
     * @example
     * // Delete one Quote
     * const Quote = await prisma.quote.delete({
     *   where: {
     *     // ... filter to delete one Quote
     *   }
     * })
     * 
     */
    delete<T extends QuoteDeleteArgs>(args: SelectSubset<T, QuoteDeleteArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Quote.
     * @param {QuoteUpdateArgs} args - Arguments to update one Quote.
     * @example
     * // Update one Quote
     * const quote = await prisma.quote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuoteUpdateArgs>(args: SelectSubset<T, QuoteUpdateArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Quotes.
     * @param {QuoteDeleteManyArgs} args - Arguments to filter Quotes to delete.
     * @example
     * // Delete a few Quotes
     * const { count } = await prisma.quote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuoteDeleteManyArgs>(args?: SelectSubset<T, QuoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quotes
     * const quote = await prisma.quote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuoteUpdateManyArgs>(args: SelectSubset<T, QuoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quotes and returns the data updated in the database.
     * @param {QuoteUpdateManyAndReturnArgs} args - Arguments to update many Quotes.
     * @example
     * // Update many Quotes
     * const quote = await prisma.quote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Quotes and only return the `id`
     * const quoteWithIdOnly = await prisma.quote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuoteUpdateManyAndReturnArgs>(args: SelectSubset<T, QuoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Quote.
     * @param {QuoteUpsertArgs} args - Arguments to update or create a Quote.
     * @example
     * // Update or create a Quote
     * const quote = await prisma.quote.upsert({
     *   create: {
     *     // ... data to create a Quote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quote we want to update
     *   }
     * })
     */
    upsert<T extends QuoteUpsertArgs>(args: SelectSubset<T, QuoteUpsertArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Quotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteCountArgs} args - Arguments to filter Quotes to count.
     * @example
     * // Count the number of Quotes
     * const count = await prisma.quote.count({
     *   where: {
     *     // ... the filter for the Quotes we want to count
     *   }
     * })
    **/
    count<T extends QuoteCountArgs>(
      args?: Subset<T, QuoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuoteAggregateArgs>(args: Subset<T, QuoteAggregateArgs>): Prisma.PrismaPromise<GetQuoteAggregateType<T>>

    /**
     * Group by Quote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuoteGroupByArgs['orderBy'] }
        : { orderBy?: QuoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Quote model
   */
  readonly fields: QuoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Quote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Service<T extends Quote$ServiceArgs<ExtArgs> = {}>(args?: Subset<T, Quote$ServiceArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Quote model
   */
  interface QuoteFieldRefs {
    readonly id: FieldRef<"Quote", 'String'>
    readonly quoteNumber: FieldRef<"Quote", 'String'>
    readonly customerId: FieldRef<"Quote", 'String'>
    readonly title: FieldRef<"Quote", 'String'>
    readonly description: FieldRef<"Quote", 'String'>
    readonly services: FieldRef<"Quote", 'Json'>
    readonly subtotal: FieldRef<"Quote", 'Float'>
    readonly tax: FieldRef<"Quote", 'Float'>
    readonly total: FieldRef<"Quote", 'Float'>
    readonly currency: FieldRef<"Quote", 'String'>
    readonly validUntil: FieldRef<"Quote", 'DateTime'>
    readonly status: FieldRef<"Quote", 'String'>
    readonly terms: FieldRef<"Quote", 'String'>
    readonly notes: FieldRef<"Quote", 'String'>
    readonly convertedToProjectId: FieldRef<"Quote", 'String'>
    readonly createdAt: FieldRef<"Quote", 'DateTime'>
    readonly updatedAt: FieldRef<"Quote", 'DateTime'>
    readonly serviceId: FieldRef<"Quote", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Quote findUnique
   */
  export type QuoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter, which Quote to fetch.
     */
    where: QuoteWhereUniqueInput
  }

  /**
   * Quote findUniqueOrThrow
   */
  export type QuoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter, which Quote to fetch.
     */
    where: QuoteWhereUniqueInput
  }

  /**
   * Quote findFirst
   */
  export type QuoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter, which Quote to fetch.
     */
    where?: QuoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quotes.
     */
    cursor?: QuoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quotes.
     */
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * Quote findFirstOrThrow
   */
  export type QuoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter, which Quote to fetch.
     */
    where?: QuoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quotes.
     */
    cursor?: QuoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quotes.
     */
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * Quote findMany
   */
  export type QuoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter, which Quotes to fetch.
     */
    where?: QuoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Quotes.
     */
    cursor?: QuoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * Quote create
   */
  export type QuoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * The data needed to create a Quote.
     */
    data: XOR<QuoteCreateInput, QuoteUncheckedCreateInput>
  }

  /**
   * Quote createMany
   */
  export type QuoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Quotes.
     */
    data: QuoteCreateManyInput | QuoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Quote createManyAndReturn
   */
  export type QuoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * The data used to create many Quotes.
     */
    data: QuoteCreateManyInput | QuoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quote update
   */
  export type QuoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * The data needed to update a Quote.
     */
    data: XOR<QuoteUpdateInput, QuoteUncheckedUpdateInput>
    /**
     * Choose, which Quote to update.
     */
    where: QuoteWhereUniqueInput
  }

  /**
   * Quote updateMany
   */
  export type QuoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Quotes.
     */
    data: XOR<QuoteUpdateManyMutationInput, QuoteUncheckedUpdateManyInput>
    /**
     * Filter which Quotes to update
     */
    where?: QuoteWhereInput
    /**
     * Limit how many Quotes to update.
     */
    limit?: number
  }

  /**
   * Quote updateManyAndReturn
   */
  export type QuoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * The data used to update Quotes.
     */
    data: XOR<QuoteUpdateManyMutationInput, QuoteUncheckedUpdateManyInput>
    /**
     * Filter which Quotes to update
     */
    where?: QuoteWhereInput
    /**
     * Limit how many Quotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quote upsert
   */
  export type QuoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * The filter to search for the Quote to update in case it exists.
     */
    where: QuoteWhereUniqueInput
    /**
     * In case the Quote found by the `where` argument doesn't exist, create a new Quote with this data.
     */
    create: XOR<QuoteCreateInput, QuoteUncheckedCreateInput>
    /**
     * In case the Quote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuoteUpdateInput, QuoteUncheckedUpdateInput>
  }

  /**
   * Quote delete
   */
  export type QuoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter which Quote to delete.
     */
    where: QuoteWhereUniqueInput
  }

  /**
   * Quote deleteMany
   */
  export type QuoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quotes to delete
     */
    where?: QuoteWhereInput
    /**
     * Limit how many Quotes to delete.
     */
    limit?: number
  }

  /**
   * Quote.Service
   */
  export type Quote$ServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
  }

  /**
   * Quote without action
   */
  export type QuoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
  }


  /**
   * Model MaterialCost
   */

  export type AggregateMaterialCost = {
    _count: MaterialCostCountAggregateOutputType | null
    _avg: MaterialCostAvgAggregateOutputType | null
    _sum: MaterialCostSumAggregateOutputType | null
    _min: MaterialCostMinAggregateOutputType | null
    _max: MaterialCostMaxAggregateOutputType | null
  }

  export type MaterialCostAvgAggregateOutputType = {
    quantity: number | null
    unitCost: number | null
    totalCost: number | null
  }

  export type MaterialCostSumAggregateOutputType = {
    quantity: number | null
    unitCost: number | null
    totalCost: number | null
  }

  export type MaterialCostMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    supplier: string | null
    material: string | null
    quantity: number | null
    unitCost: number | null
    totalCost: number | null
    invoiceRef: string | null
    date: Date | null
    category: string | null
    createdAt: Date | null
  }

  export type MaterialCostMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    supplier: string | null
    material: string | null
    quantity: number | null
    unitCost: number | null
    totalCost: number | null
    invoiceRef: string | null
    date: Date | null
    category: string | null
    createdAt: Date | null
  }

  export type MaterialCostCountAggregateOutputType = {
    id: number
    projectId: number
    supplier: number
    material: number
    quantity: number
    unitCost: number
    totalCost: number
    invoiceRef: number
    date: number
    category: number
    createdAt: number
    _all: number
  }


  export type MaterialCostAvgAggregateInputType = {
    quantity?: true
    unitCost?: true
    totalCost?: true
  }

  export type MaterialCostSumAggregateInputType = {
    quantity?: true
    unitCost?: true
    totalCost?: true
  }

  export type MaterialCostMinAggregateInputType = {
    id?: true
    projectId?: true
    supplier?: true
    material?: true
    quantity?: true
    unitCost?: true
    totalCost?: true
    invoiceRef?: true
    date?: true
    category?: true
    createdAt?: true
  }

  export type MaterialCostMaxAggregateInputType = {
    id?: true
    projectId?: true
    supplier?: true
    material?: true
    quantity?: true
    unitCost?: true
    totalCost?: true
    invoiceRef?: true
    date?: true
    category?: true
    createdAt?: true
  }

  export type MaterialCostCountAggregateInputType = {
    id?: true
    projectId?: true
    supplier?: true
    material?: true
    quantity?: true
    unitCost?: true
    totalCost?: true
    invoiceRef?: true
    date?: true
    category?: true
    createdAt?: true
    _all?: true
  }

  export type MaterialCostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaterialCost to aggregate.
     */
    where?: MaterialCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialCosts to fetch.
     */
    orderBy?: MaterialCostOrderByWithRelationInput | MaterialCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaterialCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialCosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MaterialCosts
    **/
    _count?: true | MaterialCostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaterialCostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaterialCostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterialCostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterialCostMaxAggregateInputType
  }

  export type GetMaterialCostAggregateType<T extends MaterialCostAggregateArgs> = {
        [P in keyof T & keyof AggregateMaterialCost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaterialCost[P]>
      : GetScalarType<T[P], AggregateMaterialCost[P]>
  }




  export type MaterialCostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialCostWhereInput
    orderBy?: MaterialCostOrderByWithAggregationInput | MaterialCostOrderByWithAggregationInput[]
    by: MaterialCostScalarFieldEnum[] | MaterialCostScalarFieldEnum
    having?: MaterialCostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterialCostCountAggregateInputType | true
    _avg?: MaterialCostAvgAggregateInputType
    _sum?: MaterialCostSumAggregateInputType
    _min?: MaterialCostMinAggregateInputType
    _max?: MaterialCostMaxAggregateInputType
  }

  export type MaterialCostGroupByOutputType = {
    id: string
    projectId: string | null
    supplier: string
    material: string
    quantity: number
    unitCost: number
    totalCost: number
    invoiceRef: string | null
    date: Date
    category: string | null
    createdAt: Date
    _count: MaterialCostCountAggregateOutputType | null
    _avg: MaterialCostAvgAggregateOutputType | null
    _sum: MaterialCostSumAggregateOutputType | null
    _min: MaterialCostMinAggregateOutputType | null
    _max: MaterialCostMaxAggregateOutputType | null
  }

  type GetMaterialCostGroupByPayload<T extends MaterialCostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaterialCostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaterialCostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaterialCostGroupByOutputType[P]>
            : GetScalarType<T[P], MaterialCostGroupByOutputType[P]>
        }
      >
    >


  export type MaterialCostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    supplier?: boolean
    material?: boolean
    quantity?: boolean
    unitCost?: boolean
    totalCost?: boolean
    invoiceRef?: boolean
    date?: boolean
    category?: boolean
    createdAt?: boolean
    project?: boolean | MaterialCost$projectArgs<ExtArgs>
  }, ExtArgs["result"]["materialCost"]>

  export type MaterialCostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    supplier?: boolean
    material?: boolean
    quantity?: boolean
    unitCost?: boolean
    totalCost?: boolean
    invoiceRef?: boolean
    date?: boolean
    category?: boolean
    createdAt?: boolean
    project?: boolean | MaterialCost$projectArgs<ExtArgs>
  }, ExtArgs["result"]["materialCost"]>

  export type MaterialCostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    supplier?: boolean
    material?: boolean
    quantity?: boolean
    unitCost?: boolean
    totalCost?: boolean
    invoiceRef?: boolean
    date?: boolean
    category?: boolean
    createdAt?: boolean
    project?: boolean | MaterialCost$projectArgs<ExtArgs>
  }, ExtArgs["result"]["materialCost"]>

  export type MaterialCostSelectScalar = {
    id?: boolean
    projectId?: boolean
    supplier?: boolean
    material?: boolean
    quantity?: boolean
    unitCost?: boolean
    totalCost?: boolean
    invoiceRef?: boolean
    date?: boolean
    category?: boolean
    createdAt?: boolean
  }

  export type MaterialCostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "supplier" | "material" | "quantity" | "unitCost" | "totalCost" | "invoiceRef" | "date" | "category" | "createdAt", ExtArgs["result"]["materialCost"]>
  export type MaterialCostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | MaterialCost$projectArgs<ExtArgs>
  }
  export type MaterialCostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | MaterialCost$projectArgs<ExtArgs>
  }
  export type MaterialCostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | MaterialCost$projectArgs<ExtArgs>
  }

  export type $MaterialCostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MaterialCost"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string | null
      supplier: string
      material: string
      quantity: number
      unitCost: number
      totalCost: number
      invoiceRef: string | null
      date: Date
      category: string | null
      createdAt: Date
    }, ExtArgs["result"]["materialCost"]>
    composites: {}
  }

  type MaterialCostGetPayload<S extends boolean | null | undefined | MaterialCostDefaultArgs> = $Result.GetResult<Prisma.$MaterialCostPayload, S>

  type MaterialCostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MaterialCostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MaterialCostCountAggregateInputType | true
    }

  export interface MaterialCostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MaterialCost'], meta: { name: 'MaterialCost' } }
    /**
     * Find zero or one MaterialCost that matches the filter.
     * @param {MaterialCostFindUniqueArgs} args - Arguments to find a MaterialCost
     * @example
     * // Get one MaterialCost
     * const materialCost = await prisma.materialCost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaterialCostFindUniqueArgs>(args: SelectSubset<T, MaterialCostFindUniqueArgs<ExtArgs>>): Prisma__MaterialCostClient<$Result.GetResult<Prisma.$MaterialCostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MaterialCost that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MaterialCostFindUniqueOrThrowArgs} args - Arguments to find a MaterialCost
     * @example
     * // Get one MaterialCost
     * const materialCost = await prisma.materialCost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaterialCostFindUniqueOrThrowArgs>(args: SelectSubset<T, MaterialCostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaterialCostClient<$Result.GetResult<Prisma.$MaterialCostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MaterialCost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialCostFindFirstArgs} args - Arguments to find a MaterialCost
     * @example
     * // Get one MaterialCost
     * const materialCost = await prisma.materialCost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaterialCostFindFirstArgs>(args?: SelectSubset<T, MaterialCostFindFirstArgs<ExtArgs>>): Prisma__MaterialCostClient<$Result.GetResult<Prisma.$MaterialCostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MaterialCost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialCostFindFirstOrThrowArgs} args - Arguments to find a MaterialCost
     * @example
     * // Get one MaterialCost
     * const materialCost = await prisma.materialCost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaterialCostFindFirstOrThrowArgs>(args?: SelectSubset<T, MaterialCostFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaterialCostClient<$Result.GetResult<Prisma.$MaterialCostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MaterialCosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialCostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MaterialCosts
     * const materialCosts = await prisma.materialCost.findMany()
     * 
     * // Get first 10 MaterialCosts
     * const materialCosts = await prisma.materialCost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materialCostWithIdOnly = await prisma.materialCost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaterialCostFindManyArgs>(args?: SelectSubset<T, MaterialCostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialCostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MaterialCost.
     * @param {MaterialCostCreateArgs} args - Arguments to create a MaterialCost.
     * @example
     * // Create one MaterialCost
     * const MaterialCost = await prisma.materialCost.create({
     *   data: {
     *     // ... data to create a MaterialCost
     *   }
     * })
     * 
     */
    create<T extends MaterialCostCreateArgs>(args: SelectSubset<T, MaterialCostCreateArgs<ExtArgs>>): Prisma__MaterialCostClient<$Result.GetResult<Prisma.$MaterialCostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MaterialCosts.
     * @param {MaterialCostCreateManyArgs} args - Arguments to create many MaterialCosts.
     * @example
     * // Create many MaterialCosts
     * const materialCost = await prisma.materialCost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaterialCostCreateManyArgs>(args?: SelectSubset<T, MaterialCostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MaterialCosts and returns the data saved in the database.
     * @param {MaterialCostCreateManyAndReturnArgs} args - Arguments to create many MaterialCosts.
     * @example
     * // Create many MaterialCosts
     * const materialCost = await prisma.materialCost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MaterialCosts and only return the `id`
     * const materialCostWithIdOnly = await prisma.materialCost.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaterialCostCreateManyAndReturnArgs>(args?: SelectSubset<T, MaterialCostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialCostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MaterialCost.
     * @param {MaterialCostDeleteArgs} args - Arguments to delete one MaterialCost.
     * @example
     * // Delete one MaterialCost
     * const MaterialCost = await prisma.materialCost.delete({
     *   where: {
     *     // ... filter to delete one MaterialCost
     *   }
     * })
     * 
     */
    delete<T extends MaterialCostDeleteArgs>(args: SelectSubset<T, MaterialCostDeleteArgs<ExtArgs>>): Prisma__MaterialCostClient<$Result.GetResult<Prisma.$MaterialCostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MaterialCost.
     * @param {MaterialCostUpdateArgs} args - Arguments to update one MaterialCost.
     * @example
     * // Update one MaterialCost
     * const materialCost = await prisma.materialCost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaterialCostUpdateArgs>(args: SelectSubset<T, MaterialCostUpdateArgs<ExtArgs>>): Prisma__MaterialCostClient<$Result.GetResult<Prisma.$MaterialCostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MaterialCosts.
     * @param {MaterialCostDeleteManyArgs} args - Arguments to filter MaterialCosts to delete.
     * @example
     * // Delete a few MaterialCosts
     * const { count } = await prisma.materialCost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaterialCostDeleteManyArgs>(args?: SelectSubset<T, MaterialCostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaterialCosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialCostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MaterialCosts
     * const materialCost = await prisma.materialCost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaterialCostUpdateManyArgs>(args: SelectSubset<T, MaterialCostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaterialCosts and returns the data updated in the database.
     * @param {MaterialCostUpdateManyAndReturnArgs} args - Arguments to update many MaterialCosts.
     * @example
     * // Update many MaterialCosts
     * const materialCost = await prisma.materialCost.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MaterialCosts and only return the `id`
     * const materialCostWithIdOnly = await prisma.materialCost.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MaterialCostUpdateManyAndReturnArgs>(args: SelectSubset<T, MaterialCostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialCostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MaterialCost.
     * @param {MaterialCostUpsertArgs} args - Arguments to update or create a MaterialCost.
     * @example
     * // Update or create a MaterialCost
     * const materialCost = await prisma.materialCost.upsert({
     *   create: {
     *     // ... data to create a MaterialCost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MaterialCost we want to update
     *   }
     * })
     */
    upsert<T extends MaterialCostUpsertArgs>(args: SelectSubset<T, MaterialCostUpsertArgs<ExtArgs>>): Prisma__MaterialCostClient<$Result.GetResult<Prisma.$MaterialCostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MaterialCosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialCostCountArgs} args - Arguments to filter MaterialCosts to count.
     * @example
     * // Count the number of MaterialCosts
     * const count = await prisma.materialCost.count({
     *   where: {
     *     // ... the filter for the MaterialCosts we want to count
     *   }
     * })
    **/
    count<T extends MaterialCostCountArgs>(
      args?: Subset<T, MaterialCostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterialCostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MaterialCost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialCostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterialCostAggregateArgs>(args: Subset<T, MaterialCostAggregateArgs>): Prisma.PrismaPromise<GetMaterialCostAggregateType<T>>

    /**
     * Group by MaterialCost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialCostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaterialCostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaterialCostGroupByArgs['orderBy'] }
        : { orderBy?: MaterialCostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaterialCostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterialCostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MaterialCost model
   */
  readonly fields: MaterialCostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MaterialCost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaterialCostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends MaterialCost$projectArgs<ExtArgs> = {}>(args?: Subset<T, MaterialCost$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MaterialCost model
   */
  interface MaterialCostFieldRefs {
    readonly id: FieldRef<"MaterialCost", 'String'>
    readonly projectId: FieldRef<"MaterialCost", 'String'>
    readonly supplier: FieldRef<"MaterialCost", 'String'>
    readonly material: FieldRef<"MaterialCost", 'String'>
    readonly quantity: FieldRef<"MaterialCost", 'Float'>
    readonly unitCost: FieldRef<"MaterialCost", 'Float'>
    readonly totalCost: FieldRef<"MaterialCost", 'Float'>
    readonly invoiceRef: FieldRef<"MaterialCost", 'String'>
    readonly date: FieldRef<"MaterialCost", 'DateTime'>
    readonly category: FieldRef<"MaterialCost", 'String'>
    readonly createdAt: FieldRef<"MaterialCost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MaterialCost findUnique
   */
  export type MaterialCostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialCost
     */
    select?: MaterialCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialCost
     */
    omit?: MaterialCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialCostInclude<ExtArgs> | null
    /**
     * Filter, which MaterialCost to fetch.
     */
    where: MaterialCostWhereUniqueInput
  }

  /**
   * MaterialCost findUniqueOrThrow
   */
  export type MaterialCostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialCost
     */
    select?: MaterialCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialCost
     */
    omit?: MaterialCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialCostInclude<ExtArgs> | null
    /**
     * Filter, which MaterialCost to fetch.
     */
    where: MaterialCostWhereUniqueInput
  }

  /**
   * MaterialCost findFirst
   */
  export type MaterialCostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialCost
     */
    select?: MaterialCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialCost
     */
    omit?: MaterialCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialCostInclude<ExtArgs> | null
    /**
     * Filter, which MaterialCost to fetch.
     */
    where?: MaterialCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialCosts to fetch.
     */
    orderBy?: MaterialCostOrderByWithRelationInput | MaterialCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaterialCosts.
     */
    cursor?: MaterialCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialCosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaterialCosts.
     */
    distinct?: MaterialCostScalarFieldEnum | MaterialCostScalarFieldEnum[]
  }

  /**
   * MaterialCost findFirstOrThrow
   */
  export type MaterialCostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialCost
     */
    select?: MaterialCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialCost
     */
    omit?: MaterialCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialCostInclude<ExtArgs> | null
    /**
     * Filter, which MaterialCost to fetch.
     */
    where?: MaterialCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialCosts to fetch.
     */
    orderBy?: MaterialCostOrderByWithRelationInput | MaterialCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaterialCosts.
     */
    cursor?: MaterialCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialCosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaterialCosts.
     */
    distinct?: MaterialCostScalarFieldEnum | MaterialCostScalarFieldEnum[]
  }

  /**
   * MaterialCost findMany
   */
  export type MaterialCostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialCost
     */
    select?: MaterialCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialCost
     */
    omit?: MaterialCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialCostInclude<ExtArgs> | null
    /**
     * Filter, which MaterialCosts to fetch.
     */
    where?: MaterialCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialCosts to fetch.
     */
    orderBy?: MaterialCostOrderByWithRelationInput | MaterialCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MaterialCosts.
     */
    cursor?: MaterialCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialCosts.
     */
    skip?: number
    distinct?: MaterialCostScalarFieldEnum | MaterialCostScalarFieldEnum[]
  }

  /**
   * MaterialCost create
   */
  export type MaterialCostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialCost
     */
    select?: MaterialCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialCost
     */
    omit?: MaterialCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialCostInclude<ExtArgs> | null
    /**
     * The data needed to create a MaterialCost.
     */
    data: XOR<MaterialCostCreateInput, MaterialCostUncheckedCreateInput>
  }

  /**
   * MaterialCost createMany
   */
  export type MaterialCostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MaterialCosts.
     */
    data: MaterialCostCreateManyInput | MaterialCostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MaterialCost createManyAndReturn
   */
  export type MaterialCostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialCost
     */
    select?: MaterialCostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialCost
     */
    omit?: MaterialCostOmit<ExtArgs> | null
    /**
     * The data used to create many MaterialCosts.
     */
    data: MaterialCostCreateManyInput | MaterialCostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialCostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MaterialCost update
   */
  export type MaterialCostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialCost
     */
    select?: MaterialCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialCost
     */
    omit?: MaterialCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialCostInclude<ExtArgs> | null
    /**
     * The data needed to update a MaterialCost.
     */
    data: XOR<MaterialCostUpdateInput, MaterialCostUncheckedUpdateInput>
    /**
     * Choose, which MaterialCost to update.
     */
    where: MaterialCostWhereUniqueInput
  }

  /**
   * MaterialCost updateMany
   */
  export type MaterialCostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MaterialCosts.
     */
    data: XOR<MaterialCostUpdateManyMutationInput, MaterialCostUncheckedUpdateManyInput>
    /**
     * Filter which MaterialCosts to update
     */
    where?: MaterialCostWhereInput
    /**
     * Limit how many MaterialCosts to update.
     */
    limit?: number
  }

  /**
   * MaterialCost updateManyAndReturn
   */
  export type MaterialCostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialCost
     */
    select?: MaterialCostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialCost
     */
    omit?: MaterialCostOmit<ExtArgs> | null
    /**
     * The data used to update MaterialCosts.
     */
    data: XOR<MaterialCostUpdateManyMutationInput, MaterialCostUncheckedUpdateManyInput>
    /**
     * Filter which MaterialCosts to update
     */
    where?: MaterialCostWhereInput
    /**
     * Limit how many MaterialCosts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialCostIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MaterialCost upsert
   */
  export type MaterialCostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialCost
     */
    select?: MaterialCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialCost
     */
    omit?: MaterialCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialCostInclude<ExtArgs> | null
    /**
     * The filter to search for the MaterialCost to update in case it exists.
     */
    where: MaterialCostWhereUniqueInput
    /**
     * In case the MaterialCost found by the `where` argument doesn't exist, create a new MaterialCost with this data.
     */
    create: XOR<MaterialCostCreateInput, MaterialCostUncheckedCreateInput>
    /**
     * In case the MaterialCost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaterialCostUpdateInput, MaterialCostUncheckedUpdateInput>
  }

  /**
   * MaterialCost delete
   */
  export type MaterialCostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialCost
     */
    select?: MaterialCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialCost
     */
    omit?: MaterialCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialCostInclude<ExtArgs> | null
    /**
     * Filter which MaterialCost to delete.
     */
    where: MaterialCostWhereUniqueInput
  }

  /**
   * MaterialCost deleteMany
   */
  export type MaterialCostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaterialCosts to delete
     */
    where?: MaterialCostWhereInput
    /**
     * Limit how many MaterialCosts to delete.
     */
    limit?: number
  }

  /**
   * MaterialCost.project
   */
  export type MaterialCost$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * MaterialCost without action
   */
  export type MaterialCostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialCost
     */
    select?: MaterialCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialCost
     */
    omit?: MaterialCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialCostInclude<ExtArgs> | null
  }


  /**
   * Model SupplierInvoice
   */

  export type AggregateSupplierInvoice = {
    _count: SupplierInvoiceCountAggregateOutputType | null
    _avg: SupplierInvoiceAvgAggregateOutputType | null
    _sum: SupplierInvoiceSumAggregateOutputType | null
    _min: SupplierInvoiceMinAggregateOutputType | null
    _max: SupplierInvoiceMaxAggregateOutputType | null
  }

  export type SupplierInvoiceAvgAggregateOutputType = {
    totalAmount: number | null
  }

  export type SupplierInvoiceSumAggregateOutputType = {
    totalAmount: number | null
  }

  export type SupplierInvoiceMinAggregateOutputType = {
    id: string | null
    supplier: string | null
    invoiceRef: string | null
    date: Date | null
    totalAmount: number | null
    fileUrl: string | null
    processed: boolean | null
    createdAt: Date | null
  }

  export type SupplierInvoiceMaxAggregateOutputType = {
    id: string | null
    supplier: string | null
    invoiceRef: string | null
    date: Date | null
    totalAmount: number | null
    fileUrl: string | null
    processed: boolean | null
    createdAt: Date | null
  }

  export type SupplierInvoiceCountAggregateOutputType = {
    id: number
    supplier: number
    invoiceRef: number
    date: number
    totalAmount: number
    items: number
    fileUrl: number
    processed: number
    createdAt: number
    _all: number
  }


  export type SupplierInvoiceAvgAggregateInputType = {
    totalAmount?: true
  }

  export type SupplierInvoiceSumAggregateInputType = {
    totalAmount?: true
  }

  export type SupplierInvoiceMinAggregateInputType = {
    id?: true
    supplier?: true
    invoiceRef?: true
    date?: true
    totalAmount?: true
    fileUrl?: true
    processed?: true
    createdAt?: true
  }

  export type SupplierInvoiceMaxAggregateInputType = {
    id?: true
    supplier?: true
    invoiceRef?: true
    date?: true
    totalAmount?: true
    fileUrl?: true
    processed?: true
    createdAt?: true
  }

  export type SupplierInvoiceCountAggregateInputType = {
    id?: true
    supplier?: true
    invoiceRef?: true
    date?: true
    totalAmount?: true
    items?: true
    fileUrl?: true
    processed?: true
    createdAt?: true
    _all?: true
  }

  export type SupplierInvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupplierInvoice to aggregate.
     */
    where?: SupplierInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierInvoices to fetch.
     */
    orderBy?: SupplierInvoiceOrderByWithRelationInput | SupplierInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SupplierInvoices
    **/
    _count?: true | SupplierInvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupplierInvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupplierInvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierInvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierInvoiceMaxAggregateInputType
  }

  export type GetSupplierInvoiceAggregateType<T extends SupplierInvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplierInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplierInvoice[P]>
      : GetScalarType<T[P], AggregateSupplierInvoice[P]>
  }




  export type SupplierInvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierInvoiceWhereInput
    orderBy?: SupplierInvoiceOrderByWithAggregationInput | SupplierInvoiceOrderByWithAggregationInput[]
    by: SupplierInvoiceScalarFieldEnum[] | SupplierInvoiceScalarFieldEnum
    having?: SupplierInvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierInvoiceCountAggregateInputType | true
    _avg?: SupplierInvoiceAvgAggregateInputType
    _sum?: SupplierInvoiceSumAggregateInputType
    _min?: SupplierInvoiceMinAggregateInputType
    _max?: SupplierInvoiceMaxAggregateInputType
  }

  export type SupplierInvoiceGroupByOutputType = {
    id: string
    supplier: string
    invoiceRef: string
    date: Date
    totalAmount: number
    items: JsonValue
    fileUrl: string | null
    processed: boolean
    createdAt: Date
    _count: SupplierInvoiceCountAggregateOutputType | null
    _avg: SupplierInvoiceAvgAggregateOutputType | null
    _sum: SupplierInvoiceSumAggregateOutputType | null
    _min: SupplierInvoiceMinAggregateOutputType | null
    _max: SupplierInvoiceMaxAggregateOutputType | null
  }

  type GetSupplierInvoiceGroupByPayload<T extends SupplierInvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierInvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierInvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierInvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierInvoiceGroupByOutputType[P]>
        }
      >
    >


  export type SupplierInvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplier?: boolean
    invoiceRef?: boolean
    date?: boolean
    totalAmount?: boolean
    items?: boolean
    fileUrl?: boolean
    processed?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["supplierInvoice"]>

  export type SupplierInvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplier?: boolean
    invoiceRef?: boolean
    date?: boolean
    totalAmount?: boolean
    items?: boolean
    fileUrl?: boolean
    processed?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["supplierInvoice"]>

  export type SupplierInvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplier?: boolean
    invoiceRef?: boolean
    date?: boolean
    totalAmount?: boolean
    items?: boolean
    fileUrl?: boolean
    processed?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["supplierInvoice"]>

  export type SupplierInvoiceSelectScalar = {
    id?: boolean
    supplier?: boolean
    invoiceRef?: boolean
    date?: boolean
    totalAmount?: boolean
    items?: boolean
    fileUrl?: boolean
    processed?: boolean
    createdAt?: boolean
  }

  export type SupplierInvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "supplier" | "invoiceRef" | "date" | "totalAmount" | "items" | "fileUrl" | "processed" | "createdAt", ExtArgs["result"]["supplierInvoice"]>

  export type $SupplierInvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SupplierInvoice"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      supplier: string
      invoiceRef: string
      date: Date
      totalAmount: number
      items: Prisma.JsonValue
      fileUrl: string | null
      processed: boolean
      createdAt: Date
    }, ExtArgs["result"]["supplierInvoice"]>
    composites: {}
  }

  type SupplierInvoiceGetPayload<S extends boolean | null | undefined | SupplierInvoiceDefaultArgs> = $Result.GetResult<Prisma.$SupplierInvoicePayload, S>

  type SupplierInvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupplierInvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupplierInvoiceCountAggregateInputType | true
    }

  export interface SupplierInvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SupplierInvoice'], meta: { name: 'SupplierInvoice' } }
    /**
     * Find zero or one SupplierInvoice that matches the filter.
     * @param {SupplierInvoiceFindUniqueArgs} args - Arguments to find a SupplierInvoice
     * @example
     * // Get one SupplierInvoice
     * const supplierInvoice = await prisma.supplierInvoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplierInvoiceFindUniqueArgs>(args: SelectSubset<T, SupplierInvoiceFindUniqueArgs<ExtArgs>>): Prisma__SupplierInvoiceClient<$Result.GetResult<Prisma.$SupplierInvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SupplierInvoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupplierInvoiceFindUniqueOrThrowArgs} args - Arguments to find a SupplierInvoice
     * @example
     * // Get one SupplierInvoice
     * const supplierInvoice = await prisma.supplierInvoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplierInvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, SupplierInvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupplierInvoiceClient<$Result.GetResult<Prisma.$SupplierInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupplierInvoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierInvoiceFindFirstArgs} args - Arguments to find a SupplierInvoice
     * @example
     * // Get one SupplierInvoice
     * const supplierInvoice = await prisma.supplierInvoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplierInvoiceFindFirstArgs>(args?: SelectSubset<T, SupplierInvoiceFindFirstArgs<ExtArgs>>): Prisma__SupplierInvoiceClient<$Result.GetResult<Prisma.$SupplierInvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupplierInvoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierInvoiceFindFirstOrThrowArgs} args - Arguments to find a SupplierInvoice
     * @example
     * // Get one SupplierInvoice
     * const supplierInvoice = await prisma.supplierInvoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplierInvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, SupplierInvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupplierInvoiceClient<$Result.GetResult<Prisma.$SupplierInvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SupplierInvoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierInvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SupplierInvoices
     * const supplierInvoices = await prisma.supplierInvoice.findMany()
     * 
     * // Get first 10 SupplierInvoices
     * const supplierInvoices = await prisma.supplierInvoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierInvoiceWithIdOnly = await prisma.supplierInvoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupplierInvoiceFindManyArgs>(args?: SelectSubset<T, SupplierInvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SupplierInvoice.
     * @param {SupplierInvoiceCreateArgs} args - Arguments to create a SupplierInvoice.
     * @example
     * // Create one SupplierInvoice
     * const SupplierInvoice = await prisma.supplierInvoice.create({
     *   data: {
     *     // ... data to create a SupplierInvoice
     *   }
     * })
     * 
     */
    create<T extends SupplierInvoiceCreateArgs>(args: SelectSubset<T, SupplierInvoiceCreateArgs<ExtArgs>>): Prisma__SupplierInvoiceClient<$Result.GetResult<Prisma.$SupplierInvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SupplierInvoices.
     * @param {SupplierInvoiceCreateManyArgs} args - Arguments to create many SupplierInvoices.
     * @example
     * // Create many SupplierInvoices
     * const supplierInvoice = await prisma.supplierInvoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupplierInvoiceCreateManyArgs>(args?: SelectSubset<T, SupplierInvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SupplierInvoices and returns the data saved in the database.
     * @param {SupplierInvoiceCreateManyAndReturnArgs} args - Arguments to create many SupplierInvoices.
     * @example
     * // Create many SupplierInvoices
     * const supplierInvoice = await prisma.supplierInvoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SupplierInvoices and only return the `id`
     * const supplierInvoiceWithIdOnly = await prisma.supplierInvoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupplierInvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, SupplierInvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierInvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SupplierInvoice.
     * @param {SupplierInvoiceDeleteArgs} args - Arguments to delete one SupplierInvoice.
     * @example
     * // Delete one SupplierInvoice
     * const SupplierInvoice = await prisma.supplierInvoice.delete({
     *   where: {
     *     // ... filter to delete one SupplierInvoice
     *   }
     * })
     * 
     */
    delete<T extends SupplierInvoiceDeleteArgs>(args: SelectSubset<T, SupplierInvoiceDeleteArgs<ExtArgs>>): Prisma__SupplierInvoiceClient<$Result.GetResult<Prisma.$SupplierInvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SupplierInvoice.
     * @param {SupplierInvoiceUpdateArgs} args - Arguments to update one SupplierInvoice.
     * @example
     * // Update one SupplierInvoice
     * const supplierInvoice = await prisma.supplierInvoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupplierInvoiceUpdateArgs>(args: SelectSubset<T, SupplierInvoiceUpdateArgs<ExtArgs>>): Prisma__SupplierInvoiceClient<$Result.GetResult<Prisma.$SupplierInvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SupplierInvoices.
     * @param {SupplierInvoiceDeleteManyArgs} args - Arguments to filter SupplierInvoices to delete.
     * @example
     * // Delete a few SupplierInvoices
     * const { count } = await prisma.supplierInvoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupplierInvoiceDeleteManyArgs>(args?: SelectSubset<T, SupplierInvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupplierInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierInvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SupplierInvoices
     * const supplierInvoice = await prisma.supplierInvoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupplierInvoiceUpdateManyArgs>(args: SelectSubset<T, SupplierInvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupplierInvoices and returns the data updated in the database.
     * @param {SupplierInvoiceUpdateManyAndReturnArgs} args - Arguments to update many SupplierInvoices.
     * @example
     * // Update many SupplierInvoices
     * const supplierInvoice = await prisma.supplierInvoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SupplierInvoices and only return the `id`
     * const supplierInvoiceWithIdOnly = await prisma.supplierInvoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SupplierInvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, SupplierInvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierInvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SupplierInvoice.
     * @param {SupplierInvoiceUpsertArgs} args - Arguments to update or create a SupplierInvoice.
     * @example
     * // Update or create a SupplierInvoice
     * const supplierInvoice = await prisma.supplierInvoice.upsert({
     *   create: {
     *     // ... data to create a SupplierInvoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SupplierInvoice we want to update
     *   }
     * })
     */
    upsert<T extends SupplierInvoiceUpsertArgs>(args: SelectSubset<T, SupplierInvoiceUpsertArgs<ExtArgs>>): Prisma__SupplierInvoiceClient<$Result.GetResult<Prisma.$SupplierInvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SupplierInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierInvoiceCountArgs} args - Arguments to filter SupplierInvoices to count.
     * @example
     * // Count the number of SupplierInvoices
     * const count = await prisma.supplierInvoice.count({
     *   where: {
     *     // ... the filter for the SupplierInvoices we want to count
     *   }
     * })
    **/
    count<T extends SupplierInvoiceCountArgs>(
      args?: Subset<T, SupplierInvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierInvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SupplierInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierInvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierInvoiceAggregateArgs>(args: Subset<T, SupplierInvoiceAggregateArgs>): Prisma.PrismaPromise<GetSupplierInvoiceAggregateType<T>>

    /**
     * Group by SupplierInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierInvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierInvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierInvoiceGroupByArgs['orderBy'] }
        : { orderBy?: SupplierInvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierInvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SupplierInvoice model
   */
  readonly fields: SupplierInvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SupplierInvoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierInvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SupplierInvoice model
   */
  interface SupplierInvoiceFieldRefs {
    readonly id: FieldRef<"SupplierInvoice", 'String'>
    readonly supplier: FieldRef<"SupplierInvoice", 'String'>
    readonly invoiceRef: FieldRef<"SupplierInvoice", 'String'>
    readonly date: FieldRef<"SupplierInvoice", 'DateTime'>
    readonly totalAmount: FieldRef<"SupplierInvoice", 'Float'>
    readonly items: FieldRef<"SupplierInvoice", 'Json'>
    readonly fileUrl: FieldRef<"SupplierInvoice", 'String'>
    readonly processed: FieldRef<"SupplierInvoice", 'Boolean'>
    readonly createdAt: FieldRef<"SupplierInvoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SupplierInvoice findUnique
   */
  export type SupplierInvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierInvoice
     */
    select?: SupplierInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierInvoice
     */
    omit?: SupplierInvoiceOmit<ExtArgs> | null
    /**
     * Filter, which SupplierInvoice to fetch.
     */
    where: SupplierInvoiceWhereUniqueInput
  }

  /**
   * SupplierInvoice findUniqueOrThrow
   */
  export type SupplierInvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierInvoice
     */
    select?: SupplierInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierInvoice
     */
    omit?: SupplierInvoiceOmit<ExtArgs> | null
    /**
     * Filter, which SupplierInvoice to fetch.
     */
    where: SupplierInvoiceWhereUniqueInput
  }

  /**
   * SupplierInvoice findFirst
   */
  export type SupplierInvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierInvoice
     */
    select?: SupplierInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierInvoice
     */
    omit?: SupplierInvoiceOmit<ExtArgs> | null
    /**
     * Filter, which SupplierInvoice to fetch.
     */
    where?: SupplierInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierInvoices to fetch.
     */
    orderBy?: SupplierInvoiceOrderByWithRelationInput | SupplierInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupplierInvoices.
     */
    cursor?: SupplierInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupplierInvoices.
     */
    distinct?: SupplierInvoiceScalarFieldEnum | SupplierInvoiceScalarFieldEnum[]
  }

  /**
   * SupplierInvoice findFirstOrThrow
   */
  export type SupplierInvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierInvoice
     */
    select?: SupplierInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierInvoice
     */
    omit?: SupplierInvoiceOmit<ExtArgs> | null
    /**
     * Filter, which SupplierInvoice to fetch.
     */
    where?: SupplierInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierInvoices to fetch.
     */
    orderBy?: SupplierInvoiceOrderByWithRelationInput | SupplierInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupplierInvoices.
     */
    cursor?: SupplierInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupplierInvoices.
     */
    distinct?: SupplierInvoiceScalarFieldEnum | SupplierInvoiceScalarFieldEnum[]
  }

  /**
   * SupplierInvoice findMany
   */
  export type SupplierInvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierInvoice
     */
    select?: SupplierInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierInvoice
     */
    omit?: SupplierInvoiceOmit<ExtArgs> | null
    /**
     * Filter, which SupplierInvoices to fetch.
     */
    where?: SupplierInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierInvoices to fetch.
     */
    orderBy?: SupplierInvoiceOrderByWithRelationInput | SupplierInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SupplierInvoices.
     */
    cursor?: SupplierInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierInvoices.
     */
    skip?: number
    distinct?: SupplierInvoiceScalarFieldEnum | SupplierInvoiceScalarFieldEnum[]
  }

  /**
   * SupplierInvoice create
   */
  export type SupplierInvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierInvoice
     */
    select?: SupplierInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierInvoice
     */
    omit?: SupplierInvoiceOmit<ExtArgs> | null
    /**
     * The data needed to create a SupplierInvoice.
     */
    data: XOR<SupplierInvoiceCreateInput, SupplierInvoiceUncheckedCreateInput>
  }

  /**
   * SupplierInvoice createMany
   */
  export type SupplierInvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SupplierInvoices.
     */
    data: SupplierInvoiceCreateManyInput | SupplierInvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SupplierInvoice createManyAndReturn
   */
  export type SupplierInvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierInvoice
     */
    select?: SupplierInvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierInvoice
     */
    omit?: SupplierInvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many SupplierInvoices.
     */
    data: SupplierInvoiceCreateManyInput | SupplierInvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SupplierInvoice update
   */
  export type SupplierInvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierInvoice
     */
    select?: SupplierInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierInvoice
     */
    omit?: SupplierInvoiceOmit<ExtArgs> | null
    /**
     * The data needed to update a SupplierInvoice.
     */
    data: XOR<SupplierInvoiceUpdateInput, SupplierInvoiceUncheckedUpdateInput>
    /**
     * Choose, which SupplierInvoice to update.
     */
    where: SupplierInvoiceWhereUniqueInput
  }

  /**
   * SupplierInvoice updateMany
   */
  export type SupplierInvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SupplierInvoices.
     */
    data: XOR<SupplierInvoiceUpdateManyMutationInput, SupplierInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which SupplierInvoices to update
     */
    where?: SupplierInvoiceWhereInput
    /**
     * Limit how many SupplierInvoices to update.
     */
    limit?: number
  }

  /**
   * SupplierInvoice updateManyAndReturn
   */
  export type SupplierInvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierInvoice
     */
    select?: SupplierInvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierInvoice
     */
    omit?: SupplierInvoiceOmit<ExtArgs> | null
    /**
     * The data used to update SupplierInvoices.
     */
    data: XOR<SupplierInvoiceUpdateManyMutationInput, SupplierInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which SupplierInvoices to update
     */
    where?: SupplierInvoiceWhereInput
    /**
     * Limit how many SupplierInvoices to update.
     */
    limit?: number
  }

  /**
   * SupplierInvoice upsert
   */
  export type SupplierInvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierInvoice
     */
    select?: SupplierInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierInvoice
     */
    omit?: SupplierInvoiceOmit<ExtArgs> | null
    /**
     * The filter to search for the SupplierInvoice to update in case it exists.
     */
    where: SupplierInvoiceWhereUniqueInput
    /**
     * In case the SupplierInvoice found by the `where` argument doesn't exist, create a new SupplierInvoice with this data.
     */
    create: XOR<SupplierInvoiceCreateInput, SupplierInvoiceUncheckedCreateInput>
    /**
     * In case the SupplierInvoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierInvoiceUpdateInput, SupplierInvoiceUncheckedUpdateInput>
  }

  /**
   * SupplierInvoice delete
   */
  export type SupplierInvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierInvoice
     */
    select?: SupplierInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierInvoice
     */
    omit?: SupplierInvoiceOmit<ExtArgs> | null
    /**
     * Filter which SupplierInvoice to delete.
     */
    where: SupplierInvoiceWhereUniqueInput
  }

  /**
   * SupplierInvoice deleteMany
   */
  export type SupplierInvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupplierInvoices to delete
     */
    where?: SupplierInvoiceWhereInput
    /**
     * Limit how many SupplierInvoices to delete.
     */
    limit?: number
  }

  /**
   * SupplierInvoice without action
   */
  export type SupplierInvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierInvoice
     */
    select?: SupplierInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierInvoice
     */
    omit?: SupplierInvoiceOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    password: 'password',
    role: 'role',
    externalId: 'externalId',
    mondayUserId: 'mondayUserId',
    copilotUserId: 'copilotUserId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ChatSessionScalarFieldEnum: {
    id: 'id',
    title: 'title',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    systemPrompt: 'systemPrompt',
    isActive: 'isActive',
    userId: 'userId',
    userName: 'userName',
    userEmail: 'userEmail',
    ipAddress: 'ipAddress',
    location: 'location',
    source: 'source',
    category: 'category',
    mondayItemId: 'mondayItemId',
    mondaySynced: 'mondaySynced',
    copilotSynced: 'copilotSynced',
    databaseSynced: 'databaseSynced',
    lastMondaySync: 'lastMondaySync',
    lastCopilotSync: 'lastCopilotSync'
  };

  export type ChatSessionScalarFieldEnum = (typeof ChatSessionScalarFieldEnum)[keyof typeof ChatSessionScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    role: 'role',
    content: 'content',
    timestamp: 'timestamp',
    isError: 'isError',
    userId: 'userId',
    functionName: 'functionName',
    functionArgs: 'functionArgs'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const SessionTagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    sessionId: 'sessionId'
  };

  export type SessionTagScalarFieldEnum = (typeof SessionTagScalarFieldEnum)[keyof typeof SessionTagScalarFieldEnum]


  export const MondaySyncScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    itemId: 'itemId',
    boardId: 'boardId',
    lastSynced: 'lastSynced'
  };

  export type MondaySyncScalarFieldEnum = (typeof MondaySyncScalarFieldEnum)[keyof typeof MondaySyncScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    companyName: 'companyName',
    billingAddress: 'billingAddress',
    shippingAddress: 'shippingAddress',
    taxId: 'taxId',
    phoneNumber: 'phoneNumber',
    stripeCustomerId: 'stripeCustomerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    sku: 'sku',
    name: 'name',
    description: 'description',
    category: 'category',
    basePrice: 'basePrice',
    currency: 'currency',
    specifications: 'specifications',
    images: 'images',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    orderNumber: 'orderNumber',
    customerId: 'customerId',
    status: 'status',
    subtotal: 'subtotal',
    tax: 'tax',
    shipping: 'shipping',
    total: 'total',
    currency: 'currency',
    shippingAddress: 'shippingAddress',
    shippingMethod: 'shippingMethod',
    trackingNumber: 'trackingNumber',
    shippedAt: 'shippedAt',
    deliveredAt: 'deliveredAt',
    paymentStatus: 'paymentStatus',
    paymentIntentId: 'paymentIntentId',
    paidAt: 'paidAt',
    customerNotes: 'customerNotes',
    internalNotes: 'internalNotes',
    invoiceId: 'invoiceId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const OrderItemScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    productId: 'productId',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    totalPrice: 'totalPrice',
    productSnapshot: 'productSnapshot',
    createdAt: 'createdAt'
  };

  export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    status: 'status',
    planId: 'planId',
    billingCycle: 'billingCycle',
    currentPeriodStart: 'currentPeriodStart',
    currentPeriodEnd: 'currentPeriodEnd',
    nextBillingDate: 'nextBillingDate',
    stripeSubscriptionId: 'stripeSubscriptionId',
    metadata: 'metadata',
    cancelledAt: 'cancelledAt',
    cancelReason: 'cancelReason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const SubscriptionPlanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    price: 'price',
    currency: 'currency',
    interval: 'interval',
    features: 'features',
    limits: 'limits',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionPlanScalarFieldEnum = (typeof SubscriptionPlanScalarFieldEnum)[keyof typeof SubscriptionPlanScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    invoiceNumber: 'invoiceNumber',
    customerId: 'customerId',
    type: 'type',
    subscriptionId: 'subscriptionId',
    subtotal: 'subtotal',
    tax: 'tax',
    total: 'total',
    currency: 'currency',
    status: 'status',
    dueDate: 'dueDate',
    paidAt: 'paidAt',
    paymentIntentId: 'paymentIntentId',
    paymentMethod: 'paymentMethod',
    pdfUrl: 'pdfUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const PaymentMethodScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    stripePaymentMethodId: 'stripePaymentMethodId',
    type: 'type',
    last4: 'last4',
    brand: 'brand',
    expiryMonth: 'expiryMonth',
    expiryYear: 'expiryYear',
    isDefault: 'isDefault',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentMethodScalarFieldEnum = (typeof PaymentMethodScalarFieldEnum)[keyof typeof PaymentMethodScalarFieldEnum]


  export const InventoryScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    location: 'location',
    quantity: 'quantity',
    reservedQuantity: 'reservedQuantity',
    availableQuantity: 'availableQuantity',
    reorderPoint: 'reorderPoint',
    reorderQuantity: 'reorderQuantity',
    batchNumber: 'batchNumber',
    serialNumbers: 'serialNumbers',
    lastRestocked: 'lastRestocked',
    lastCounted: 'lastCounted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InventoryScalarFieldEnum = (typeof InventoryScalarFieldEnum)[keyof typeof InventoryScalarFieldEnum]


  export const CartScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    userId: 'userId',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CartScalarFieldEnum = (typeof CartScalarFieldEnum)[keyof typeof CartScalarFieldEnum]


  export const CartItemScalarFieldEnum: {
    id: 'id',
    cartId: 'cartId',
    productId: 'productId',
    quantity: 'quantity',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CartItemScalarFieldEnum = (typeof CartItemScalarFieldEnum)[keyof typeof CartItemScalarFieldEnum]


  export const PriceHistoryScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    price: 'price',
    previousPrice: 'previousPrice',
    currency: 'currency',
    reason: 'reason',
    effectiveFrom: 'effectiveFrom',
    effectiveUntil: 'effectiveUntil',
    createdAt: 'createdAt'
  };

  export type PriceHistoryScalarFieldEnum = (typeof PriceHistoryScalarFieldEnum)[keyof typeof PriceHistoryScalarFieldEnum]


  export const SystemHealthScalarFieldEnum: {
    id: 'id',
    service: 'service',
    status: 'status',
    responseTime: 'responseTime',
    errorRate: 'errorRate',
    uptime: 'uptime',
    message: 'message',
    lastCheck: 'lastCheck',
    nextCheck: 'nextCheck',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SystemHealthScalarFieldEnum = (typeof SystemHealthScalarFieldEnum)[keyof typeof SystemHealthScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    title: 'title',
    message: 'message',
    priority: 'priority',
    channel: 'channel',
    read: 'read',
    readAt: 'readAt',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const AnalyticsEventScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    userId: 'userId',
    eventName: 'eventName',
    eventCategory: 'eventCategory',
    eventData: 'eventData',
    dataPoints: 'dataPoints',
    context: 'context',
    timestamp: 'timestamp',
    createdAt: 'createdAt'
  };

  export type AnalyticsEventScalarFieldEnum = (typeof AnalyticsEventScalarFieldEnum)[keyof typeof AnalyticsEventScalarFieldEnum]


  export const AnalyticsSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    visitorId: 'visitorId',
    startTime: 'startTime',
    endTime: 'endTime',
    duration: 'duration',
    pageViews: 'pageViews',
    events: 'events',
    bounced: 'bounced',
    source: 'source',
    medium: 'medium',
    campaign: 'campaign',
    content: 'content',
    term: 'term',
    deviceType: 'deviceType',
    deviceBrand: 'deviceBrand',
    browser: 'browser',
    os: 'os',
    screenResolution: 'screenResolution',
    country: 'country',
    region: 'region',
    city: 'city',
    engagementScore: 'engagementScore',
    conversionValue: 'conversionValue',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AnalyticsSessionScalarFieldEnum = (typeof AnalyticsSessionScalarFieldEnum)[keyof typeof AnalyticsSessionScalarFieldEnum]


  export const AnalyticsMetricScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    category: 'category',
    calculation: 'calculation',
    dailyValues: 'dailyValues',
    weeklyValues: 'weeklyValues',
    monthlyValues: 'monthlyValues',
    lastCalculated: 'lastCalculated',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AnalyticsMetricScalarFieldEnum = (typeof AnalyticsMetricScalarFieldEnum)[keyof typeof AnalyticsMetricScalarFieldEnum]


  export const AnalyticsCohortScalarFieldEnum: {
    id: 'id',
    name: 'name',
    definition: 'definition',
    userCount: 'userCount',
    retentionData: 'retentionData',
    engagementData: 'engagementData',
    revenueData: 'revenueData',
    lastUpdated: 'lastUpdated',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AnalyticsCohortScalarFieldEnum = (typeof AnalyticsCohortScalarFieldEnum)[keyof typeof AnalyticsCohortScalarFieldEnum]


  export const AnalyticsFunnelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    steps: 'steps',
    conversionRates: 'conversionRates',
    dropoffRates: 'dropoffRates',
    avgTimePerStep: 'avgTimePerStep',
    lastCalculated: 'lastCalculated',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AnalyticsFunnelScalarFieldEnum = (typeof AnalyticsFunnelScalarFieldEnum)[keyof typeof AnalyticsFunnelScalarFieldEnum]


  export const AnalyticsAttributionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    conversionId: 'conversionId',
    conversionType: 'conversionType',
    conversionValue: 'conversionValue',
    touchpoints: 'touchpoints',
    model: 'model',
    channelWeights: 'channelWeights',
    convertedAt: 'convertedAt',
    createdAt: 'createdAt'
  };

  export type AnalyticsAttributionScalarFieldEnum = (typeof AnalyticsAttributionScalarFieldEnum)[keyof typeof AnalyticsAttributionScalarFieldEnum]


  export const AnalyticsSegmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    conditions: 'conditions',
    userCount: 'userCount',
    avgEngagement: 'avgEngagement',
    avgRevenue: 'avgRevenue',
    conversionRate: 'conversionRate',
    lastUpdated: 'lastUpdated',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AnalyticsSegmentScalarFieldEnum = (typeof AnalyticsSegmentScalarFieldEnum)[keyof typeof AnalyticsSegmentScalarFieldEnum]


  export const AnalyticsReportScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    definition: 'definition',
    schedule: 'schedule',
    lastRun: 'lastRun',
    nextRun: 'nextRun',
    recipients: 'recipients',
    format: 'format',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AnalyticsReportScalarFieldEnum = (typeof AnalyticsReportScalarFieldEnum)[keyof typeof AnalyticsReportScalarFieldEnum]


  export const QuizSessionScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    quizId: 'quizId',
    source: 'source',
    utmSource: 'utmSource',
    utmMedium: 'utmMedium',
    utmCampaign: 'utmCampaign',
    utmContent: 'utmContent',
    contentId: 'contentId',
    campaignId: 'campaignId',
    deviceInfo: 'deviceInfo',
    landingPage: 'landingPage',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    status: 'status',
    createdAt: 'createdAt',
    startTime: 'startTime',
    endTime: 'endTime',
    completionRate: 'completionRate',
    userName: 'userName',
    email: 'email',
    phoneNumber: 'phoneNumber',
    companyName: 'companyName',
    userType: 'userType',
    selectedBrand: 'selectedBrand',
    userSegment: 'userSegment',
    crewSize: 'crewSize',
    leadQualityScore: 'leadQualityScore',
    version: 'version'
  };

  export type QuizSessionScalarFieldEnum = (typeof QuizSessionScalarFieldEnum)[keyof typeof QuizSessionScalarFieldEnum]


  export const QuizResponseScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    questionId: 'questionId',
    questionType: 'questionType',
    responseValue: 'responseValue',
    responseTime: 'responseTime',
    createdAt: 'createdAt'
  };

  export type QuizResponseScalarFieldEnum = (typeof QuizResponseScalarFieldEnum)[keyof typeof QuizResponseScalarFieldEnum]


  export const BehavioralInteractionScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    interactionType: 'interactionType',
    element: 'element',
    position: 'position',
    viewport: 'viewport',
    duration: 'duration',
    metadata: 'metadata',
    timestamp: 'timestamp'
  };

  export type BehavioralInteractionScalarFieldEnum = (typeof BehavioralInteractionScalarFieldEnum)[keyof typeof BehavioralInteractionScalarFieldEnum]


  export const QuizConversionScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    conversionType: 'conversionType',
    conversionValue: 'conversionValue',
    orderId: 'orderId',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type QuizConversionScalarFieldEnum = (typeof QuizConversionScalarFieldEnum)[keyof typeof QuizConversionScalarFieldEnum]


  export const ABTestExperimentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    status: 'status',
    startDate: 'startDate',
    endDate: 'endDate',
    testType: 'testType',
    control: 'control',
    variants: 'variants',
    allocation: 'allocation',
    metrics: 'metrics',
    results: 'results',
    winner: 'winner',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ABTestExperimentScalarFieldEnum = (typeof ABTestExperimentScalarFieldEnum)[keyof typeof ABTestExperimentScalarFieldEnum]


  export const QuizBrandScalarFieldEnum: {
    id: 'id',
    brandId: 'brandId',
    name: 'name',
    displayName: 'displayName',
    color: 'color',
    voltage: 'voltage',
    voltageOptions: 'voltageOptions',
    marketShare: 'marketShare',
    popularWith: 'popularWith',
    category: 'category',
    active: 'active',
    createdAt: 'createdAt'
  };

  export type QuizBrandScalarFieldEnum = (typeof QuizBrandScalarFieldEnum)[keyof typeof QuizBrandScalarFieldEnum]


  export const QuizRoutingRuleScalarFieldEnum: {
    id: 'id',
    userType: 'userType',
    brand: 'brand',
    trade: 'trade',
    nextQuestionId: 'nextQuestionId',
    condition: 'condition',
    priority: 'priority',
    active: 'active',
    createdAt: 'createdAt'
  };

  export type QuizRoutingRuleScalarFieldEnum = (typeof QuizRoutingRuleScalarFieldEnum)[keyof typeof QuizRoutingRuleScalarFieldEnum]


  export const QuizInterventionScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    interventionType: 'interventionType',
    triggerReason: 'triggerReason',
    questionId: 'questionId',
    shownAt: 'shownAt',
    userAction: 'userAction',
    actionTimestamp: 'actionTimestamp'
  };

  export type QuizInterventionScalarFieldEnum = (typeof QuizInterventionScalarFieldEnum)[keyof typeof QuizInterventionScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    serviceCode: 'serviceCode',
    name: 'name',
    description: 'description',
    category: 'category',
    basePrice: 'basePrice',
    pricingModel: 'pricingModel',
    currency: 'currency',
    specifications: 'specifications',
    portfolio: 'portfolio',
    leadTime: 'leadTime',
    capacity: 'capacity',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    projectRef: 'projectRef',
    clientId: 'clientId',
    name: 'name',
    description: 'description',
    service: 'service',
    status: 'status',
    currentStage: 'currentStage',
    stagesCompleted: 'stagesCompleted',
    quotedAmount: 'quotedAmount',
    actualCost: 'actualCost',
    invoicedAmount: 'invoicedAmount',
    paidAmount: 'paidAmount',
    startDate: 'startDate',
    targetDate: 'targetDate',
    completedDate: 'completedDate',
    location: 'location',
    notes: 'notes',
    priority: 'priority',
    orderId: 'orderId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    serviceId: 'serviceId'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const ProjectStageScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    stageName: 'stageName',
    status: 'status',
    notes: 'notes',
    completedAt: 'completedAt',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectStageScalarFieldEnum = (typeof ProjectStageScalarFieldEnum)[keyof typeof ProjectStageScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    filename: 'filename',
    originalName: 'originalName',
    fileType: 'fileType',
    fileSize: 'fileSize',
    fileUrl: 'fileUrl',
    uploadedAt: 'uploadedAt'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const DocumentGenerationScalarFieldEnum: {
    id: 'id',
    documentId: 'documentId',
    documentType: 'documentType',
    documentNumber: 'documentNumber',
    templateData: 'templateData',
    status: 'status',
    generatedBy: 'generatedBy',
    generatedAt: 'generatedAt',
    autoSend: 'autoSend',
    emailSent: 'emailSent',
    emailSentAt: 'emailSentAt',
    recipientEmail: 'recipientEmail',
    fileUrl: 'fileUrl',
    errorMessage: 'errorMessage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DocumentGenerationScalarFieldEnum = (typeof DocumentGenerationScalarFieldEnum)[keyof typeof DocumentGenerationScalarFieldEnum]


  export const QuoteScalarFieldEnum: {
    id: 'id',
    quoteNumber: 'quoteNumber',
    customerId: 'customerId',
    title: 'title',
    description: 'description',
    services: 'services',
    subtotal: 'subtotal',
    tax: 'tax',
    total: 'total',
    currency: 'currency',
    validUntil: 'validUntil',
    status: 'status',
    terms: 'terms',
    notes: 'notes',
    convertedToProjectId: 'convertedToProjectId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    serviceId: 'serviceId'
  };

  export type QuoteScalarFieldEnum = (typeof QuoteScalarFieldEnum)[keyof typeof QuoteScalarFieldEnum]


  export const MaterialCostScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    supplier: 'supplier',
    material: 'material',
    quantity: 'quantity',
    unitCost: 'unitCost',
    totalCost: 'totalCost',
    invoiceRef: 'invoiceRef',
    date: 'date',
    category: 'category',
    createdAt: 'createdAt'
  };

  export type MaterialCostScalarFieldEnum = (typeof MaterialCostScalarFieldEnum)[keyof typeof MaterialCostScalarFieldEnum]


  export const SupplierInvoiceScalarFieldEnum: {
    id: 'id',
    supplier: 'supplier',
    invoiceRef: 'invoiceRef',
    date: 'date',
    totalAmount: 'totalAmount',
    items: 'items',
    fileUrl: 'fileUrl',
    processed: 'processed',
    createdAt: 'createdAt'
  };

  export type SupplierInvoiceScalarFieldEnum = (typeof SupplierInvoiceScalarFieldEnum)[keyof typeof SupplierInvoiceScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    externalId?: StringNullableFilter<"User"> | string | null
    mondayUserId?: StringNullableFilter<"User"> | string | null
    copilotUserId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: ChatSessionListRelationFilter
    messages?: MessageListRelationFilter
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    cart?: XOR<CartNullableScalarRelationFilter, CartWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    role?: SortOrder
    externalId?: SortOrderInput | SortOrder
    mondayUserId?: SortOrderInput | SortOrder
    copilotUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessions?: ChatSessionOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
    customer?: CustomerOrderByWithRelationInput
    cart?: CartOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    externalId?: StringNullableFilter<"User"> | string | null
    mondayUserId?: StringNullableFilter<"User"> | string | null
    copilotUserId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: ChatSessionListRelationFilter
    messages?: MessageListRelationFilter
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    cart?: XOR<CartNullableScalarRelationFilter, CartWhereInput> | null
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    role?: SortOrder
    externalId?: SortOrderInput | SortOrder
    mondayUserId?: SortOrderInput | SortOrder
    copilotUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: StringWithAggregatesFilter<"User"> | string
    externalId?: StringNullableWithAggregatesFilter<"User"> | string | null
    mondayUserId?: StringNullableWithAggregatesFilter<"User"> | string | null
    copilotUserId?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ChatSessionWhereInput = {
    AND?: ChatSessionWhereInput | ChatSessionWhereInput[]
    OR?: ChatSessionWhereInput[]
    NOT?: ChatSessionWhereInput | ChatSessionWhereInput[]
    id?: StringFilter<"ChatSession"> | string
    title?: StringFilter<"ChatSession"> | string
    createdAt?: DateTimeFilter<"ChatSession"> | Date | string
    updatedAt?: DateTimeFilter<"ChatSession"> | Date | string
    systemPrompt?: StringNullableFilter<"ChatSession"> | string | null
    isActive?: BoolFilter<"ChatSession"> | boolean
    userId?: StringNullableFilter<"ChatSession"> | string | null
    userName?: StringNullableFilter<"ChatSession"> | string | null
    userEmail?: StringNullableFilter<"ChatSession"> | string | null
    ipAddress?: StringNullableFilter<"ChatSession"> | string | null
    location?: StringNullableFilter<"ChatSession"> | string | null
    source?: StringNullableFilter<"ChatSession"> | string | null
    category?: StringNullableFilter<"ChatSession"> | string | null
    mondayItemId?: StringNullableFilter<"ChatSession"> | string | null
    mondaySynced?: BoolFilter<"ChatSession"> | boolean
    copilotSynced?: BoolFilter<"ChatSession"> | boolean
    databaseSynced?: BoolFilter<"ChatSession"> | boolean
    lastMondaySync?: DateTimeNullableFilter<"ChatSession"> | Date | string | null
    lastCopilotSync?: DateTimeNullableFilter<"ChatSession"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    messages?: MessageListRelationFilter
    tags?: SessionTagListRelationFilter
  }

  export type ChatSessionOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    systemPrompt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    userId?: SortOrderInput | SortOrder
    userName?: SortOrderInput | SortOrder
    userEmail?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    mondayItemId?: SortOrderInput | SortOrder
    mondaySynced?: SortOrder
    copilotSynced?: SortOrder
    databaseSynced?: SortOrder
    lastMondaySync?: SortOrderInput | SortOrder
    lastCopilotSync?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    messages?: MessageOrderByRelationAggregateInput
    tags?: SessionTagOrderByRelationAggregateInput
  }

  export type ChatSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChatSessionWhereInput | ChatSessionWhereInput[]
    OR?: ChatSessionWhereInput[]
    NOT?: ChatSessionWhereInput | ChatSessionWhereInput[]
    title?: StringFilter<"ChatSession"> | string
    createdAt?: DateTimeFilter<"ChatSession"> | Date | string
    updatedAt?: DateTimeFilter<"ChatSession"> | Date | string
    systemPrompt?: StringNullableFilter<"ChatSession"> | string | null
    isActive?: BoolFilter<"ChatSession"> | boolean
    userId?: StringNullableFilter<"ChatSession"> | string | null
    userName?: StringNullableFilter<"ChatSession"> | string | null
    userEmail?: StringNullableFilter<"ChatSession"> | string | null
    ipAddress?: StringNullableFilter<"ChatSession"> | string | null
    location?: StringNullableFilter<"ChatSession"> | string | null
    source?: StringNullableFilter<"ChatSession"> | string | null
    category?: StringNullableFilter<"ChatSession"> | string | null
    mondayItemId?: StringNullableFilter<"ChatSession"> | string | null
    mondaySynced?: BoolFilter<"ChatSession"> | boolean
    copilotSynced?: BoolFilter<"ChatSession"> | boolean
    databaseSynced?: BoolFilter<"ChatSession"> | boolean
    lastMondaySync?: DateTimeNullableFilter<"ChatSession"> | Date | string | null
    lastCopilotSync?: DateTimeNullableFilter<"ChatSession"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    messages?: MessageListRelationFilter
    tags?: SessionTagListRelationFilter
  }, "id">

  export type ChatSessionOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    systemPrompt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    userId?: SortOrderInput | SortOrder
    userName?: SortOrderInput | SortOrder
    userEmail?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    mondayItemId?: SortOrderInput | SortOrder
    mondaySynced?: SortOrder
    copilotSynced?: SortOrder
    databaseSynced?: SortOrder
    lastMondaySync?: SortOrderInput | SortOrder
    lastCopilotSync?: SortOrderInput | SortOrder
    _count?: ChatSessionCountOrderByAggregateInput
    _max?: ChatSessionMaxOrderByAggregateInput
    _min?: ChatSessionMinOrderByAggregateInput
  }

  export type ChatSessionScalarWhereWithAggregatesInput = {
    AND?: ChatSessionScalarWhereWithAggregatesInput | ChatSessionScalarWhereWithAggregatesInput[]
    OR?: ChatSessionScalarWhereWithAggregatesInput[]
    NOT?: ChatSessionScalarWhereWithAggregatesInput | ChatSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChatSession"> | string
    title?: StringWithAggregatesFilter<"ChatSession"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ChatSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChatSession"> | Date | string
    systemPrompt?: StringNullableWithAggregatesFilter<"ChatSession"> | string | null
    isActive?: BoolWithAggregatesFilter<"ChatSession"> | boolean
    userId?: StringNullableWithAggregatesFilter<"ChatSession"> | string | null
    userName?: StringNullableWithAggregatesFilter<"ChatSession"> | string | null
    userEmail?: StringNullableWithAggregatesFilter<"ChatSession"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"ChatSession"> | string | null
    location?: StringNullableWithAggregatesFilter<"ChatSession"> | string | null
    source?: StringNullableWithAggregatesFilter<"ChatSession"> | string | null
    category?: StringNullableWithAggregatesFilter<"ChatSession"> | string | null
    mondayItemId?: StringNullableWithAggregatesFilter<"ChatSession"> | string | null
    mondaySynced?: BoolWithAggregatesFilter<"ChatSession"> | boolean
    copilotSynced?: BoolWithAggregatesFilter<"ChatSession"> | boolean
    databaseSynced?: BoolWithAggregatesFilter<"ChatSession"> | boolean
    lastMondaySync?: DateTimeNullableWithAggregatesFilter<"ChatSession"> | Date | string | null
    lastCopilotSync?: DateTimeNullableWithAggregatesFilter<"ChatSession"> | Date | string | null
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    sessionId?: StringFilter<"Message"> | string
    role?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    timestamp?: DateTimeFilter<"Message"> | Date | string
    isError?: BoolNullableFilter<"Message"> | boolean | null
    userId?: StringNullableFilter<"Message"> | string | null
    functionName?: StringNullableFilter<"Message"> | string | null
    functionArgs?: StringNullableFilter<"Message"> | string | null
    session?: XOR<ChatSessionScalarRelationFilter, ChatSessionWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    timestamp?: SortOrder
    isError?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    functionName?: SortOrderInput | SortOrder
    functionArgs?: SortOrderInput | SortOrder
    session?: ChatSessionOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    sessionId?: StringFilter<"Message"> | string
    role?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    timestamp?: DateTimeFilter<"Message"> | Date | string
    isError?: BoolNullableFilter<"Message"> | boolean | null
    userId?: StringNullableFilter<"Message"> | string | null
    functionName?: StringNullableFilter<"Message"> | string | null
    functionArgs?: StringNullableFilter<"Message"> | string | null
    session?: XOR<ChatSessionScalarRelationFilter, ChatSessionWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    timestamp?: SortOrder
    isError?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    functionName?: SortOrderInput | SortOrder
    functionArgs?: SortOrderInput | SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    sessionId?: StringWithAggregatesFilter<"Message"> | string
    role?: StringWithAggregatesFilter<"Message"> | string
    content?: StringWithAggregatesFilter<"Message"> | string
    timestamp?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    isError?: BoolNullableWithAggregatesFilter<"Message"> | boolean | null
    userId?: StringNullableWithAggregatesFilter<"Message"> | string | null
    functionName?: StringNullableWithAggregatesFilter<"Message"> | string | null
    functionArgs?: StringNullableWithAggregatesFilter<"Message"> | string | null
  }

  export type SessionTagWhereInput = {
    AND?: SessionTagWhereInput | SessionTagWhereInput[]
    OR?: SessionTagWhereInput[]
    NOT?: SessionTagWhereInput | SessionTagWhereInput[]
    id?: StringFilter<"SessionTag"> | string
    name?: StringFilter<"SessionTag"> | string
    sessionId?: StringFilter<"SessionTag"> | string
    session?: XOR<ChatSessionScalarRelationFilter, ChatSessionWhereInput>
  }

  export type SessionTagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    sessionId?: SortOrder
    session?: ChatSessionOrderByWithRelationInput
  }

  export type SessionTagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionId_name?: SessionTagSessionIdNameCompoundUniqueInput
    AND?: SessionTagWhereInput | SessionTagWhereInput[]
    OR?: SessionTagWhereInput[]
    NOT?: SessionTagWhereInput | SessionTagWhereInput[]
    name?: StringFilter<"SessionTag"> | string
    sessionId?: StringFilter<"SessionTag"> | string
    session?: XOR<ChatSessionScalarRelationFilter, ChatSessionWhereInput>
  }, "id" | "sessionId_name">

  export type SessionTagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    sessionId?: SortOrder
    _count?: SessionTagCountOrderByAggregateInput
    _max?: SessionTagMaxOrderByAggregateInput
    _min?: SessionTagMinOrderByAggregateInput
  }

  export type SessionTagScalarWhereWithAggregatesInput = {
    AND?: SessionTagScalarWhereWithAggregatesInput | SessionTagScalarWhereWithAggregatesInput[]
    OR?: SessionTagScalarWhereWithAggregatesInput[]
    NOT?: SessionTagScalarWhereWithAggregatesInput | SessionTagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SessionTag"> | string
    name?: StringWithAggregatesFilter<"SessionTag"> | string
    sessionId?: StringWithAggregatesFilter<"SessionTag"> | string
  }

  export type MondaySyncWhereInput = {
    AND?: MondaySyncWhereInput | MondaySyncWhereInput[]
    OR?: MondaySyncWhereInput[]
    NOT?: MondaySyncWhereInput | MondaySyncWhereInput[]
    id?: StringFilter<"MondaySync"> | string
    sessionId?: StringFilter<"MondaySync"> | string
    itemId?: StringFilter<"MondaySync"> | string
    boardId?: StringFilter<"MondaySync"> | string
    lastSynced?: DateTimeFilter<"MondaySync"> | Date | string
  }

  export type MondaySyncOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    itemId?: SortOrder
    boardId?: SortOrder
    lastSynced?: SortOrder
  }

  export type MondaySyncWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionId?: string
    AND?: MondaySyncWhereInput | MondaySyncWhereInput[]
    OR?: MondaySyncWhereInput[]
    NOT?: MondaySyncWhereInput | MondaySyncWhereInput[]
    itemId?: StringFilter<"MondaySync"> | string
    boardId?: StringFilter<"MondaySync"> | string
    lastSynced?: DateTimeFilter<"MondaySync"> | Date | string
  }, "id" | "sessionId">

  export type MondaySyncOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    itemId?: SortOrder
    boardId?: SortOrder
    lastSynced?: SortOrder
    _count?: MondaySyncCountOrderByAggregateInput
    _max?: MondaySyncMaxOrderByAggregateInput
    _min?: MondaySyncMinOrderByAggregateInput
  }

  export type MondaySyncScalarWhereWithAggregatesInput = {
    AND?: MondaySyncScalarWhereWithAggregatesInput | MondaySyncScalarWhereWithAggregatesInput[]
    OR?: MondaySyncScalarWhereWithAggregatesInput[]
    NOT?: MondaySyncScalarWhereWithAggregatesInput | MondaySyncScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MondaySync"> | string
    sessionId?: StringWithAggregatesFilter<"MondaySync"> | string
    itemId?: StringWithAggregatesFilter<"MondaySync"> | string
    boardId?: StringWithAggregatesFilter<"MondaySync"> | string
    lastSynced?: DateTimeWithAggregatesFilter<"MondaySync"> | Date | string
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: StringFilter<"Customer"> | string
    userId?: StringFilter<"Customer"> | string
    companyName?: StringNullableFilter<"Customer"> | string | null
    billingAddress?: JsonNullableFilter<"Customer">
    shippingAddress?: JsonNullableFilter<"Customer">
    taxId?: StringNullableFilter<"Customer"> | string | null
    phoneNumber?: StringNullableFilter<"Customer"> | string | null
    stripeCustomerId?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    paymentMethods?: PaymentMethodListRelationFilter
    orders?: OrderListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
    invoices?: InvoiceListRelationFilter
    projects?: ProjectListRelationFilter
    quotes?: QuoteListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrderInput | SortOrder
    billingAddress?: SortOrderInput | SortOrder
    shippingAddress?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    paymentMethods?: PaymentMethodOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    subscriptions?: SubscriptionOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    projects?: ProjectOrderByRelationAggregateInput
    quotes?: QuoteOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    stripeCustomerId?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    companyName?: StringNullableFilter<"Customer"> | string | null
    billingAddress?: JsonNullableFilter<"Customer">
    shippingAddress?: JsonNullableFilter<"Customer">
    taxId?: StringNullableFilter<"Customer"> | string | null
    phoneNumber?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    paymentMethods?: PaymentMethodListRelationFilter
    orders?: OrderListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
    invoices?: InvoiceListRelationFilter
    projects?: ProjectListRelationFilter
    quotes?: QuoteListRelationFilter
  }, "id" | "userId" | "stripeCustomerId">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrderInput | SortOrder
    billingAddress?: SortOrderInput | SortOrder
    shippingAddress?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Customer"> | string
    userId?: StringWithAggregatesFilter<"Customer"> | string
    companyName?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    billingAddress?: JsonNullableWithAggregatesFilter<"Customer">
    shippingAddress?: JsonNullableWithAggregatesFilter<"Customer">
    taxId?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    phoneNumber?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    stripeCustomerId?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    sku?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    category?: StringFilter<"Product"> | string
    basePrice?: FloatFilter<"Product"> | number
    currency?: StringFilter<"Product"> | string
    specifications?: JsonNullableFilter<"Product">
    images?: JsonNullableFilter<"Product">
    isActive?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    inventoryItems?: InventoryListRelationFilter
    orderItems?: OrderItemListRelationFilter
    cartItems?: CartItemListRelationFilter
    priceHistory?: PriceHistoryListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    basePrice?: SortOrder
    currency?: SortOrder
    specifications?: SortOrderInput | SortOrder
    images?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inventoryItems?: InventoryOrderByRelationAggregateInput
    orderItems?: OrderItemOrderByRelationAggregateInput
    cartItems?: CartItemOrderByRelationAggregateInput
    priceHistory?: PriceHistoryOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sku?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    category?: StringFilter<"Product"> | string
    basePrice?: FloatFilter<"Product"> | number
    currency?: StringFilter<"Product"> | string
    specifications?: JsonNullableFilter<"Product">
    images?: JsonNullableFilter<"Product">
    isActive?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    inventoryItems?: InventoryListRelationFilter
    orderItems?: OrderItemListRelationFilter
    cartItems?: CartItemListRelationFilter
    priceHistory?: PriceHistoryListRelationFilter
  }, "id" | "sku">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    basePrice?: SortOrder
    currency?: SortOrder
    specifications?: SortOrderInput | SortOrder
    images?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    sku?: StringWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    category?: StringWithAggregatesFilter<"Product"> | string
    basePrice?: FloatWithAggregatesFilter<"Product"> | number
    currency?: StringWithAggregatesFilter<"Product"> | string
    specifications?: JsonNullableWithAggregatesFilter<"Product">
    images?: JsonNullableWithAggregatesFilter<"Product">
    isActive?: BoolWithAggregatesFilter<"Product"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
    orderNumber?: StringFilter<"Order"> | string
    customerId?: StringFilter<"Order"> | string
    status?: StringFilter<"Order"> | string
    subtotal?: FloatFilter<"Order"> | number
    tax?: FloatFilter<"Order"> | number
    shipping?: FloatFilter<"Order"> | number
    total?: FloatFilter<"Order"> | number
    currency?: StringFilter<"Order"> | string
    shippingAddress?: JsonNullableFilter<"Order">
    shippingMethod?: StringNullableFilter<"Order"> | string | null
    trackingNumber?: StringNullableFilter<"Order"> | string | null
    shippedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    paymentStatus?: StringFilter<"Order"> | string
    paymentIntentId?: StringNullableFilter<"Order"> | string | null
    paidAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    customerNotes?: StringNullableFilter<"Order"> | string | null
    internalNotes?: StringNullableFilter<"Order"> | string | null
    invoiceId?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    items?: OrderItemListRelationFilter
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    customerId?: SortOrder
    status?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    shipping?: SortOrder
    total?: SortOrder
    currency?: SortOrder
    shippingAddress?: SortOrderInput | SortOrder
    shippingMethod?: SortOrderInput | SortOrder
    trackingNumber?: SortOrderInput | SortOrder
    shippedAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    paymentStatus?: SortOrder
    paymentIntentId?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    customerNotes?: SortOrderInput | SortOrder
    internalNotes?: SortOrderInput | SortOrder
    invoiceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    items?: OrderItemOrderByRelationAggregateInput
    invoice?: InvoiceOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderNumber?: string
    paymentIntentId?: string
    invoiceId?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    customerId?: StringFilter<"Order"> | string
    status?: StringFilter<"Order"> | string
    subtotal?: FloatFilter<"Order"> | number
    tax?: FloatFilter<"Order"> | number
    shipping?: FloatFilter<"Order"> | number
    total?: FloatFilter<"Order"> | number
    currency?: StringFilter<"Order"> | string
    shippingAddress?: JsonNullableFilter<"Order">
    shippingMethod?: StringNullableFilter<"Order"> | string | null
    trackingNumber?: StringNullableFilter<"Order"> | string | null
    shippedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    paymentStatus?: StringFilter<"Order"> | string
    paidAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    customerNotes?: StringNullableFilter<"Order"> | string | null
    internalNotes?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    items?: OrderItemListRelationFilter
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
  }, "id" | "orderNumber" | "paymentIntentId" | "invoiceId">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    customerId?: SortOrder
    status?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    shipping?: SortOrder
    total?: SortOrder
    currency?: SortOrder
    shippingAddress?: SortOrderInput | SortOrder
    shippingMethod?: SortOrderInput | SortOrder
    trackingNumber?: SortOrderInput | SortOrder
    shippedAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    paymentStatus?: SortOrder
    paymentIntentId?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    customerNotes?: SortOrderInput | SortOrder
    internalNotes?: SortOrderInput | SortOrder
    invoiceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
    orderNumber?: StringWithAggregatesFilter<"Order"> | string
    customerId?: StringWithAggregatesFilter<"Order"> | string
    status?: StringWithAggregatesFilter<"Order"> | string
    subtotal?: FloatWithAggregatesFilter<"Order"> | number
    tax?: FloatWithAggregatesFilter<"Order"> | number
    shipping?: FloatWithAggregatesFilter<"Order"> | number
    total?: FloatWithAggregatesFilter<"Order"> | number
    currency?: StringWithAggregatesFilter<"Order"> | string
    shippingAddress?: JsonNullableWithAggregatesFilter<"Order">
    shippingMethod?: StringNullableWithAggregatesFilter<"Order"> | string | null
    trackingNumber?: StringNullableWithAggregatesFilter<"Order"> | string | null
    shippedAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    deliveredAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    paymentStatus?: StringWithAggregatesFilter<"Order"> | string
    paymentIntentId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    paidAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    customerNotes?: StringNullableWithAggregatesFilter<"Order"> | string | null
    internalNotes?: StringNullableWithAggregatesFilter<"Order"> | string | null
    invoiceId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
  }

  export type OrderItemWhereInput = {
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    orderId?: StringFilter<"OrderItem"> | string
    productId?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
    unitPrice?: FloatFilter<"OrderItem"> | number
    totalPrice?: FloatFilter<"OrderItem"> | number
    productSnapshot?: JsonNullableFilter<"OrderItem">
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type OrderItemOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    productSnapshot?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    order?: OrderOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type OrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    orderId?: StringFilter<"OrderItem"> | string
    productId?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
    unitPrice?: FloatFilter<"OrderItem"> | number
    totalPrice?: FloatFilter<"OrderItem"> | number
    productSnapshot?: JsonNullableFilter<"OrderItem">
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type OrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    productSnapshot?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: OrderItemCountOrderByAggregateInput
    _avg?: OrderItemAvgOrderByAggregateInput
    _max?: OrderItemMaxOrderByAggregateInput
    _min?: OrderItemMinOrderByAggregateInput
    _sum?: OrderItemSumOrderByAggregateInput
  }

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    OR?: OrderItemScalarWhereWithAggregatesInput[]
    NOT?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderItem"> | string
    orderId?: StringWithAggregatesFilter<"OrderItem"> | string
    productId?: StringWithAggregatesFilter<"OrderItem"> | string
    quantity?: IntWithAggregatesFilter<"OrderItem"> | number
    unitPrice?: FloatWithAggregatesFilter<"OrderItem"> | number
    totalPrice?: FloatWithAggregatesFilter<"OrderItem"> | number
    productSnapshot?: JsonNullableWithAggregatesFilter<"OrderItem">
    createdAt?: DateTimeWithAggregatesFilter<"OrderItem"> | Date | string
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: StringFilter<"Subscription"> | string
    customerId?: StringFilter<"Subscription"> | string
    status?: StringFilter<"Subscription"> | string
    planId?: StringFilter<"Subscription"> | string
    billingCycle?: StringFilter<"Subscription"> | string
    currentPeriodStart?: DateTimeFilter<"Subscription"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"Subscription"> | Date | string
    nextBillingDate?: DateTimeFilter<"Subscription"> | Date | string
    stripeSubscriptionId?: StringNullableFilter<"Subscription"> | string | null
    metadata?: JsonNullableFilter<"Subscription">
    cancelledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    cancelReason?: StringNullableFilter<"Subscription"> | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    plan?: XOR<SubscriptionPlanScalarRelationFilter, SubscriptionPlanWhereInput>
    invoices?: InvoiceListRelationFilter
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    status?: SortOrder
    planId?: SortOrder
    billingCycle?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    nextBillingDate?: SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    cancelReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    plan?: SubscriptionPlanOrderByWithRelationInput
    invoices?: InvoiceOrderByRelationAggregateInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    stripeSubscriptionId?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    customerId?: StringFilter<"Subscription"> | string
    status?: StringFilter<"Subscription"> | string
    planId?: StringFilter<"Subscription"> | string
    billingCycle?: StringFilter<"Subscription"> | string
    currentPeriodStart?: DateTimeFilter<"Subscription"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"Subscription"> | Date | string
    nextBillingDate?: DateTimeFilter<"Subscription"> | Date | string
    metadata?: JsonNullableFilter<"Subscription">
    cancelledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    cancelReason?: StringNullableFilter<"Subscription"> | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    plan?: XOR<SubscriptionPlanScalarRelationFilter, SubscriptionPlanWhereInput>
    invoices?: InvoiceListRelationFilter
  }, "id" | "stripeSubscriptionId">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    status?: SortOrder
    planId?: SortOrder
    billingCycle?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    nextBillingDate?: SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    cancelReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscription"> | string
    customerId?: StringWithAggregatesFilter<"Subscription"> | string
    status?: StringWithAggregatesFilter<"Subscription"> | string
    planId?: StringWithAggregatesFilter<"Subscription"> | string
    billingCycle?: StringWithAggregatesFilter<"Subscription"> | string
    currentPeriodStart?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    currentPeriodEnd?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    nextBillingDate?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    stripeSubscriptionId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Subscription">
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    cancelReason?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
  }

  export type SubscriptionPlanWhereInput = {
    AND?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    OR?: SubscriptionPlanWhereInput[]
    NOT?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    id?: StringFilter<"SubscriptionPlan"> | string
    name?: StringFilter<"SubscriptionPlan"> | string
    description?: StringNullableFilter<"SubscriptionPlan"> | string | null
    price?: FloatFilter<"SubscriptionPlan"> | number
    currency?: StringFilter<"SubscriptionPlan"> | string
    interval?: StringFilter<"SubscriptionPlan"> | string
    features?: JsonNullableFilter<"SubscriptionPlan">
    limits?: JsonNullableFilter<"SubscriptionPlan">
    isActive?: BoolFilter<"SubscriptionPlan"> | boolean
    createdAt?: DateTimeFilter<"SubscriptionPlan"> | Date | string
    updatedAt?: DateTimeFilter<"SubscriptionPlan"> | Date | string
    subscriptions?: SubscriptionListRelationFilter
  }

  export type SubscriptionPlanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    features?: SortOrderInput | SortOrder
    limits?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subscriptions?: SubscriptionOrderByRelationAggregateInput
  }

  export type SubscriptionPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    OR?: SubscriptionPlanWhereInput[]
    NOT?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    name?: StringFilter<"SubscriptionPlan"> | string
    description?: StringNullableFilter<"SubscriptionPlan"> | string | null
    price?: FloatFilter<"SubscriptionPlan"> | number
    currency?: StringFilter<"SubscriptionPlan"> | string
    interval?: StringFilter<"SubscriptionPlan"> | string
    features?: JsonNullableFilter<"SubscriptionPlan">
    limits?: JsonNullableFilter<"SubscriptionPlan">
    isActive?: BoolFilter<"SubscriptionPlan"> | boolean
    createdAt?: DateTimeFilter<"SubscriptionPlan"> | Date | string
    updatedAt?: DateTimeFilter<"SubscriptionPlan"> | Date | string
    subscriptions?: SubscriptionListRelationFilter
  }, "id">

  export type SubscriptionPlanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    features?: SortOrderInput | SortOrder
    limits?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionPlanCountOrderByAggregateInput
    _avg?: SubscriptionPlanAvgOrderByAggregateInput
    _max?: SubscriptionPlanMaxOrderByAggregateInput
    _min?: SubscriptionPlanMinOrderByAggregateInput
    _sum?: SubscriptionPlanSumOrderByAggregateInput
  }

  export type SubscriptionPlanScalarWhereWithAggregatesInput = {
    AND?: SubscriptionPlanScalarWhereWithAggregatesInput | SubscriptionPlanScalarWhereWithAggregatesInput[]
    OR?: SubscriptionPlanScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionPlanScalarWhereWithAggregatesInput | SubscriptionPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubscriptionPlan"> | string
    name?: StringWithAggregatesFilter<"SubscriptionPlan"> | string
    description?: StringNullableWithAggregatesFilter<"SubscriptionPlan"> | string | null
    price?: FloatWithAggregatesFilter<"SubscriptionPlan"> | number
    currency?: StringWithAggregatesFilter<"SubscriptionPlan"> | string
    interval?: StringWithAggregatesFilter<"SubscriptionPlan"> | string
    features?: JsonNullableWithAggregatesFilter<"SubscriptionPlan">
    limits?: JsonNullableWithAggregatesFilter<"SubscriptionPlan">
    isActive?: BoolWithAggregatesFilter<"SubscriptionPlan"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SubscriptionPlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SubscriptionPlan"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    invoiceNumber?: StringFilter<"Invoice"> | string
    customerId?: StringFilter<"Invoice"> | string
    type?: StringFilter<"Invoice"> | string
    subscriptionId?: StringNullableFilter<"Invoice"> | string | null
    subtotal?: FloatFilter<"Invoice"> | number
    tax?: FloatFilter<"Invoice"> | number
    total?: FloatFilter<"Invoice"> | number
    currency?: StringFilter<"Invoice"> | string
    status?: StringFilter<"Invoice"> | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    paidAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    paymentIntentId?: StringNullableFilter<"Invoice"> | string | null
    paymentMethod?: StringNullableFilter<"Invoice"> | string | null
    pdfUrl?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    subscription?: XOR<SubscriptionNullableScalarRelationFilter, SubscriptionWhereInput> | null
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    paymentIntentId?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    pdfUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
    subscription?: SubscriptionOrderByWithRelationInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invoiceNumber?: string
    paymentIntentId?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    customerId?: StringFilter<"Invoice"> | string
    type?: StringFilter<"Invoice"> | string
    subscriptionId?: StringNullableFilter<"Invoice"> | string | null
    subtotal?: FloatFilter<"Invoice"> | number
    tax?: FloatFilter<"Invoice"> | number
    total?: FloatFilter<"Invoice"> | number
    currency?: StringFilter<"Invoice"> | string
    status?: StringFilter<"Invoice"> | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    paidAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    paymentMethod?: StringNullableFilter<"Invoice"> | string | null
    pdfUrl?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    subscription?: XOR<SubscriptionNullableScalarRelationFilter, SubscriptionWhereInput> | null
  }, "id" | "invoiceNumber" | "paymentIntentId">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    paymentIntentId?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    pdfUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    invoiceNumber?: StringWithAggregatesFilter<"Invoice"> | string
    customerId?: StringWithAggregatesFilter<"Invoice"> | string
    type?: StringWithAggregatesFilter<"Invoice"> | string
    subscriptionId?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    subtotal?: FloatWithAggregatesFilter<"Invoice"> | number
    tax?: FloatWithAggregatesFilter<"Invoice"> | number
    total?: FloatWithAggregatesFilter<"Invoice"> | number
    currency?: StringWithAggregatesFilter<"Invoice"> | string
    status?: StringWithAggregatesFilter<"Invoice"> | string
    dueDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    paidAt?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    paymentIntentId?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    paymentMethod?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    pdfUrl?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
  }

  export type PaymentMethodWhereInput = {
    AND?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    OR?: PaymentMethodWhereInput[]
    NOT?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    id?: StringFilter<"PaymentMethod"> | string
    customerId?: StringFilter<"PaymentMethod"> | string
    stripePaymentMethodId?: StringFilter<"PaymentMethod"> | string
    type?: StringFilter<"PaymentMethod"> | string
    last4?: StringFilter<"PaymentMethod"> | string
    brand?: StringNullableFilter<"PaymentMethod"> | string | null
    expiryMonth?: IntNullableFilter<"PaymentMethod"> | number | null
    expiryYear?: IntNullableFilter<"PaymentMethod"> | number | null
    isDefault?: BoolFilter<"PaymentMethod"> | boolean
    createdAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }

  export type PaymentMethodOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    stripePaymentMethodId?: SortOrder
    type?: SortOrder
    last4?: SortOrder
    brand?: SortOrderInput | SortOrder
    expiryMonth?: SortOrderInput | SortOrder
    expiryYear?: SortOrderInput | SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
  }

  export type PaymentMethodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    stripePaymentMethodId?: string
    AND?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    OR?: PaymentMethodWhereInput[]
    NOT?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    customerId?: StringFilter<"PaymentMethod"> | string
    type?: StringFilter<"PaymentMethod"> | string
    last4?: StringFilter<"PaymentMethod"> | string
    brand?: StringNullableFilter<"PaymentMethod"> | string | null
    expiryMonth?: IntNullableFilter<"PaymentMethod"> | number | null
    expiryYear?: IntNullableFilter<"PaymentMethod"> | number | null
    isDefault?: BoolFilter<"PaymentMethod"> | boolean
    createdAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }, "id" | "stripePaymentMethodId">

  export type PaymentMethodOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    stripePaymentMethodId?: SortOrder
    type?: SortOrder
    last4?: SortOrder
    brand?: SortOrderInput | SortOrder
    expiryMonth?: SortOrderInput | SortOrder
    expiryYear?: SortOrderInput | SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentMethodCountOrderByAggregateInput
    _avg?: PaymentMethodAvgOrderByAggregateInput
    _max?: PaymentMethodMaxOrderByAggregateInput
    _min?: PaymentMethodMinOrderByAggregateInput
    _sum?: PaymentMethodSumOrderByAggregateInput
  }

  export type PaymentMethodScalarWhereWithAggregatesInput = {
    AND?: PaymentMethodScalarWhereWithAggregatesInput | PaymentMethodScalarWhereWithAggregatesInput[]
    OR?: PaymentMethodScalarWhereWithAggregatesInput[]
    NOT?: PaymentMethodScalarWhereWithAggregatesInput | PaymentMethodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentMethod"> | string
    customerId?: StringWithAggregatesFilter<"PaymentMethod"> | string
    stripePaymentMethodId?: StringWithAggregatesFilter<"PaymentMethod"> | string
    type?: StringWithAggregatesFilter<"PaymentMethod"> | string
    last4?: StringWithAggregatesFilter<"PaymentMethod"> | string
    brand?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
    expiryMonth?: IntNullableWithAggregatesFilter<"PaymentMethod"> | number | null
    expiryYear?: IntNullableWithAggregatesFilter<"PaymentMethod"> | number | null
    isDefault?: BoolWithAggregatesFilter<"PaymentMethod"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentMethod"> | Date | string
  }

  export type InventoryWhereInput = {
    AND?: InventoryWhereInput | InventoryWhereInput[]
    OR?: InventoryWhereInput[]
    NOT?: InventoryWhereInput | InventoryWhereInput[]
    id?: StringFilter<"Inventory"> | string
    productId?: StringFilter<"Inventory"> | string
    location?: StringFilter<"Inventory"> | string
    quantity?: IntFilter<"Inventory"> | number
    reservedQuantity?: IntFilter<"Inventory"> | number
    availableQuantity?: IntFilter<"Inventory"> | number
    reorderPoint?: IntFilter<"Inventory"> | number
    reorderQuantity?: IntFilter<"Inventory"> | number
    batchNumber?: StringNullableFilter<"Inventory"> | string | null
    serialNumbers?: JsonNullableFilter<"Inventory">
    lastRestocked?: DateTimeNullableFilter<"Inventory"> | Date | string | null
    lastCounted?: DateTimeNullableFilter<"Inventory"> | Date | string | null
    createdAt?: DateTimeFilter<"Inventory"> | Date | string
    updatedAt?: DateTimeFilter<"Inventory"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type InventoryOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    location?: SortOrder
    quantity?: SortOrder
    reservedQuantity?: SortOrder
    availableQuantity?: SortOrder
    reorderPoint?: SortOrder
    reorderQuantity?: SortOrder
    batchNumber?: SortOrderInput | SortOrder
    serialNumbers?: SortOrderInput | SortOrder
    lastRestocked?: SortOrderInput | SortOrder
    lastCounted?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type InventoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productId_location?: InventoryProductIdLocationCompoundUniqueInput
    AND?: InventoryWhereInput | InventoryWhereInput[]
    OR?: InventoryWhereInput[]
    NOT?: InventoryWhereInput | InventoryWhereInput[]
    productId?: StringFilter<"Inventory"> | string
    location?: StringFilter<"Inventory"> | string
    quantity?: IntFilter<"Inventory"> | number
    reservedQuantity?: IntFilter<"Inventory"> | number
    availableQuantity?: IntFilter<"Inventory"> | number
    reorderPoint?: IntFilter<"Inventory"> | number
    reorderQuantity?: IntFilter<"Inventory"> | number
    batchNumber?: StringNullableFilter<"Inventory"> | string | null
    serialNumbers?: JsonNullableFilter<"Inventory">
    lastRestocked?: DateTimeNullableFilter<"Inventory"> | Date | string | null
    lastCounted?: DateTimeNullableFilter<"Inventory"> | Date | string | null
    createdAt?: DateTimeFilter<"Inventory"> | Date | string
    updatedAt?: DateTimeFilter<"Inventory"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id" | "productId_location">

  export type InventoryOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    location?: SortOrder
    quantity?: SortOrder
    reservedQuantity?: SortOrder
    availableQuantity?: SortOrder
    reorderPoint?: SortOrder
    reorderQuantity?: SortOrder
    batchNumber?: SortOrderInput | SortOrder
    serialNumbers?: SortOrderInput | SortOrder
    lastRestocked?: SortOrderInput | SortOrder
    lastCounted?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InventoryCountOrderByAggregateInput
    _avg?: InventoryAvgOrderByAggregateInput
    _max?: InventoryMaxOrderByAggregateInput
    _min?: InventoryMinOrderByAggregateInput
    _sum?: InventorySumOrderByAggregateInput
  }

  export type InventoryScalarWhereWithAggregatesInput = {
    AND?: InventoryScalarWhereWithAggregatesInput | InventoryScalarWhereWithAggregatesInput[]
    OR?: InventoryScalarWhereWithAggregatesInput[]
    NOT?: InventoryScalarWhereWithAggregatesInput | InventoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Inventory"> | string
    productId?: StringWithAggregatesFilter<"Inventory"> | string
    location?: StringWithAggregatesFilter<"Inventory"> | string
    quantity?: IntWithAggregatesFilter<"Inventory"> | number
    reservedQuantity?: IntWithAggregatesFilter<"Inventory"> | number
    availableQuantity?: IntWithAggregatesFilter<"Inventory"> | number
    reorderPoint?: IntWithAggregatesFilter<"Inventory"> | number
    reorderQuantity?: IntWithAggregatesFilter<"Inventory"> | number
    batchNumber?: StringNullableWithAggregatesFilter<"Inventory"> | string | null
    serialNumbers?: JsonNullableWithAggregatesFilter<"Inventory">
    lastRestocked?: DateTimeNullableWithAggregatesFilter<"Inventory"> | Date | string | null
    lastCounted?: DateTimeNullableWithAggregatesFilter<"Inventory"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Inventory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Inventory"> | Date | string
  }

  export type CartWhereInput = {
    AND?: CartWhereInput | CartWhereInput[]
    OR?: CartWhereInput[]
    NOT?: CartWhereInput | CartWhereInput[]
    id?: StringFilter<"Cart"> | string
    sessionId?: StringNullableFilter<"Cart"> | string | null
    userId?: StringNullableFilter<"Cart"> | string | null
    expiresAt?: DateTimeFilter<"Cart"> | Date | string
    createdAt?: DateTimeFilter<"Cart"> | Date | string
    updatedAt?: DateTimeFilter<"Cart"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    items?: CartItemListRelationFilter
  }

  export type CartOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    items?: CartItemOrderByRelationAggregateInput
  }

  export type CartWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionId?: string
    userId?: string
    AND?: CartWhereInput | CartWhereInput[]
    OR?: CartWhereInput[]
    NOT?: CartWhereInput | CartWhereInput[]
    expiresAt?: DateTimeFilter<"Cart"> | Date | string
    createdAt?: DateTimeFilter<"Cart"> | Date | string
    updatedAt?: DateTimeFilter<"Cart"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    items?: CartItemListRelationFilter
  }, "id" | "sessionId" | "userId">

  export type CartOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CartCountOrderByAggregateInput
    _max?: CartMaxOrderByAggregateInput
    _min?: CartMinOrderByAggregateInput
  }

  export type CartScalarWhereWithAggregatesInput = {
    AND?: CartScalarWhereWithAggregatesInput | CartScalarWhereWithAggregatesInput[]
    OR?: CartScalarWhereWithAggregatesInput[]
    NOT?: CartScalarWhereWithAggregatesInput | CartScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Cart"> | string
    sessionId?: StringNullableWithAggregatesFilter<"Cart"> | string | null
    userId?: StringNullableWithAggregatesFilter<"Cart"> | string | null
    expiresAt?: DateTimeWithAggregatesFilter<"Cart"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Cart"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Cart"> | Date | string
  }

  export type CartItemWhereInput = {
    AND?: CartItemWhereInput | CartItemWhereInput[]
    OR?: CartItemWhereInput[]
    NOT?: CartItemWhereInput | CartItemWhereInput[]
    id?: StringFilter<"CartItem"> | string
    cartId?: StringFilter<"CartItem"> | string
    productId?: StringFilter<"CartItem"> | string
    quantity?: IntFilter<"CartItem"> | number
    createdAt?: DateTimeFilter<"CartItem"> | Date | string
    updatedAt?: DateTimeFilter<"CartItem"> | Date | string
    cart?: XOR<CartScalarRelationFilter, CartWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type CartItemOrderByWithRelationInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cart?: CartOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type CartItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    cartId_productId?: CartItemCartIdProductIdCompoundUniqueInput
    AND?: CartItemWhereInput | CartItemWhereInput[]
    OR?: CartItemWhereInput[]
    NOT?: CartItemWhereInput | CartItemWhereInput[]
    cartId?: StringFilter<"CartItem"> | string
    productId?: StringFilter<"CartItem"> | string
    quantity?: IntFilter<"CartItem"> | number
    createdAt?: DateTimeFilter<"CartItem"> | Date | string
    updatedAt?: DateTimeFilter<"CartItem"> | Date | string
    cart?: XOR<CartScalarRelationFilter, CartWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id" | "cartId_productId">

  export type CartItemOrderByWithAggregationInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CartItemCountOrderByAggregateInput
    _avg?: CartItemAvgOrderByAggregateInput
    _max?: CartItemMaxOrderByAggregateInput
    _min?: CartItemMinOrderByAggregateInput
    _sum?: CartItemSumOrderByAggregateInput
  }

  export type CartItemScalarWhereWithAggregatesInput = {
    AND?: CartItemScalarWhereWithAggregatesInput | CartItemScalarWhereWithAggregatesInput[]
    OR?: CartItemScalarWhereWithAggregatesInput[]
    NOT?: CartItemScalarWhereWithAggregatesInput | CartItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CartItem"> | string
    cartId?: StringWithAggregatesFilter<"CartItem"> | string
    productId?: StringWithAggregatesFilter<"CartItem"> | string
    quantity?: IntWithAggregatesFilter<"CartItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CartItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CartItem"> | Date | string
  }

  export type PriceHistoryWhereInput = {
    AND?: PriceHistoryWhereInput | PriceHistoryWhereInput[]
    OR?: PriceHistoryWhereInput[]
    NOT?: PriceHistoryWhereInput | PriceHistoryWhereInput[]
    id?: StringFilter<"PriceHistory"> | string
    productId?: StringFilter<"PriceHistory"> | string
    price?: FloatFilter<"PriceHistory"> | number
    previousPrice?: FloatNullableFilter<"PriceHistory"> | number | null
    currency?: StringFilter<"PriceHistory"> | string
    reason?: StringNullableFilter<"PriceHistory"> | string | null
    effectiveFrom?: DateTimeFilter<"PriceHistory"> | Date | string
    effectiveUntil?: DateTimeNullableFilter<"PriceHistory"> | Date | string | null
    createdAt?: DateTimeFilter<"PriceHistory"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type PriceHistoryOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    price?: SortOrder
    previousPrice?: SortOrderInput | SortOrder
    currency?: SortOrder
    reason?: SortOrderInput | SortOrder
    effectiveFrom?: SortOrder
    effectiveUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type PriceHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PriceHistoryWhereInput | PriceHistoryWhereInput[]
    OR?: PriceHistoryWhereInput[]
    NOT?: PriceHistoryWhereInput | PriceHistoryWhereInput[]
    productId?: StringFilter<"PriceHistory"> | string
    price?: FloatFilter<"PriceHistory"> | number
    previousPrice?: FloatNullableFilter<"PriceHistory"> | number | null
    currency?: StringFilter<"PriceHistory"> | string
    reason?: StringNullableFilter<"PriceHistory"> | string | null
    effectiveFrom?: DateTimeFilter<"PriceHistory"> | Date | string
    effectiveUntil?: DateTimeNullableFilter<"PriceHistory"> | Date | string | null
    createdAt?: DateTimeFilter<"PriceHistory"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type PriceHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    price?: SortOrder
    previousPrice?: SortOrderInput | SortOrder
    currency?: SortOrder
    reason?: SortOrderInput | SortOrder
    effectiveFrom?: SortOrder
    effectiveUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PriceHistoryCountOrderByAggregateInput
    _avg?: PriceHistoryAvgOrderByAggregateInput
    _max?: PriceHistoryMaxOrderByAggregateInput
    _min?: PriceHistoryMinOrderByAggregateInput
    _sum?: PriceHistorySumOrderByAggregateInput
  }

  export type PriceHistoryScalarWhereWithAggregatesInput = {
    AND?: PriceHistoryScalarWhereWithAggregatesInput | PriceHistoryScalarWhereWithAggregatesInput[]
    OR?: PriceHistoryScalarWhereWithAggregatesInput[]
    NOT?: PriceHistoryScalarWhereWithAggregatesInput | PriceHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PriceHistory"> | string
    productId?: StringWithAggregatesFilter<"PriceHistory"> | string
    price?: FloatWithAggregatesFilter<"PriceHistory"> | number
    previousPrice?: FloatNullableWithAggregatesFilter<"PriceHistory"> | number | null
    currency?: StringWithAggregatesFilter<"PriceHistory"> | string
    reason?: StringNullableWithAggregatesFilter<"PriceHistory"> | string | null
    effectiveFrom?: DateTimeWithAggregatesFilter<"PriceHistory"> | Date | string
    effectiveUntil?: DateTimeNullableWithAggregatesFilter<"PriceHistory"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PriceHistory"> | Date | string
  }

  export type SystemHealthWhereInput = {
    AND?: SystemHealthWhereInput | SystemHealthWhereInput[]
    OR?: SystemHealthWhereInput[]
    NOT?: SystemHealthWhereInput | SystemHealthWhereInput[]
    id?: StringFilter<"SystemHealth"> | string
    service?: StringFilter<"SystemHealth"> | string
    status?: StringFilter<"SystemHealth"> | string
    responseTime?: FloatNullableFilter<"SystemHealth"> | number | null
    errorRate?: FloatNullableFilter<"SystemHealth"> | number | null
    uptime?: FloatNullableFilter<"SystemHealth"> | number | null
    message?: StringNullableFilter<"SystemHealth"> | string | null
    lastCheck?: DateTimeFilter<"SystemHealth"> | Date | string
    nextCheck?: DateTimeNullableFilter<"SystemHealth"> | Date | string | null
    metadata?: JsonNullableFilter<"SystemHealth">
    createdAt?: DateTimeFilter<"SystemHealth"> | Date | string
    updatedAt?: DateTimeFilter<"SystemHealth"> | Date | string
  }

  export type SystemHealthOrderByWithRelationInput = {
    id?: SortOrder
    service?: SortOrder
    status?: SortOrder
    responseTime?: SortOrderInput | SortOrder
    errorRate?: SortOrderInput | SortOrder
    uptime?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    lastCheck?: SortOrder
    nextCheck?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemHealthWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    service?: string
    AND?: SystemHealthWhereInput | SystemHealthWhereInput[]
    OR?: SystemHealthWhereInput[]
    NOT?: SystemHealthWhereInput | SystemHealthWhereInput[]
    status?: StringFilter<"SystemHealth"> | string
    responseTime?: FloatNullableFilter<"SystemHealth"> | number | null
    errorRate?: FloatNullableFilter<"SystemHealth"> | number | null
    uptime?: FloatNullableFilter<"SystemHealth"> | number | null
    message?: StringNullableFilter<"SystemHealth"> | string | null
    lastCheck?: DateTimeFilter<"SystemHealth"> | Date | string
    nextCheck?: DateTimeNullableFilter<"SystemHealth"> | Date | string | null
    metadata?: JsonNullableFilter<"SystemHealth">
    createdAt?: DateTimeFilter<"SystemHealth"> | Date | string
    updatedAt?: DateTimeFilter<"SystemHealth"> | Date | string
  }, "id" | "service">

  export type SystemHealthOrderByWithAggregationInput = {
    id?: SortOrder
    service?: SortOrder
    status?: SortOrder
    responseTime?: SortOrderInput | SortOrder
    errorRate?: SortOrderInput | SortOrder
    uptime?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    lastCheck?: SortOrder
    nextCheck?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SystemHealthCountOrderByAggregateInput
    _avg?: SystemHealthAvgOrderByAggregateInput
    _max?: SystemHealthMaxOrderByAggregateInput
    _min?: SystemHealthMinOrderByAggregateInput
    _sum?: SystemHealthSumOrderByAggregateInput
  }

  export type SystemHealthScalarWhereWithAggregatesInput = {
    AND?: SystemHealthScalarWhereWithAggregatesInput | SystemHealthScalarWhereWithAggregatesInput[]
    OR?: SystemHealthScalarWhereWithAggregatesInput[]
    NOT?: SystemHealthScalarWhereWithAggregatesInput | SystemHealthScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemHealth"> | string
    service?: StringWithAggregatesFilter<"SystemHealth"> | string
    status?: StringWithAggregatesFilter<"SystemHealth"> | string
    responseTime?: FloatNullableWithAggregatesFilter<"SystemHealth"> | number | null
    errorRate?: FloatNullableWithAggregatesFilter<"SystemHealth"> | number | null
    uptime?: FloatNullableWithAggregatesFilter<"SystemHealth"> | number | null
    message?: StringNullableWithAggregatesFilter<"SystemHealth"> | string | null
    lastCheck?: DateTimeWithAggregatesFilter<"SystemHealth"> | Date | string
    nextCheck?: DateTimeNullableWithAggregatesFilter<"SystemHealth"> | Date | string | null
    metadata?: JsonNullableWithAggregatesFilter<"SystemHealth">
    createdAt?: DateTimeWithAggregatesFilter<"SystemHealth"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SystemHealth"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringNullableFilter<"Notification"> | string | null
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    priority?: StringFilter<"Notification"> | string
    channel?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    priority?: SortOrder
    channel?: SortOrder
    read?: SortOrder
    readAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringNullableFilter<"Notification"> | string | null
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    priority?: StringFilter<"Notification"> | string
    channel?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    priority?: SortOrder
    channel?: SortOrder
    read?: SortOrder
    readAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    type?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    priority?: StringWithAggregatesFilter<"Notification"> | string
    channel?: StringWithAggregatesFilter<"Notification"> | string
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    readAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Notification">
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type AnalyticsEventWhereInput = {
    AND?: AnalyticsEventWhereInput | AnalyticsEventWhereInput[]
    OR?: AnalyticsEventWhereInput[]
    NOT?: AnalyticsEventWhereInput | AnalyticsEventWhereInput[]
    id?: StringFilter<"AnalyticsEvent"> | string
    sessionId?: StringFilter<"AnalyticsEvent"> | string
    userId?: StringNullableFilter<"AnalyticsEvent"> | string | null
    eventName?: StringFilter<"AnalyticsEvent"> | string
    eventCategory?: StringFilter<"AnalyticsEvent"> | string
    eventData?: JsonFilter<"AnalyticsEvent">
    dataPoints?: JsonFilter<"AnalyticsEvent">
    context?: JsonFilter<"AnalyticsEvent">
    timestamp?: DateTimeFilter<"AnalyticsEvent"> | Date | string
    createdAt?: DateTimeFilter<"AnalyticsEvent"> | Date | string
  }

  export type AnalyticsEventOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrderInput | SortOrder
    eventName?: SortOrder
    eventCategory?: SortOrder
    eventData?: SortOrder
    dataPoints?: SortOrder
    context?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnalyticsEventWhereInput | AnalyticsEventWhereInput[]
    OR?: AnalyticsEventWhereInput[]
    NOT?: AnalyticsEventWhereInput | AnalyticsEventWhereInput[]
    sessionId?: StringFilter<"AnalyticsEvent"> | string
    userId?: StringNullableFilter<"AnalyticsEvent"> | string | null
    eventName?: StringFilter<"AnalyticsEvent"> | string
    eventCategory?: StringFilter<"AnalyticsEvent"> | string
    eventData?: JsonFilter<"AnalyticsEvent">
    dataPoints?: JsonFilter<"AnalyticsEvent">
    context?: JsonFilter<"AnalyticsEvent">
    timestamp?: DateTimeFilter<"AnalyticsEvent"> | Date | string
    createdAt?: DateTimeFilter<"AnalyticsEvent"> | Date | string
  }, "id">

  export type AnalyticsEventOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrderInput | SortOrder
    eventName?: SortOrder
    eventCategory?: SortOrder
    eventData?: SortOrder
    dataPoints?: SortOrder
    context?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    _count?: AnalyticsEventCountOrderByAggregateInput
    _max?: AnalyticsEventMaxOrderByAggregateInput
    _min?: AnalyticsEventMinOrderByAggregateInput
  }

  export type AnalyticsEventScalarWhereWithAggregatesInput = {
    AND?: AnalyticsEventScalarWhereWithAggregatesInput | AnalyticsEventScalarWhereWithAggregatesInput[]
    OR?: AnalyticsEventScalarWhereWithAggregatesInput[]
    NOT?: AnalyticsEventScalarWhereWithAggregatesInput | AnalyticsEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AnalyticsEvent"> | string
    sessionId?: StringWithAggregatesFilter<"AnalyticsEvent"> | string
    userId?: StringNullableWithAggregatesFilter<"AnalyticsEvent"> | string | null
    eventName?: StringWithAggregatesFilter<"AnalyticsEvent"> | string
    eventCategory?: StringWithAggregatesFilter<"AnalyticsEvent"> | string
    eventData?: JsonWithAggregatesFilter<"AnalyticsEvent">
    dataPoints?: JsonWithAggregatesFilter<"AnalyticsEvent">
    context?: JsonWithAggregatesFilter<"AnalyticsEvent">
    timestamp?: DateTimeWithAggregatesFilter<"AnalyticsEvent"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"AnalyticsEvent"> | Date | string
  }

  export type AnalyticsSessionWhereInput = {
    AND?: AnalyticsSessionWhereInput | AnalyticsSessionWhereInput[]
    OR?: AnalyticsSessionWhereInput[]
    NOT?: AnalyticsSessionWhereInput | AnalyticsSessionWhereInput[]
    id?: StringFilter<"AnalyticsSession"> | string
    userId?: StringNullableFilter<"AnalyticsSession"> | string | null
    visitorId?: StringNullableFilter<"AnalyticsSession"> | string | null
    startTime?: DateTimeFilter<"AnalyticsSession"> | Date | string
    endTime?: DateTimeNullableFilter<"AnalyticsSession"> | Date | string | null
    duration?: IntNullableFilter<"AnalyticsSession"> | number | null
    pageViews?: IntFilter<"AnalyticsSession"> | number
    events?: IntFilter<"AnalyticsSession"> | number
    bounced?: BoolFilter<"AnalyticsSession"> | boolean
    source?: StringNullableFilter<"AnalyticsSession"> | string | null
    medium?: StringNullableFilter<"AnalyticsSession"> | string | null
    campaign?: StringNullableFilter<"AnalyticsSession"> | string | null
    content?: StringNullableFilter<"AnalyticsSession"> | string | null
    term?: StringNullableFilter<"AnalyticsSession"> | string | null
    deviceType?: StringNullableFilter<"AnalyticsSession"> | string | null
    deviceBrand?: StringNullableFilter<"AnalyticsSession"> | string | null
    browser?: StringNullableFilter<"AnalyticsSession"> | string | null
    os?: StringNullableFilter<"AnalyticsSession"> | string | null
    screenResolution?: StringNullableFilter<"AnalyticsSession"> | string | null
    country?: StringNullableFilter<"AnalyticsSession"> | string | null
    region?: StringNullableFilter<"AnalyticsSession"> | string | null
    city?: StringNullableFilter<"AnalyticsSession"> | string | null
    engagementScore?: FloatNullableFilter<"AnalyticsSession"> | number | null
    conversionValue?: FloatNullableFilter<"AnalyticsSession"> | number | null
    createdAt?: DateTimeFilter<"AnalyticsSession"> | Date | string
    updatedAt?: DateTimeFilter<"AnalyticsSession"> | Date | string
  }

  export type AnalyticsSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    visitorId?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    pageViews?: SortOrder
    events?: SortOrder
    bounced?: SortOrder
    source?: SortOrderInput | SortOrder
    medium?: SortOrderInput | SortOrder
    campaign?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    term?: SortOrderInput | SortOrder
    deviceType?: SortOrderInput | SortOrder
    deviceBrand?: SortOrderInput | SortOrder
    browser?: SortOrderInput | SortOrder
    os?: SortOrderInput | SortOrder
    screenResolution?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    engagementScore?: SortOrderInput | SortOrder
    conversionValue?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalyticsSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnalyticsSessionWhereInput | AnalyticsSessionWhereInput[]
    OR?: AnalyticsSessionWhereInput[]
    NOT?: AnalyticsSessionWhereInput | AnalyticsSessionWhereInput[]
    userId?: StringNullableFilter<"AnalyticsSession"> | string | null
    visitorId?: StringNullableFilter<"AnalyticsSession"> | string | null
    startTime?: DateTimeFilter<"AnalyticsSession"> | Date | string
    endTime?: DateTimeNullableFilter<"AnalyticsSession"> | Date | string | null
    duration?: IntNullableFilter<"AnalyticsSession"> | number | null
    pageViews?: IntFilter<"AnalyticsSession"> | number
    events?: IntFilter<"AnalyticsSession"> | number
    bounced?: BoolFilter<"AnalyticsSession"> | boolean
    source?: StringNullableFilter<"AnalyticsSession"> | string | null
    medium?: StringNullableFilter<"AnalyticsSession"> | string | null
    campaign?: StringNullableFilter<"AnalyticsSession"> | string | null
    content?: StringNullableFilter<"AnalyticsSession"> | string | null
    term?: StringNullableFilter<"AnalyticsSession"> | string | null
    deviceType?: StringNullableFilter<"AnalyticsSession"> | string | null
    deviceBrand?: StringNullableFilter<"AnalyticsSession"> | string | null
    browser?: StringNullableFilter<"AnalyticsSession"> | string | null
    os?: StringNullableFilter<"AnalyticsSession"> | string | null
    screenResolution?: StringNullableFilter<"AnalyticsSession"> | string | null
    country?: StringNullableFilter<"AnalyticsSession"> | string | null
    region?: StringNullableFilter<"AnalyticsSession"> | string | null
    city?: StringNullableFilter<"AnalyticsSession"> | string | null
    engagementScore?: FloatNullableFilter<"AnalyticsSession"> | number | null
    conversionValue?: FloatNullableFilter<"AnalyticsSession"> | number | null
    createdAt?: DateTimeFilter<"AnalyticsSession"> | Date | string
    updatedAt?: DateTimeFilter<"AnalyticsSession"> | Date | string
  }, "id">

  export type AnalyticsSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    visitorId?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    pageViews?: SortOrder
    events?: SortOrder
    bounced?: SortOrder
    source?: SortOrderInput | SortOrder
    medium?: SortOrderInput | SortOrder
    campaign?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    term?: SortOrderInput | SortOrder
    deviceType?: SortOrderInput | SortOrder
    deviceBrand?: SortOrderInput | SortOrder
    browser?: SortOrderInput | SortOrder
    os?: SortOrderInput | SortOrder
    screenResolution?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    engagementScore?: SortOrderInput | SortOrder
    conversionValue?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AnalyticsSessionCountOrderByAggregateInput
    _avg?: AnalyticsSessionAvgOrderByAggregateInput
    _max?: AnalyticsSessionMaxOrderByAggregateInput
    _min?: AnalyticsSessionMinOrderByAggregateInput
    _sum?: AnalyticsSessionSumOrderByAggregateInput
  }

  export type AnalyticsSessionScalarWhereWithAggregatesInput = {
    AND?: AnalyticsSessionScalarWhereWithAggregatesInput | AnalyticsSessionScalarWhereWithAggregatesInput[]
    OR?: AnalyticsSessionScalarWhereWithAggregatesInput[]
    NOT?: AnalyticsSessionScalarWhereWithAggregatesInput | AnalyticsSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AnalyticsSession"> | string
    userId?: StringNullableWithAggregatesFilter<"AnalyticsSession"> | string | null
    visitorId?: StringNullableWithAggregatesFilter<"AnalyticsSession"> | string | null
    startTime?: DateTimeWithAggregatesFilter<"AnalyticsSession"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"AnalyticsSession"> | Date | string | null
    duration?: IntNullableWithAggregatesFilter<"AnalyticsSession"> | number | null
    pageViews?: IntWithAggregatesFilter<"AnalyticsSession"> | number
    events?: IntWithAggregatesFilter<"AnalyticsSession"> | number
    bounced?: BoolWithAggregatesFilter<"AnalyticsSession"> | boolean
    source?: StringNullableWithAggregatesFilter<"AnalyticsSession"> | string | null
    medium?: StringNullableWithAggregatesFilter<"AnalyticsSession"> | string | null
    campaign?: StringNullableWithAggregatesFilter<"AnalyticsSession"> | string | null
    content?: StringNullableWithAggregatesFilter<"AnalyticsSession"> | string | null
    term?: StringNullableWithAggregatesFilter<"AnalyticsSession"> | string | null
    deviceType?: StringNullableWithAggregatesFilter<"AnalyticsSession"> | string | null
    deviceBrand?: StringNullableWithAggregatesFilter<"AnalyticsSession"> | string | null
    browser?: StringNullableWithAggregatesFilter<"AnalyticsSession"> | string | null
    os?: StringNullableWithAggregatesFilter<"AnalyticsSession"> | string | null
    screenResolution?: StringNullableWithAggregatesFilter<"AnalyticsSession"> | string | null
    country?: StringNullableWithAggregatesFilter<"AnalyticsSession"> | string | null
    region?: StringNullableWithAggregatesFilter<"AnalyticsSession"> | string | null
    city?: StringNullableWithAggregatesFilter<"AnalyticsSession"> | string | null
    engagementScore?: FloatNullableWithAggregatesFilter<"AnalyticsSession"> | number | null
    conversionValue?: FloatNullableWithAggregatesFilter<"AnalyticsSession"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"AnalyticsSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AnalyticsSession"> | Date | string
  }

  export type AnalyticsMetricWhereInput = {
    AND?: AnalyticsMetricWhereInput | AnalyticsMetricWhereInput[]
    OR?: AnalyticsMetricWhereInput[]
    NOT?: AnalyticsMetricWhereInput | AnalyticsMetricWhereInput[]
    id?: StringFilter<"AnalyticsMetric"> | string
    name?: StringFilter<"AnalyticsMetric"> | string
    type?: StringFilter<"AnalyticsMetric"> | string
    category?: StringFilter<"AnalyticsMetric"> | string
    calculation?: JsonFilter<"AnalyticsMetric">
    dailyValues?: JsonNullableFilter<"AnalyticsMetric">
    weeklyValues?: JsonNullableFilter<"AnalyticsMetric">
    monthlyValues?: JsonNullableFilter<"AnalyticsMetric">
    lastCalculated?: DateTimeNullableFilter<"AnalyticsMetric"> | Date | string | null
    createdAt?: DateTimeFilter<"AnalyticsMetric"> | Date | string
    updatedAt?: DateTimeFilter<"AnalyticsMetric"> | Date | string
  }

  export type AnalyticsMetricOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    category?: SortOrder
    calculation?: SortOrder
    dailyValues?: SortOrderInput | SortOrder
    weeklyValues?: SortOrderInput | SortOrder
    monthlyValues?: SortOrderInput | SortOrder
    lastCalculated?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalyticsMetricWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: AnalyticsMetricWhereInput | AnalyticsMetricWhereInput[]
    OR?: AnalyticsMetricWhereInput[]
    NOT?: AnalyticsMetricWhereInput | AnalyticsMetricWhereInput[]
    type?: StringFilter<"AnalyticsMetric"> | string
    category?: StringFilter<"AnalyticsMetric"> | string
    calculation?: JsonFilter<"AnalyticsMetric">
    dailyValues?: JsonNullableFilter<"AnalyticsMetric">
    weeklyValues?: JsonNullableFilter<"AnalyticsMetric">
    monthlyValues?: JsonNullableFilter<"AnalyticsMetric">
    lastCalculated?: DateTimeNullableFilter<"AnalyticsMetric"> | Date | string | null
    createdAt?: DateTimeFilter<"AnalyticsMetric"> | Date | string
    updatedAt?: DateTimeFilter<"AnalyticsMetric"> | Date | string
  }, "id" | "name">

  export type AnalyticsMetricOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    category?: SortOrder
    calculation?: SortOrder
    dailyValues?: SortOrderInput | SortOrder
    weeklyValues?: SortOrderInput | SortOrder
    monthlyValues?: SortOrderInput | SortOrder
    lastCalculated?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AnalyticsMetricCountOrderByAggregateInput
    _max?: AnalyticsMetricMaxOrderByAggregateInput
    _min?: AnalyticsMetricMinOrderByAggregateInput
  }

  export type AnalyticsMetricScalarWhereWithAggregatesInput = {
    AND?: AnalyticsMetricScalarWhereWithAggregatesInput | AnalyticsMetricScalarWhereWithAggregatesInput[]
    OR?: AnalyticsMetricScalarWhereWithAggregatesInput[]
    NOT?: AnalyticsMetricScalarWhereWithAggregatesInput | AnalyticsMetricScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AnalyticsMetric"> | string
    name?: StringWithAggregatesFilter<"AnalyticsMetric"> | string
    type?: StringWithAggregatesFilter<"AnalyticsMetric"> | string
    category?: StringWithAggregatesFilter<"AnalyticsMetric"> | string
    calculation?: JsonWithAggregatesFilter<"AnalyticsMetric">
    dailyValues?: JsonNullableWithAggregatesFilter<"AnalyticsMetric">
    weeklyValues?: JsonNullableWithAggregatesFilter<"AnalyticsMetric">
    monthlyValues?: JsonNullableWithAggregatesFilter<"AnalyticsMetric">
    lastCalculated?: DateTimeNullableWithAggregatesFilter<"AnalyticsMetric"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AnalyticsMetric"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AnalyticsMetric"> | Date | string
  }

  export type AnalyticsCohortWhereInput = {
    AND?: AnalyticsCohortWhereInput | AnalyticsCohortWhereInput[]
    OR?: AnalyticsCohortWhereInput[]
    NOT?: AnalyticsCohortWhereInput | AnalyticsCohortWhereInput[]
    id?: StringFilter<"AnalyticsCohort"> | string
    name?: StringFilter<"AnalyticsCohort"> | string
    definition?: JsonFilter<"AnalyticsCohort">
    userCount?: IntFilter<"AnalyticsCohort"> | number
    retentionData?: JsonNullableFilter<"AnalyticsCohort">
    engagementData?: JsonNullableFilter<"AnalyticsCohort">
    revenueData?: JsonNullableFilter<"AnalyticsCohort">
    lastUpdated?: DateTimeNullableFilter<"AnalyticsCohort"> | Date | string | null
    createdAt?: DateTimeFilter<"AnalyticsCohort"> | Date | string
    updatedAt?: DateTimeFilter<"AnalyticsCohort"> | Date | string
  }

  export type AnalyticsCohortOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    definition?: SortOrder
    userCount?: SortOrder
    retentionData?: SortOrderInput | SortOrder
    engagementData?: SortOrderInput | SortOrder
    revenueData?: SortOrderInput | SortOrder
    lastUpdated?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalyticsCohortWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: AnalyticsCohortWhereInput | AnalyticsCohortWhereInput[]
    OR?: AnalyticsCohortWhereInput[]
    NOT?: AnalyticsCohortWhereInput | AnalyticsCohortWhereInput[]
    definition?: JsonFilter<"AnalyticsCohort">
    userCount?: IntFilter<"AnalyticsCohort"> | number
    retentionData?: JsonNullableFilter<"AnalyticsCohort">
    engagementData?: JsonNullableFilter<"AnalyticsCohort">
    revenueData?: JsonNullableFilter<"AnalyticsCohort">
    lastUpdated?: DateTimeNullableFilter<"AnalyticsCohort"> | Date | string | null
    createdAt?: DateTimeFilter<"AnalyticsCohort"> | Date | string
    updatedAt?: DateTimeFilter<"AnalyticsCohort"> | Date | string
  }, "id" | "name">

  export type AnalyticsCohortOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    definition?: SortOrder
    userCount?: SortOrder
    retentionData?: SortOrderInput | SortOrder
    engagementData?: SortOrderInput | SortOrder
    revenueData?: SortOrderInput | SortOrder
    lastUpdated?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AnalyticsCohortCountOrderByAggregateInput
    _avg?: AnalyticsCohortAvgOrderByAggregateInput
    _max?: AnalyticsCohortMaxOrderByAggregateInput
    _min?: AnalyticsCohortMinOrderByAggregateInput
    _sum?: AnalyticsCohortSumOrderByAggregateInput
  }

  export type AnalyticsCohortScalarWhereWithAggregatesInput = {
    AND?: AnalyticsCohortScalarWhereWithAggregatesInput | AnalyticsCohortScalarWhereWithAggregatesInput[]
    OR?: AnalyticsCohortScalarWhereWithAggregatesInput[]
    NOT?: AnalyticsCohortScalarWhereWithAggregatesInput | AnalyticsCohortScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AnalyticsCohort"> | string
    name?: StringWithAggregatesFilter<"AnalyticsCohort"> | string
    definition?: JsonWithAggregatesFilter<"AnalyticsCohort">
    userCount?: IntWithAggregatesFilter<"AnalyticsCohort"> | number
    retentionData?: JsonNullableWithAggregatesFilter<"AnalyticsCohort">
    engagementData?: JsonNullableWithAggregatesFilter<"AnalyticsCohort">
    revenueData?: JsonNullableWithAggregatesFilter<"AnalyticsCohort">
    lastUpdated?: DateTimeNullableWithAggregatesFilter<"AnalyticsCohort"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AnalyticsCohort"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AnalyticsCohort"> | Date | string
  }

  export type AnalyticsFunnelWhereInput = {
    AND?: AnalyticsFunnelWhereInput | AnalyticsFunnelWhereInput[]
    OR?: AnalyticsFunnelWhereInput[]
    NOT?: AnalyticsFunnelWhereInput | AnalyticsFunnelWhereInput[]
    id?: StringFilter<"AnalyticsFunnel"> | string
    name?: StringFilter<"AnalyticsFunnel"> | string
    steps?: JsonFilter<"AnalyticsFunnel">
    conversionRates?: JsonNullableFilter<"AnalyticsFunnel">
    dropoffRates?: JsonNullableFilter<"AnalyticsFunnel">
    avgTimePerStep?: JsonNullableFilter<"AnalyticsFunnel">
    lastCalculated?: DateTimeNullableFilter<"AnalyticsFunnel"> | Date | string | null
    createdAt?: DateTimeFilter<"AnalyticsFunnel"> | Date | string
    updatedAt?: DateTimeFilter<"AnalyticsFunnel"> | Date | string
  }

  export type AnalyticsFunnelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    steps?: SortOrder
    conversionRates?: SortOrderInput | SortOrder
    dropoffRates?: SortOrderInput | SortOrder
    avgTimePerStep?: SortOrderInput | SortOrder
    lastCalculated?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalyticsFunnelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: AnalyticsFunnelWhereInput | AnalyticsFunnelWhereInput[]
    OR?: AnalyticsFunnelWhereInput[]
    NOT?: AnalyticsFunnelWhereInput | AnalyticsFunnelWhereInput[]
    steps?: JsonFilter<"AnalyticsFunnel">
    conversionRates?: JsonNullableFilter<"AnalyticsFunnel">
    dropoffRates?: JsonNullableFilter<"AnalyticsFunnel">
    avgTimePerStep?: JsonNullableFilter<"AnalyticsFunnel">
    lastCalculated?: DateTimeNullableFilter<"AnalyticsFunnel"> | Date | string | null
    createdAt?: DateTimeFilter<"AnalyticsFunnel"> | Date | string
    updatedAt?: DateTimeFilter<"AnalyticsFunnel"> | Date | string
  }, "id" | "name">

  export type AnalyticsFunnelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    steps?: SortOrder
    conversionRates?: SortOrderInput | SortOrder
    dropoffRates?: SortOrderInput | SortOrder
    avgTimePerStep?: SortOrderInput | SortOrder
    lastCalculated?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AnalyticsFunnelCountOrderByAggregateInput
    _max?: AnalyticsFunnelMaxOrderByAggregateInput
    _min?: AnalyticsFunnelMinOrderByAggregateInput
  }

  export type AnalyticsFunnelScalarWhereWithAggregatesInput = {
    AND?: AnalyticsFunnelScalarWhereWithAggregatesInput | AnalyticsFunnelScalarWhereWithAggregatesInput[]
    OR?: AnalyticsFunnelScalarWhereWithAggregatesInput[]
    NOT?: AnalyticsFunnelScalarWhereWithAggregatesInput | AnalyticsFunnelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AnalyticsFunnel"> | string
    name?: StringWithAggregatesFilter<"AnalyticsFunnel"> | string
    steps?: JsonWithAggregatesFilter<"AnalyticsFunnel">
    conversionRates?: JsonNullableWithAggregatesFilter<"AnalyticsFunnel">
    dropoffRates?: JsonNullableWithAggregatesFilter<"AnalyticsFunnel">
    avgTimePerStep?: JsonNullableWithAggregatesFilter<"AnalyticsFunnel">
    lastCalculated?: DateTimeNullableWithAggregatesFilter<"AnalyticsFunnel"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AnalyticsFunnel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AnalyticsFunnel"> | Date | string
  }

  export type AnalyticsAttributionWhereInput = {
    AND?: AnalyticsAttributionWhereInput | AnalyticsAttributionWhereInput[]
    OR?: AnalyticsAttributionWhereInput[]
    NOT?: AnalyticsAttributionWhereInput | AnalyticsAttributionWhereInput[]
    id?: StringFilter<"AnalyticsAttribution"> | string
    userId?: StringFilter<"AnalyticsAttribution"> | string
    conversionId?: StringNullableFilter<"AnalyticsAttribution"> | string | null
    conversionType?: StringFilter<"AnalyticsAttribution"> | string
    conversionValue?: FloatNullableFilter<"AnalyticsAttribution"> | number | null
    touchpoints?: JsonFilter<"AnalyticsAttribution">
    model?: StringFilter<"AnalyticsAttribution"> | string
    channelWeights?: JsonFilter<"AnalyticsAttribution">
    convertedAt?: DateTimeNullableFilter<"AnalyticsAttribution"> | Date | string | null
    createdAt?: DateTimeFilter<"AnalyticsAttribution"> | Date | string
  }

  export type AnalyticsAttributionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    conversionId?: SortOrderInput | SortOrder
    conversionType?: SortOrder
    conversionValue?: SortOrderInput | SortOrder
    touchpoints?: SortOrder
    model?: SortOrder
    channelWeights?: SortOrder
    convertedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsAttributionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnalyticsAttributionWhereInput | AnalyticsAttributionWhereInput[]
    OR?: AnalyticsAttributionWhereInput[]
    NOT?: AnalyticsAttributionWhereInput | AnalyticsAttributionWhereInput[]
    userId?: StringFilter<"AnalyticsAttribution"> | string
    conversionId?: StringNullableFilter<"AnalyticsAttribution"> | string | null
    conversionType?: StringFilter<"AnalyticsAttribution"> | string
    conversionValue?: FloatNullableFilter<"AnalyticsAttribution"> | number | null
    touchpoints?: JsonFilter<"AnalyticsAttribution">
    model?: StringFilter<"AnalyticsAttribution"> | string
    channelWeights?: JsonFilter<"AnalyticsAttribution">
    convertedAt?: DateTimeNullableFilter<"AnalyticsAttribution"> | Date | string | null
    createdAt?: DateTimeFilter<"AnalyticsAttribution"> | Date | string
  }, "id">

  export type AnalyticsAttributionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    conversionId?: SortOrderInput | SortOrder
    conversionType?: SortOrder
    conversionValue?: SortOrderInput | SortOrder
    touchpoints?: SortOrder
    model?: SortOrder
    channelWeights?: SortOrder
    convertedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AnalyticsAttributionCountOrderByAggregateInput
    _avg?: AnalyticsAttributionAvgOrderByAggregateInput
    _max?: AnalyticsAttributionMaxOrderByAggregateInput
    _min?: AnalyticsAttributionMinOrderByAggregateInput
    _sum?: AnalyticsAttributionSumOrderByAggregateInput
  }

  export type AnalyticsAttributionScalarWhereWithAggregatesInput = {
    AND?: AnalyticsAttributionScalarWhereWithAggregatesInput | AnalyticsAttributionScalarWhereWithAggregatesInput[]
    OR?: AnalyticsAttributionScalarWhereWithAggregatesInput[]
    NOT?: AnalyticsAttributionScalarWhereWithAggregatesInput | AnalyticsAttributionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AnalyticsAttribution"> | string
    userId?: StringWithAggregatesFilter<"AnalyticsAttribution"> | string
    conversionId?: StringNullableWithAggregatesFilter<"AnalyticsAttribution"> | string | null
    conversionType?: StringWithAggregatesFilter<"AnalyticsAttribution"> | string
    conversionValue?: FloatNullableWithAggregatesFilter<"AnalyticsAttribution"> | number | null
    touchpoints?: JsonWithAggregatesFilter<"AnalyticsAttribution">
    model?: StringWithAggregatesFilter<"AnalyticsAttribution"> | string
    channelWeights?: JsonWithAggregatesFilter<"AnalyticsAttribution">
    convertedAt?: DateTimeNullableWithAggregatesFilter<"AnalyticsAttribution"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AnalyticsAttribution"> | Date | string
  }

  export type AnalyticsSegmentWhereInput = {
    AND?: AnalyticsSegmentWhereInput | AnalyticsSegmentWhereInput[]
    OR?: AnalyticsSegmentWhereInput[]
    NOT?: AnalyticsSegmentWhereInput | AnalyticsSegmentWhereInput[]
    id?: StringFilter<"AnalyticsSegment"> | string
    name?: StringFilter<"AnalyticsSegment"> | string
    type?: StringFilter<"AnalyticsSegment"> | string
    conditions?: JsonFilter<"AnalyticsSegment">
    userCount?: IntFilter<"AnalyticsSegment"> | number
    avgEngagement?: FloatNullableFilter<"AnalyticsSegment"> | number | null
    avgRevenue?: FloatNullableFilter<"AnalyticsSegment"> | number | null
    conversionRate?: FloatNullableFilter<"AnalyticsSegment"> | number | null
    lastUpdated?: DateTimeNullableFilter<"AnalyticsSegment"> | Date | string | null
    createdAt?: DateTimeFilter<"AnalyticsSegment"> | Date | string
    updatedAt?: DateTimeFilter<"AnalyticsSegment"> | Date | string
  }

  export type AnalyticsSegmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    conditions?: SortOrder
    userCount?: SortOrder
    avgEngagement?: SortOrderInput | SortOrder
    avgRevenue?: SortOrderInput | SortOrder
    conversionRate?: SortOrderInput | SortOrder
    lastUpdated?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalyticsSegmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: AnalyticsSegmentWhereInput | AnalyticsSegmentWhereInput[]
    OR?: AnalyticsSegmentWhereInput[]
    NOT?: AnalyticsSegmentWhereInput | AnalyticsSegmentWhereInput[]
    type?: StringFilter<"AnalyticsSegment"> | string
    conditions?: JsonFilter<"AnalyticsSegment">
    userCount?: IntFilter<"AnalyticsSegment"> | number
    avgEngagement?: FloatNullableFilter<"AnalyticsSegment"> | number | null
    avgRevenue?: FloatNullableFilter<"AnalyticsSegment"> | number | null
    conversionRate?: FloatNullableFilter<"AnalyticsSegment"> | number | null
    lastUpdated?: DateTimeNullableFilter<"AnalyticsSegment"> | Date | string | null
    createdAt?: DateTimeFilter<"AnalyticsSegment"> | Date | string
    updatedAt?: DateTimeFilter<"AnalyticsSegment"> | Date | string
  }, "id" | "name">

  export type AnalyticsSegmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    conditions?: SortOrder
    userCount?: SortOrder
    avgEngagement?: SortOrderInput | SortOrder
    avgRevenue?: SortOrderInput | SortOrder
    conversionRate?: SortOrderInput | SortOrder
    lastUpdated?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AnalyticsSegmentCountOrderByAggregateInput
    _avg?: AnalyticsSegmentAvgOrderByAggregateInput
    _max?: AnalyticsSegmentMaxOrderByAggregateInput
    _min?: AnalyticsSegmentMinOrderByAggregateInput
    _sum?: AnalyticsSegmentSumOrderByAggregateInput
  }

  export type AnalyticsSegmentScalarWhereWithAggregatesInput = {
    AND?: AnalyticsSegmentScalarWhereWithAggregatesInput | AnalyticsSegmentScalarWhereWithAggregatesInput[]
    OR?: AnalyticsSegmentScalarWhereWithAggregatesInput[]
    NOT?: AnalyticsSegmentScalarWhereWithAggregatesInput | AnalyticsSegmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AnalyticsSegment"> | string
    name?: StringWithAggregatesFilter<"AnalyticsSegment"> | string
    type?: StringWithAggregatesFilter<"AnalyticsSegment"> | string
    conditions?: JsonWithAggregatesFilter<"AnalyticsSegment">
    userCount?: IntWithAggregatesFilter<"AnalyticsSegment"> | number
    avgEngagement?: FloatNullableWithAggregatesFilter<"AnalyticsSegment"> | number | null
    avgRevenue?: FloatNullableWithAggregatesFilter<"AnalyticsSegment"> | number | null
    conversionRate?: FloatNullableWithAggregatesFilter<"AnalyticsSegment"> | number | null
    lastUpdated?: DateTimeNullableWithAggregatesFilter<"AnalyticsSegment"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AnalyticsSegment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AnalyticsSegment"> | Date | string
  }

  export type AnalyticsReportWhereInput = {
    AND?: AnalyticsReportWhereInput | AnalyticsReportWhereInput[]
    OR?: AnalyticsReportWhereInput[]
    NOT?: AnalyticsReportWhereInput | AnalyticsReportWhereInput[]
    id?: StringFilter<"AnalyticsReport"> | string
    name?: StringFilter<"AnalyticsReport"> | string
    type?: StringFilter<"AnalyticsReport"> | string
    definition?: JsonFilter<"AnalyticsReport">
    schedule?: StringNullableFilter<"AnalyticsReport"> | string | null
    lastRun?: DateTimeNullableFilter<"AnalyticsReport"> | Date | string | null
    nextRun?: DateTimeNullableFilter<"AnalyticsReport"> | Date | string | null
    recipients?: JsonNullableFilter<"AnalyticsReport">
    format?: StringFilter<"AnalyticsReport"> | string
    createdBy?: StringNullableFilter<"AnalyticsReport"> | string | null
    createdAt?: DateTimeFilter<"AnalyticsReport"> | Date | string
    updatedAt?: DateTimeFilter<"AnalyticsReport"> | Date | string
  }

  export type AnalyticsReportOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    definition?: SortOrder
    schedule?: SortOrderInput | SortOrder
    lastRun?: SortOrderInput | SortOrder
    nextRun?: SortOrderInput | SortOrder
    recipients?: SortOrderInput | SortOrder
    format?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalyticsReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnalyticsReportWhereInput | AnalyticsReportWhereInput[]
    OR?: AnalyticsReportWhereInput[]
    NOT?: AnalyticsReportWhereInput | AnalyticsReportWhereInput[]
    name?: StringFilter<"AnalyticsReport"> | string
    type?: StringFilter<"AnalyticsReport"> | string
    definition?: JsonFilter<"AnalyticsReport">
    schedule?: StringNullableFilter<"AnalyticsReport"> | string | null
    lastRun?: DateTimeNullableFilter<"AnalyticsReport"> | Date | string | null
    nextRun?: DateTimeNullableFilter<"AnalyticsReport"> | Date | string | null
    recipients?: JsonNullableFilter<"AnalyticsReport">
    format?: StringFilter<"AnalyticsReport"> | string
    createdBy?: StringNullableFilter<"AnalyticsReport"> | string | null
    createdAt?: DateTimeFilter<"AnalyticsReport"> | Date | string
    updatedAt?: DateTimeFilter<"AnalyticsReport"> | Date | string
  }, "id">

  export type AnalyticsReportOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    definition?: SortOrder
    schedule?: SortOrderInput | SortOrder
    lastRun?: SortOrderInput | SortOrder
    nextRun?: SortOrderInput | SortOrder
    recipients?: SortOrderInput | SortOrder
    format?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AnalyticsReportCountOrderByAggregateInput
    _max?: AnalyticsReportMaxOrderByAggregateInput
    _min?: AnalyticsReportMinOrderByAggregateInput
  }

  export type AnalyticsReportScalarWhereWithAggregatesInput = {
    AND?: AnalyticsReportScalarWhereWithAggregatesInput | AnalyticsReportScalarWhereWithAggregatesInput[]
    OR?: AnalyticsReportScalarWhereWithAggregatesInput[]
    NOT?: AnalyticsReportScalarWhereWithAggregatesInput | AnalyticsReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AnalyticsReport"> | string
    name?: StringWithAggregatesFilter<"AnalyticsReport"> | string
    type?: StringWithAggregatesFilter<"AnalyticsReport"> | string
    definition?: JsonWithAggregatesFilter<"AnalyticsReport">
    schedule?: StringNullableWithAggregatesFilter<"AnalyticsReport"> | string | null
    lastRun?: DateTimeNullableWithAggregatesFilter<"AnalyticsReport"> | Date | string | null
    nextRun?: DateTimeNullableWithAggregatesFilter<"AnalyticsReport"> | Date | string | null
    recipients?: JsonNullableWithAggregatesFilter<"AnalyticsReport">
    format?: StringWithAggregatesFilter<"AnalyticsReport"> | string
    createdBy?: StringNullableWithAggregatesFilter<"AnalyticsReport"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AnalyticsReport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AnalyticsReport"> | Date | string
  }

  export type QuizSessionWhereInput = {
    AND?: QuizSessionWhereInput | QuizSessionWhereInput[]
    OR?: QuizSessionWhereInput[]
    NOT?: QuizSessionWhereInput | QuizSessionWhereInput[]
    id?: StringFilter<"QuizSession"> | string
    sessionId?: StringFilter<"QuizSession"> | string
    quizId?: StringFilter<"QuizSession"> | string
    source?: StringNullableFilter<"QuizSession"> | string | null
    utmSource?: StringNullableFilter<"QuizSession"> | string | null
    utmMedium?: StringNullableFilter<"QuizSession"> | string | null
    utmCampaign?: StringNullableFilter<"QuizSession"> | string | null
    utmContent?: StringNullableFilter<"QuizSession"> | string | null
    contentId?: StringNullableFilter<"QuizSession"> | string | null
    campaignId?: StringNullableFilter<"QuizSession"> | string | null
    deviceInfo?: JsonNullableFilter<"QuizSession">
    landingPage?: StringNullableFilter<"QuizSession"> | string | null
    ipAddress?: StringNullableFilter<"QuizSession"> | string | null
    userAgent?: StringNullableFilter<"QuizSession"> | string | null
    status?: StringFilter<"QuizSession"> | string
    createdAt?: DateTimeFilter<"QuizSession"> | Date | string
    startTime?: DateTimeFilter<"QuizSession"> | Date | string
    endTime?: DateTimeNullableFilter<"QuizSession"> | Date | string | null
    completionRate?: FloatNullableFilter<"QuizSession"> | number | null
    userName?: StringNullableFilter<"QuizSession"> | string | null
    email?: StringNullableFilter<"QuizSession"> | string | null
    phoneNumber?: StringNullableFilter<"QuizSession"> | string | null
    companyName?: StringNullableFilter<"QuizSession"> | string | null
    userType?: StringNullableFilter<"QuizSession"> | string | null
    selectedBrand?: StringNullableFilter<"QuizSession"> | string | null
    userSegment?: StringNullableFilter<"QuizSession"> | string | null
    crewSize?: IntNullableFilter<"QuizSession"> | number | null
    leadQualityScore?: FloatNullableFilter<"QuizSession"> | number | null
    version?: StringNullableFilter<"QuizSession"> | string | null
    responses?: QuizResponseListRelationFilter
    interactions?: BehavioralInteractionListRelationFilter
    conversions?: QuizConversionListRelationFilter
  }

  export type QuizSessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    quizId?: SortOrder
    source?: SortOrderInput | SortOrder
    utmSource?: SortOrderInput | SortOrder
    utmMedium?: SortOrderInput | SortOrder
    utmCampaign?: SortOrderInput | SortOrder
    utmContent?: SortOrderInput | SortOrder
    contentId?: SortOrderInput | SortOrder
    campaignId?: SortOrderInput | SortOrder
    deviceInfo?: SortOrderInput | SortOrder
    landingPage?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    completionRate?: SortOrderInput | SortOrder
    userName?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    companyName?: SortOrderInput | SortOrder
    userType?: SortOrderInput | SortOrder
    selectedBrand?: SortOrderInput | SortOrder
    userSegment?: SortOrderInput | SortOrder
    crewSize?: SortOrderInput | SortOrder
    leadQualityScore?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    responses?: QuizResponseOrderByRelationAggregateInput
    interactions?: BehavioralInteractionOrderByRelationAggregateInput
    conversions?: QuizConversionOrderByRelationAggregateInput
  }

  export type QuizSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionId?: string
    AND?: QuizSessionWhereInput | QuizSessionWhereInput[]
    OR?: QuizSessionWhereInput[]
    NOT?: QuizSessionWhereInput | QuizSessionWhereInput[]
    quizId?: StringFilter<"QuizSession"> | string
    source?: StringNullableFilter<"QuizSession"> | string | null
    utmSource?: StringNullableFilter<"QuizSession"> | string | null
    utmMedium?: StringNullableFilter<"QuizSession"> | string | null
    utmCampaign?: StringNullableFilter<"QuizSession"> | string | null
    utmContent?: StringNullableFilter<"QuizSession"> | string | null
    contentId?: StringNullableFilter<"QuizSession"> | string | null
    campaignId?: StringNullableFilter<"QuizSession"> | string | null
    deviceInfo?: JsonNullableFilter<"QuizSession">
    landingPage?: StringNullableFilter<"QuizSession"> | string | null
    ipAddress?: StringNullableFilter<"QuizSession"> | string | null
    userAgent?: StringNullableFilter<"QuizSession"> | string | null
    status?: StringFilter<"QuizSession"> | string
    createdAt?: DateTimeFilter<"QuizSession"> | Date | string
    startTime?: DateTimeFilter<"QuizSession"> | Date | string
    endTime?: DateTimeNullableFilter<"QuizSession"> | Date | string | null
    completionRate?: FloatNullableFilter<"QuizSession"> | number | null
    userName?: StringNullableFilter<"QuizSession"> | string | null
    email?: StringNullableFilter<"QuizSession"> | string | null
    phoneNumber?: StringNullableFilter<"QuizSession"> | string | null
    companyName?: StringNullableFilter<"QuizSession"> | string | null
    userType?: StringNullableFilter<"QuizSession"> | string | null
    selectedBrand?: StringNullableFilter<"QuizSession"> | string | null
    userSegment?: StringNullableFilter<"QuizSession"> | string | null
    crewSize?: IntNullableFilter<"QuizSession"> | number | null
    leadQualityScore?: FloatNullableFilter<"QuizSession"> | number | null
    version?: StringNullableFilter<"QuizSession"> | string | null
    responses?: QuizResponseListRelationFilter
    interactions?: BehavioralInteractionListRelationFilter
    conversions?: QuizConversionListRelationFilter
  }, "id" | "sessionId">

  export type QuizSessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    quizId?: SortOrder
    source?: SortOrderInput | SortOrder
    utmSource?: SortOrderInput | SortOrder
    utmMedium?: SortOrderInput | SortOrder
    utmCampaign?: SortOrderInput | SortOrder
    utmContent?: SortOrderInput | SortOrder
    contentId?: SortOrderInput | SortOrder
    campaignId?: SortOrderInput | SortOrder
    deviceInfo?: SortOrderInput | SortOrder
    landingPage?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    completionRate?: SortOrderInput | SortOrder
    userName?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    companyName?: SortOrderInput | SortOrder
    userType?: SortOrderInput | SortOrder
    selectedBrand?: SortOrderInput | SortOrder
    userSegment?: SortOrderInput | SortOrder
    crewSize?: SortOrderInput | SortOrder
    leadQualityScore?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    _count?: QuizSessionCountOrderByAggregateInput
    _avg?: QuizSessionAvgOrderByAggregateInput
    _max?: QuizSessionMaxOrderByAggregateInput
    _min?: QuizSessionMinOrderByAggregateInput
    _sum?: QuizSessionSumOrderByAggregateInput
  }

  export type QuizSessionScalarWhereWithAggregatesInput = {
    AND?: QuizSessionScalarWhereWithAggregatesInput | QuizSessionScalarWhereWithAggregatesInput[]
    OR?: QuizSessionScalarWhereWithAggregatesInput[]
    NOT?: QuizSessionScalarWhereWithAggregatesInput | QuizSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuizSession"> | string
    sessionId?: StringWithAggregatesFilter<"QuizSession"> | string
    quizId?: StringWithAggregatesFilter<"QuizSession"> | string
    source?: StringNullableWithAggregatesFilter<"QuizSession"> | string | null
    utmSource?: StringNullableWithAggregatesFilter<"QuizSession"> | string | null
    utmMedium?: StringNullableWithAggregatesFilter<"QuizSession"> | string | null
    utmCampaign?: StringNullableWithAggregatesFilter<"QuizSession"> | string | null
    utmContent?: StringNullableWithAggregatesFilter<"QuizSession"> | string | null
    contentId?: StringNullableWithAggregatesFilter<"QuizSession"> | string | null
    campaignId?: StringNullableWithAggregatesFilter<"QuizSession"> | string | null
    deviceInfo?: JsonNullableWithAggregatesFilter<"QuizSession">
    landingPage?: StringNullableWithAggregatesFilter<"QuizSession"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"QuizSession"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"QuizSession"> | string | null
    status?: StringWithAggregatesFilter<"QuizSession"> | string
    createdAt?: DateTimeWithAggregatesFilter<"QuizSession"> | Date | string
    startTime?: DateTimeWithAggregatesFilter<"QuizSession"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"QuizSession"> | Date | string | null
    completionRate?: FloatNullableWithAggregatesFilter<"QuizSession"> | number | null
    userName?: StringNullableWithAggregatesFilter<"QuizSession"> | string | null
    email?: StringNullableWithAggregatesFilter<"QuizSession"> | string | null
    phoneNumber?: StringNullableWithAggregatesFilter<"QuizSession"> | string | null
    companyName?: StringNullableWithAggregatesFilter<"QuizSession"> | string | null
    userType?: StringNullableWithAggregatesFilter<"QuizSession"> | string | null
    selectedBrand?: StringNullableWithAggregatesFilter<"QuizSession"> | string | null
    userSegment?: StringNullableWithAggregatesFilter<"QuizSession"> | string | null
    crewSize?: IntNullableWithAggregatesFilter<"QuizSession"> | number | null
    leadQualityScore?: FloatNullableWithAggregatesFilter<"QuizSession"> | number | null
    version?: StringNullableWithAggregatesFilter<"QuizSession"> | string | null
  }

  export type QuizResponseWhereInput = {
    AND?: QuizResponseWhereInput | QuizResponseWhereInput[]
    OR?: QuizResponseWhereInput[]
    NOT?: QuizResponseWhereInput | QuizResponseWhereInput[]
    id?: StringFilter<"QuizResponse"> | string
    sessionId?: StringFilter<"QuizResponse"> | string
    questionId?: StringFilter<"QuizResponse"> | string
    questionType?: StringFilter<"QuizResponse"> | string
    responseValue?: JsonFilter<"QuizResponse">
    responseTime?: IntNullableFilter<"QuizResponse"> | number | null
    createdAt?: DateTimeFilter<"QuizResponse"> | Date | string
    session?: XOR<QuizSessionScalarRelationFilter, QuizSessionWhereInput>
  }

  export type QuizResponseOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    questionId?: SortOrder
    questionType?: SortOrder
    responseValue?: SortOrder
    responseTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    session?: QuizSessionOrderByWithRelationInput
  }

  export type QuizResponseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuizResponseWhereInput | QuizResponseWhereInput[]
    OR?: QuizResponseWhereInput[]
    NOT?: QuizResponseWhereInput | QuizResponseWhereInput[]
    sessionId?: StringFilter<"QuizResponse"> | string
    questionId?: StringFilter<"QuizResponse"> | string
    questionType?: StringFilter<"QuizResponse"> | string
    responseValue?: JsonFilter<"QuizResponse">
    responseTime?: IntNullableFilter<"QuizResponse"> | number | null
    createdAt?: DateTimeFilter<"QuizResponse"> | Date | string
    session?: XOR<QuizSessionScalarRelationFilter, QuizSessionWhereInput>
  }, "id">

  export type QuizResponseOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    questionId?: SortOrder
    questionType?: SortOrder
    responseValue?: SortOrder
    responseTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: QuizResponseCountOrderByAggregateInput
    _avg?: QuizResponseAvgOrderByAggregateInput
    _max?: QuizResponseMaxOrderByAggregateInput
    _min?: QuizResponseMinOrderByAggregateInput
    _sum?: QuizResponseSumOrderByAggregateInput
  }

  export type QuizResponseScalarWhereWithAggregatesInput = {
    AND?: QuizResponseScalarWhereWithAggregatesInput | QuizResponseScalarWhereWithAggregatesInput[]
    OR?: QuizResponseScalarWhereWithAggregatesInput[]
    NOT?: QuizResponseScalarWhereWithAggregatesInput | QuizResponseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuizResponse"> | string
    sessionId?: StringWithAggregatesFilter<"QuizResponse"> | string
    questionId?: StringWithAggregatesFilter<"QuizResponse"> | string
    questionType?: StringWithAggregatesFilter<"QuizResponse"> | string
    responseValue?: JsonWithAggregatesFilter<"QuizResponse">
    responseTime?: IntNullableWithAggregatesFilter<"QuizResponse"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"QuizResponse"> | Date | string
  }

  export type BehavioralInteractionWhereInput = {
    AND?: BehavioralInteractionWhereInput | BehavioralInteractionWhereInput[]
    OR?: BehavioralInteractionWhereInput[]
    NOT?: BehavioralInteractionWhereInput | BehavioralInteractionWhereInput[]
    id?: StringFilter<"BehavioralInteraction"> | string
    sessionId?: StringFilter<"BehavioralInteraction"> | string
    interactionType?: StringFilter<"BehavioralInteraction"> | string
    element?: StringNullableFilter<"BehavioralInteraction"> | string | null
    position?: JsonNullableFilter<"BehavioralInteraction">
    viewport?: JsonNullableFilter<"BehavioralInteraction">
    duration?: IntNullableFilter<"BehavioralInteraction"> | number | null
    metadata?: JsonNullableFilter<"BehavioralInteraction">
    timestamp?: DateTimeFilter<"BehavioralInteraction"> | Date | string
    session?: XOR<QuizSessionScalarRelationFilter, QuizSessionWhereInput>
  }

  export type BehavioralInteractionOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    interactionType?: SortOrder
    element?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    viewport?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    session?: QuizSessionOrderByWithRelationInput
  }

  export type BehavioralInteractionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BehavioralInteractionWhereInput | BehavioralInteractionWhereInput[]
    OR?: BehavioralInteractionWhereInput[]
    NOT?: BehavioralInteractionWhereInput | BehavioralInteractionWhereInput[]
    sessionId?: StringFilter<"BehavioralInteraction"> | string
    interactionType?: StringFilter<"BehavioralInteraction"> | string
    element?: StringNullableFilter<"BehavioralInteraction"> | string | null
    position?: JsonNullableFilter<"BehavioralInteraction">
    viewport?: JsonNullableFilter<"BehavioralInteraction">
    duration?: IntNullableFilter<"BehavioralInteraction"> | number | null
    metadata?: JsonNullableFilter<"BehavioralInteraction">
    timestamp?: DateTimeFilter<"BehavioralInteraction"> | Date | string
    session?: XOR<QuizSessionScalarRelationFilter, QuizSessionWhereInput>
  }, "id">

  export type BehavioralInteractionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    interactionType?: SortOrder
    element?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    viewport?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: BehavioralInteractionCountOrderByAggregateInput
    _avg?: BehavioralInteractionAvgOrderByAggregateInput
    _max?: BehavioralInteractionMaxOrderByAggregateInput
    _min?: BehavioralInteractionMinOrderByAggregateInput
    _sum?: BehavioralInteractionSumOrderByAggregateInput
  }

  export type BehavioralInteractionScalarWhereWithAggregatesInput = {
    AND?: BehavioralInteractionScalarWhereWithAggregatesInput | BehavioralInteractionScalarWhereWithAggregatesInput[]
    OR?: BehavioralInteractionScalarWhereWithAggregatesInput[]
    NOT?: BehavioralInteractionScalarWhereWithAggregatesInput | BehavioralInteractionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BehavioralInteraction"> | string
    sessionId?: StringWithAggregatesFilter<"BehavioralInteraction"> | string
    interactionType?: StringWithAggregatesFilter<"BehavioralInteraction"> | string
    element?: StringNullableWithAggregatesFilter<"BehavioralInteraction"> | string | null
    position?: JsonNullableWithAggregatesFilter<"BehavioralInteraction">
    viewport?: JsonNullableWithAggregatesFilter<"BehavioralInteraction">
    duration?: IntNullableWithAggregatesFilter<"BehavioralInteraction"> | number | null
    metadata?: JsonNullableWithAggregatesFilter<"BehavioralInteraction">
    timestamp?: DateTimeWithAggregatesFilter<"BehavioralInteraction"> | Date | string
  }

  export type QuizConversionWhereInput = {
    AND?: QuizConversionWhereInput | QuizConversionWhereInput[]
    OR?: QuizConversionWhereInput[]
    NOT?: QuizConversionWhereInput | QuizConversionWhereInput[]
    id?: StringFilter<"QuizConversion"> | string
    sessionId?: StringFilter<"QuizConversion"> | string
    conversionType?: StringFilter<"QuizConversion"> | string
    conversionValue?: FloatNullableFilter<"QuizConversion"> | number | null
    orderId?: StringNullableFilter<"QuizConversion"> | string | null
    metadata?: JsonNullableFilter<"QuizConversion">
    createdAt?: DateTimeFilter<"QuizConversion"> | Date | string
    session?: XOR<QuizSessionScalarRelationFilter, QuizSessionWhereInput>
  }

  export type QuizConversionOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    conversionType?: SortOrder
    conversionValue?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    session?: QuizSessionOrderByWithRelationInput
  }

  export type QuizConversionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuizConversionWhereInput | QuizConversionWhereInput[]
    OR?: QuizConversionWhereInput[]
    NOT?: QuizConversionWhereInput | QuizConversionWhereInput[]
    sessionId?: StringFilter<"QuizConversion"> | string
    conversionType?: StringFilter<"QuizConversion"> | string
    conversionValue?: FloatNullableFilter<"QuizConversion"> | number | null
    orderId?: StringNullableFilter<"QuizConversion"> | string | null
    metadata?: JsonNullableFilter<"QuizConversion">
    createdAt?: DateTimeFilter<"QuizConversion"> | Date | string
    session?: XOR<QuizSessionScalarRelationFilter, QuizSessionWhereInput>
  }, "id">

  export type QuizConversionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    conversionType?: SortOrder
    conversionValue?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: QuizConversionCountOrderByAggregateInput
    _avg?: QuizConversionAvgOrderByAggregateInput
    _max?: QuizConversionMaxOrderByAggregateInput
    _min?: QuizConversionMinOrderByAggregateInput
    _sum?: QuizConversionSumOrderByAggregateInput
  }

  export type QuizConversionScalarWhereWithAggregatesInput = {
    AND?: QuizConversionScalarWhereWithAggregatesInput | QuizConversionScalarWhereWithAggregatesInput[]
    OR?: QuizConversionScalarWhereWithAggregatesInput[]
    NOT?: QuizConversionScalarWhereWithAggregatesInput | QuizConversionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuizConversion"> | string
    sessionId?: StringWithAggregatesFilter<"QuizConversion"> | string
    conversionType?: StringWithAggregatesFilter<"QuizConversion"> | string
    conversionValue?: FloatNullableWithAggregatesFilter<"QuizConversion"> | number | null
    orderId?: StringNullableWithAggregatesFilter<"QuizConversion"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"QuizConversion">
    createdAt?: DateTimeWithAggregatesFilter<"QuizConversion"> | Date | string
  }

  export type ABTestExperimentWhereInput = {
    AND?: ABTestExperimentWhereInput | ABTestExperimentWhereInput[]
    OR?: ABTestExperimentWhereInput[]
    NOT?: ABTestExperimentWhereInput | ABTestExperimentWhereInput[]
    id?: StringFilter<"ABTestExperiment"> | string
    name?: StringFilter<"ABTestExperiment"> | string
    status?: StringFilter<"ABTestExperiment"> | string
    startDate?: DateTimeNullableFilter<"ABTestExperiment"> | Date | string | null
    endDate?: DateTimeNullableFilter<"ABTestExperiment"> | Date | string | null
    testType?: StringFilter<"ABTestExperiment"> | string
    control?: JsonFilter<"ABTestExperiment">
    variants?: JsonFilter<"ABTestExperiment">
    allocation?: JsonFilter<"ABTestExperiment">
    metrics?: JsonFilter<"ABTestExperiment">
    results?: JsonNullableFilter<"ABTestExperiment">
    winner?: StringNullableFilter<"ABTestExperiment"> | string | null
    createdAt?: DateTimeFilter<"ABTestExperiment"> | Date | string
    updatedAt?: DateTimeFilter<"ABTestExperiment"> | Date | string
  }

  export type ABTestExperimentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    testType?: SortOrder
    control?: SortOrder
    variants?: SortOrder
    allocation?: SortOrder
    metrics?: SortOrder
    results?: SortOrderInput | SortOrder
    winner?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ABTestExperimentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ABTestExperimentWhereInput | ABTestExperimentWhereInput[]
    OR?: ABTestExperimentWhereInput[]
    NOT?: ABTestExperimentWhereInput | ABTestExperimentWhereInput[]
    name?: StringFilter<"ABTestExperiment"> | string
    status?: StringFilter<"ABTestExperiment"> | string
    startDate?: DateTimeNullableFilter<"ABTestExperiment"> | Date | string | null
    endDate?: DateTimeNullableFilter<"ABTestExperiment"> | Date | string | null
    testType?: StringFilter<"ABTestExperiment"> | string
    control?: JsonFilter<"ABTestExperiment">
    variants?: JsonFilter<"ABTestExperiment">
    allocation?: JsonFilter<"ABTestExperiment">
    metrics?: JsonFilter<"ABTestExperiment">
    results?: JsonNullableFilter<"ABTestExperiment">
    winner?: StringNullableFilter<"ABTestExperiment"> | string | null
    createdAt?: DateTimeFilter<"ABTestExperiment"> | Date | string
    updatedAt?: DateTimeFilter<"ABTestExperiment"> | Date | string
  }, "id">

  export type ABTestExperimentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    testType?: SortOrder
    control?: SortOrder
    variants?: SortOrder
    allocation?: SortOrder
    metrics?: SortOrder
    results?: SortOrderInput | SortOrder
    winner?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ABTestExperimentCountOrderByAggregateInput
    _max?: ABTestExperimentMaxOrderByAggregateInput
    _min?: ABTestExperimentMinOrderByAggregateInput
  }

  export type ABTestExperimentScalarWhereWithAggregatesInput = {
    AND?: ABTestExperimentScalarWhereWithAggregatesInput | ABTestExperimentScalarWhereWithAggregatesInput[]
    OR?: ABTestExperimentScalarWhereWithAggregatesInput[]
    NOT?: ABTestExperimentScalarWhereWithAggregatesInput | ABTestExperimentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ABTestExperiment"> | string
    name?: StringWithAggregatesFilter<"ABTestExperiment"> | string
    status?: StringWithAggregatesFilter<"ABTestExperiment"> | string
    startDate?: DateTimeNullableWithAggregatesFilter<"ABTestExperiment"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"ABTestExperiment"> | Date | string | null
    testType?: StringWithAggregatesFilter<"ABTestExperiment"> | string
    control?: JsonWithAggregatesFilter<"ABTestExperiment">
    variants?: JsonWithAggregatesFilter<"ABTestExperiment">
    allocation?: JsonWithAggregatesFilter<"ABTestExperiment">
    metrics?: JsonWithAggregatesFilter<"ABTestExperiment">
    results?: JsonNullableWithAggregatesFilter<"ABTestExperiment">
    winner?: StringNullableWithAggregatesFilter<"ABTestExperiment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ABTestExperiment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ABTestExperiment"> | Date | string
  }

  export type QuizBrandWhereInput = {
    AND?: QuizBrandWhereInput | QuizBrandWhereInput[]
    OR?: QuizBrandWhereInput[]
    NOT?: QuizBrandWhereInput | QuizBrandWhereInput[]
    id?: StringFilter<"QuizBrand"> | string
    brandId?: StringFilter<"QuizBrand"> | string
    name?: StringFilter<"QuizBrand"> | string
    displayName?: StringFilter<"QuizBrand"> | string
    color?: StringFilter<"QuizBrand"> | string
    voltage?: StringFilter<"QuizBrand"> | string
    voltageOptions?: JsonFilter<"QuizBrand">
    marketShare?: FloatNullableFilter<"QuizBrand"> | number | null
    popularWith?: JsonNullableFilter<"QuizBrand">
    category?: StringNullableFilter<"QuizBrand"> | string | null
    active?: BoolFilter<"QuizBrand"> | boolean
    createdAt?: DateTimeFilter<"QuizBrand"> | Date | string
  }

  export type QuizBrandOrderByWithRelationInput = {
    id?: SortOrder
    brandId?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    color?: SortOrder
    voltage?: SortOrder
    voltageOptions?: SortOrder
    marketShare?: SortOrderInput | SortOrder
    popularWith?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizBrandWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    brandId?: string
    AND?: QuizBrandWhereInput | QuizBrandWhereInput[]
    OR?: QuizBrandWhereInput[]
    NOT?: QuizBrandWhereInput | QuizBrandWhereInput[]
    name?: StringFilter<"QuizBrand"> | string
    displayName?: StringFilter<"QuizBrand"> | string
    color?: StringFilter<"QuizBrand"> | string
    voltage?: StringFilter<"QuizBrand"> | string
    voltageOptions?: JsonFilter<"QuizBrand">
    marketShare?: FloatNullableFilter<"QuizBrand"> | number | null
    popularWith?: JsonNullableFilter<"QuizBrand">
    category?: StringNullableFilter<"QuizBrand"> | string | null
    active?: BoolFilter<"QuizBrand"> | boolean
    createdAt?: DateTimeFilter<"QuizBrand"> | Date | string
  }, "id" | "brandId">

  export type QuizBrandOrderByWithAggregationInput = {
    id?: SortOrder
    brandId?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    color?: SortOrder
    voltage?: SortOrder
    voltageOptions?: SortOrder
    marketShare?: SortOrderInput | SortOrder
    popularWith?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    _count?: QuizBrandCountOrderByAggregateInput
    _avg?: QuizBrandAvgOrderByAggregateInput
    _max?: QuizBrandMaxOrderByAggregateInput
    _min?: QuizBrandMinOrderByAggregateInput
    _sum?: QuizBrandSumOrderByAggregateInput
  }

  export type QuizBrandScalarWhereWithAggregatesInput = {
    AND?: QuizBrandScalarWhereWithAggregatesInput | QuizBrandScalarWhereWithAggregatesInput[]
    OR?: QuizBrandScalarWhereWithAggregatesInput[]
    NOT?: QuizBrandScalarWhereWithAggregatesInput | QuizBrandScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuizBrand"> | string
    brandId?: StringWithAggregatesFilter<"QuizBrand"> | string
    name?: StringWithAggregatesFilter<"QuizBrand"> | string
    displayName?: StringWithAggregatesFilter<"QuizBrand"> | string
    color?: StringWithAggregatesFilter<"QuizBrand"> | string
    voltage?: StringWithAggregatesFilter<"QuizBrand"> | string
    voltageOptions?: JsonWithAggregatesFilter<"QuizBrand">
    marketShare?: FloatNullableWithAggregatesFilter<"QuizBrand"> | number | null
    popularWith?: JsonNullableWithAggregatesFilter<"QuizBrand">
    category?: StringNullableWithAggregatesFilter<"QuizBrand"> | string | null
    active?: BoolWithAggregatesFilter<"QuizBrand"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"QuizBrand"> | Date | string
  }

  export type QuizRoutingRuleWhereInput = {
    AND?: QuizRoutingRuleWhereInput | QuizRoutingRuleWhereInput[]
    OR?: QuizRoutingRuleWhereInput[]
    NOT?: QuizRoutingRuleWhereInput | QuizRoutingRuleWhereInput[]
    id?: StringFilter<"QuizRoutingRule"> | string
    userType?: StringNullableFilter<"QuizRoutingRule"> | string | null
    brand?: StringNullableFilter<"QuizRoutingRule"> | string | null
    trade?: StringNullableFilter<"QuizRoutingRule"> | string | null
    nextQuestionId?: StringFilter<"QuizRoutingRule"> | string
    condition?: JsonNullableFilter<"QuizRoutingRule">
    priority?: IntFilter<"QuizRoutingRule"> | number
    active?: BoolFilter<"QuizRoutingRule"> | boolean
    createdAt?: DateTimeFilter<"QuizRoutingRule"> | Date | string
  }

  export type QuizRoutingRuleOrderByWithRelationInput = {
    id?: SortOrder
    userType?: SortOrderInput | SortOrder
    brand?: SortOrderInput | SortOrder
    trade?: SortOrderInput | SortOrder
    nextQuestionId?: SortOrder
    condition?: SortOrderInput | SortOrder
    priority?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizRoutingRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuizRoutingRuleWhereInput | QuizRoutingRuleWhereInput[]
    OR?: QuizRoutingRuleWhereInput[]
    NOT?: QuizRoutingRuleWhereInput | QuizRoutingRuleWhereInput[]
    userType?: StringNullableFilter<"QuizRoutingRule"> | string | null
    brand?: StringNullableFilter<"QuizRoutingRule"> | string | null
    trade?: StringNullableFilter<"QuizRoutingRule"> | string | null
    nextQuestionId?: StringFilter<"QuizRoutingRule"> | string
    condition?: JsonNullableFilter<"QuizRoutingRule">
    priority?: IntFilter<"QuizRoutingRule"> | number
    active?: BoolFilter<"QuizRoutingRule"> | boolean
    createdAt?: DateTimeFilter<"QuizRoutingRule"> | Date | string
  }, "id">

  export type QuizRoutingRuleOrderByWithAggregationInput = {
    id?: SortOrder
    userType?: SortOrderInput | SortOrder
    brand?: SortOrderInput | SortOrder
    trade?: SortOrderInput | SortOrder
    nextQuestionId?: SortOrder
    condition?: SortOrderInput | SortOrder
    priority?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    _count?: QuizRoutingRuleCountOrderByAggregateInput
    _avg?: QuizRoutingRuleAvgOrderByAggregateInput
    _max?: QuizRoutingRuleMaxOrderByAggregateInput
    _min?: QuizRoutingRuleMinOrderByAggregateInput
    _sum?: QuizRoutingRuleSumOrderByAggregateInput
  }

  export type QuizRoutingRuleScalarWhereWithAggregatesInput = {
    AND?: QuizRoutingRuleScalarWhereWithAggregatesInput | QuizRoutingRuleScalarWhereWithAggregatesInput[]
    OR?: QuizRoutingRuleScalarWhereWithAggregatesInput[]
    NOT?: QuizRoutingRuleScalarWhereWithAggregatesInput | QuizRoutingRuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuizRoutingRule"> | string
    userType?: StringNullableWithAggregatesFilter<"QuizRoutingRule"> | string | null
    brand?: StringNullableWithAggregatesFilter<"QuizRoutingRule"> | string | null
    trade?: StringNullableWithAggregatesFilter<"QuizRoutingRule"> | string | null
    nextQuestionId?: StringWithAggregatesFilter<"QuizRoutingRule"> | string
    condition?: JsonNullableWithAggregatesFilter<"QuizRoutingRule">
    priority?: IntWithAggregatesFilter<"QuizRoutingRule"> | number
    active?: BoolWithAggregatesFilter<"QuizRoutingRule"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"QuizRoutingRule"> | Date | string
  }

  export type QuizInterventionWhereInput = {
    AND?: QuizInterventionWhereInput | QuizInterventionWhereInput[]
    OR?: QuizInterventionWhereInput[]
    NOT?: QuizInterventionWhereInput | QuizInterventionWhereInput[]
    id?: StringFilter<"QuizIntervention"> | string
    sessionId?: StringFilter<"QuizIntervention"> | string
    interventionType?: StringFilter<"QuizIntervention"> | string
    triggerReason?: StringFilter<"QuizIntervention"> | string
    questionId?: StringNullableFilter<"QuizIntervention"> | string | null
    shownAt?: DateTimeFilter<"QuizIntervention"> | Date | string
    userAction?: StringNullableFilter<"QuizIntervention"> | string | null
    actionTimestamp?: DateTimeNullableFilter<"QuizIntervention"> | Date | string | null
  }

  export type QuizInterventionOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    interventionType?: SortOrder
    triggerReason?: SortOrder
    questionId?: SortOrderInput | SortOrder
    shownAt?: SortOrder
    userAction?: SortOrderInput | SortOrder
    actionTimestamp?: SortOrderInput | SortOrder
  }

  export type QuizInterventionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuizInterventionWhereInput | QuizInterventionWhereInput[]
    OR?: QuizInterventionWhereInput[]
    NOT?: QuizInterventionWhereInput | QuizInterventionWhereInput[]
    sessionId?: StringFilter<"QuizIntervention"> | string
    interventionType?: StringFilter<"QuizIntervention"> | string
    triggerReason?: StringFilter<"QuizIntervention"> | string
    questionId?: StringNullableFilter<"QuizIntervention"> | string | null
    shownAt?: DateTimeFilter<"QuizIntervention"> | Date | string
    userAction?: StringNullableFilter<"QuizIntervention"> | string | null
    actionTimestamp?: DateTimeNullableFilter<"QuizIntervention"> | Date | string | null
  }, "id">

  export type QuizInterventionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    interventionType?: SortOrder
    triggerReason?: SortOrder
    questionId?: SortOrderInput | SortOrder
    shownAt?: SortOrder
    userAction?: SortOrderInput | SortOrder
    actionTimestamp?: SortOrderInput | SortOrder
    _count?: QuizInterventionCountOrderByAggregateInput
    _max?: QuizInterventionMaxOrderByAggregateInput
    _min?: QuizInterventionMinOrderByAggregateInput
  }

  export type QuizInterventionScalarWhereWithAggregatesInput = {
    AND?: QuizInterventionScalarWhereWithAggregatesInput | QuizInterventionScalarWhereWithAggregatesInput[]
    OR?: QuizInterventionScalarWhereWithAggregatesInput[]
    NOT?: QuizInterventionScalarWhereWithAggregatesInput | QuizInterventionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuizIntervention"> | string
    sessionId?: StringWithAggregatesFilter<"QuizIntervention"> | string
    interventionType?: StringWithAggregatesFilter<"QuizIntervention"> | string
    triggerReason?: StringWithAggregatesFilter<"QuizIntervention"> | string
    questionId?: StringNullableWithAggregatesFilter<"QuizIntervention"> | string | null
    shownAt?: DateTimeWithAggregatesFilter<"QuizIntervention"> | Date | string
    userAction?: StringNullableWithAggregatesFilter<"QuizIntervention"> | string | null
    actionTimestamp?: DateTimeNullableWithAggregatesFilter<"QuizIntervention"> | Date | string | null
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: StringFilter<"Service"> | string
    serviceCode?: StringFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    description?: StringNullableFilter<"Service"> | string | null
    category?: StringFilter<"Service"> | string
    basePrice?: FloatNullableFilter<"Service"> | number | null
    pricingModel?: StringFilter<"Service"> | string
    currency?: StringFilter<"Service"> | string
    specifications?: JsonNullableFilter<"Service">
    portfolio?: JsonNullableFilter<"Service">
    leadTime?: IntNullableFilter<"Service"> | number | null
    capacity?: JsonNullableFilter<"Service">
    isActive?: BoolFilter<"Service"> | boolean
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    projects?: ProjectListRelationFilter
    quotes?: QuoteListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    serviceCode?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    basePrice?: SortOrderInput | SortOrder
    pricingModel?: SortOrder
    currency?: SortOrder
    specifications?: SortOrderInput | SortOrder
    portfolio?: SortOrderInput | SortOrder
    leadTime?: SortOrderInput | SortOrder
    capacity?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projects?: ProjectOrderByRelationAggregateInput
    quotes?: QuoteOrderByRelationAggregateInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    serviceCode?: string
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    name?: StringFilter<"Service"> | string
    description?: StringNullableFilter<"Service"> | string | null
    category?: StringFilter<"Service"> | string
    basePrice?: FloatNullableFilter<"Service"> | number | null
    pricingModel?: StringFilter<"Service"> | string
    currency?: StringFilter<"Service"> | string
    specifications?: JsonNullableFilter<"Service">
    portfolio?: JsonNullableFilter<"Service">
    leadTime?: IntNullableFilter<"Service"> | number | null
    capacity?: JsonNullableFilter<"Service">
    isActive?: BoolFilter<"Service"> | boolean
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    projects?: ProjectListRelationFilter
    quotes?: QuoteListRelationFilter
  }, "id" | "serviceCode">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    serviceCode?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    basePrice?: SortOrderInput | SortOrder
    pricingModel?: SortOrder
    currency?: SortOrder
    specifications?: SortOrderInput | SortOrder
    portfolio?: SortOrderInput | SortOrder
    leadTime?: SortOrderInput | SortOrder
    capacity?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _avg?: ServiceAvgOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
    _sum?: ServiceSumOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Service"> | string
    serviceCode?: StringWithAggregatesFilter<"Service"> | string
    name?: StringWithAggregatesFilter<"Service"> | string
    description?: StringNullableWithAggregatesFilter<"Service"> | string | null
    category?: StringWithAggregatesFilter<"Service"> | string
    basePrice?: FloatNullableWithAggregatesFilter<"Service"> | number | null
    pricingModel?: StringWithAggregatesFilter<"Service"> | string
    currency?: StringWithAggregatesFilter<"Service"> | string
    specifications?: JsonNullableWithAggregatesFilter<"Service">
    portfolio?: JsonNullableWithAggregatesFilter<"Service">
    leadTime?: IntNullableWithAggregatesFilter<"Service"> | number | null
    capacity?: JsonNullableWithAggregatesFilter<"Service">
    isActive?: BoolWithAggregatesFilter<"Service"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: StringFilter<"Project"> | string
    projectRef?: StringFilter<"Project"> | string
    clientId?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    service?: StringFilter<"Project"> | string
    status?: StringFilter<"Project"> | string
    currentStage?: StringFilter<"Project"> | string
    stagesCompleted?: StringNullableListFilter<"Project">
    quotedAmount?: FloatNullableFilter<"Project"> | number | null
    actualCost?: FloatNullableFilter<"Project"> | number | null
    invoicedAmount?: FloatNullableFilter<"Project"> | number | null
    paidAmount?: FloatNullableFilter<"Project"> | number | null
    startDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    targetDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    completedDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    location?: StringNullableFilter<"Project"> | string | null
    notes?: StringNullableFilter<"Project"> | string | null
    priority?: StringFilter<"Project"> | string
    orderId?: StringNullableFilter<"Project"> | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    serviceId?: StringNullableFilter<"Project"> | string | null
    client?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    documents?: DocumentListRelationFilter
    stages?: ProjectStageListRelationFilter
    costs?: MaterialCostListRelationFilter
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    Service?: XOR<ServiceNullableScalarRelationFilter, ServiceWhereInput> | null
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    projectRef?: SortOrder
    clientId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    service?: SortOrder
    status?: SortOrder
    currentStage?: SortOrder
    stagesCompleted?: SortOrder
    quotedAmount?: SortOrderInput | SortOrder
    actualCost?: SortOrderInput | SortOrder
    invoicedAmount?: SortOrderInput | SortOrder
    paidAmount?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    targetDate?: SortOrderInput | SortOrder
    completedDate?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    priority?: SortOrder
    orderId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceId?: SortOrderInput | SortOrder
    client?: CustomerOrderByWithRelationInput
    documents?: DocumentOrderByRelationAggregateInput
    stages?: ProjectStageOrderByRelationAggregateInput
    costs?: MaterialCostOrderByRelationAggregateInput
    order?: OrderOrderByWithRelationInput
    Service?: ServiceOrderByWithRelationInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectRef?: string
    orderId?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    clientId?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    service?: StringFilter<"Project"> | string
    status?: StringFilter<"Project"> | string
    currentStage?: StringFilter<"Project"> | string
    stagesCompleted?: StringNullableListFilter<"Project">
    quotedAmount?: FloatNullableFilter<"Project"> | number | null
    actualCost?: FloatNullableFilter<"Project"> | number | null
    invoicedAmount?: FloatNullableFilter<"Project"> | number | null
    paidAmount?: FloatNullableFilter<"Project"> | number | null
    startDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    targetDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    completedDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    location?: StringNullableFilter<"Project"> | string | null
    notes?: StringNullableFilter<"Project"> | string | null
    priority?: StringFilter<"Project"> | string
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    serviceId?: StringNullableFilter<"Project"> | string | null
    client?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    documents?: DocumentListRelationFilter
    stages?: ProjectStageListRelationFilter
    costs?: MaterialCostListRelationFilter
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    Service?: XOR<ServiceNullableScalarRelationFilter, ServiceWhereInput> | null
  }, "id" | "projectRef" | "orderId">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    projectRef?: SortOrder
    clientId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    service?: SortOrder
    status?: SortOrder
    currentStage?: SortOrder
    stagesCompleted?: SortOrder
    quotedAmount?: SortOrderInput | SortOrder
    actualCost?: SortOrderInput | SortOrder
    invoicedAmount?: SortOrderInput | SortOrder
    paidAmount?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    targetDate?: SortOrderInput | SortOrder
    completedDate?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    priority?: SortOrder
    orderId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceId?: SortOrderInput | SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _avg?: ProjectAvgOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
    _sum?: ProjectSumOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Project"> | string
    projectRef?: StringWithAggregatesFilter<"Project"> | string
    clientId?: StringWithAggregatesFilter<"Project"> | string
    name?: StringWithAggregatesFilter<"Project"> | string
    description?: StringNullableWithAggregatesFilter<"Project"> | string | null
    service?: StringWithAggregatesFilter<"Project"> | string
    status?: StringWithAggregatesFilter<"Project"> | string
    currentStage?: StringWithAggregatesFilter<"Project"> | string
    stagesCompleted?: StringNullableListFilter<"Project">
    quotedAmount?: FloatNullableWithAggregatesFilter<"Project"> | number | null
    actualCost?: FloatNullableWithAggregatesFilter<"Project"> | number | null
    invoicedAmount?: FloatNullableWithAggregatesFilter<"Project"> | number | null
    paidAmount?: FloatNullableWithAggregatesFilter<"Project"> | number | null
    startDate?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    targetDate?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    completedDate?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    location?: StringNullableWithAggregatesFilter<"Project"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Project"> | string | null
    priority?: StringWithAggregatesFilter<"Project"> | string
    orderId?: StringNullableWithAggregatesFilter<"Project"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    serviceId?: StringNullableWithAggregatesFilter<"Project"> | string | null
  }

  export type ProjectStageWhereInput = {
    AND?: ProjectStageWhereInput | ProjectStageWhereInput[]
    OR?: ProjectStageWhereInput[]
    NOT?: ProjectStageWhereInput | ProjectStageWhereInput[]
    id?: StringFilter<"ProjectStage"> | string
    projectId?: StringFilter<"ProjectStage"> | string
    stageName?: StringFilter<"ProjectStage"> | string
    status?: StringFilter<"ProjectStage"> | string
    notes?: StringNullableFilter<"ProjectStage"> | string | null
    completedAt?: DateTimeNullableFilter<"ProjectStage"> | Date | string | null
    order?: IntFilter<"ProjectStage"> | number
    createdAt?: DateTimeFilter<"ProjectStage"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectStage"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type ProjectStageOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    stageName?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type ProjectStageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectStageWhereInput | ProjectStageWhereInput[]
    OR?: ProjectStageWhereInput[]
    NOT?: ProjectStageWhereInput | ProjectStageWhereInput[]
    projectId?: StringFilter<"ProjectStage"> | string
    stageName?: StringFilter<"ProjectStage"> | string
    status?: StringFilter<"ProjectStage"> | string
    notes?: StringNullableFilter<"ProjectStage"> | string | null
    completedAt?: DateTimeNullableFilter<"ProjectStage"> | Date | string | null
    order?: IntFilter<"ProjectStage"> | number
    createdAt?: DateTimeFilter<"ProjectStage"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectStage"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type ProjectStageOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    stageName?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectStageCountOrderByAggregateInput
    _avg?: ProjectStageAvgOrderByAggregateInput
    _max?: ProjectStageMaxOrderByAggregateInput
    _min?: ProjectStageMinOrderByAggregateInput
    _sum?: ProjectStageSumOrderByAggregateInput
  }

  export type ProjectStageScalarWhereWithAggregatesInput = {
    AND?: ProjectStageScalarWhereWithAggregatesInput | ProjectStageScalarWhereWithAggregatesInput[]
    OR?: ProjectStageScalarWhereWithAggregatesInput[]
    NOT?: ProjectStageScalarWhereWithAggregatesInput | ProjectStageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectStage"> | string
    projectId?: StringWithAggregatesFilter<"ProjectStage"> | string
    stageName?: StringWithAggregatesFilter<"ProjectStage"> | string
    status?: StringWithAggregatesFilter<"ProjectStage"> | string
    notes?: StringNullableWithAggregatesFilter<"ProjectStage"> | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"ProjectStage"> | Date | string | null
    order?: IntWithAggregatesFilter<"ProjectStage"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ProjectStage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProjectStage"> | Date | string
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: StringFilter<"Document"> | string
    projectId?: StringFilter<"Document"> | string
    filename?: StringFilter<"Document"> | string
    originalName?: StringFilter<"Document"> | string
    fileType?: StringFilter<"Document"> | string
    fileSize?: IntNullableFilter<"Document"> | number | null
    fileUrl?: StringNullableFilter<"Document"> | string | null
    uploadedAt?: DateTimeFilter<"Document"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    generations?: DocumentGenerationListRelationFilter
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrderInput | SortOrder
    fileUrl?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    generations?: DocumentGenerationOrderByRelationAggregateInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    projectId?: StringFilter<"Document"> | string
    filename?: StringFilter<"Document"> | string
    originalName?: StringFilter<"Document"> | string
    fileType?: StringFilter<"Document"> | string
    fileSize?: IntNullableFilter<"Document"> | number | null
    fileUrl?: StringNullableFilter<"Document"> | string | null
    uploadedAt?: DateTimeFilter<"Document"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    generations?: DocumentGenerationListRelationFilter
  }, "id">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrderInput | SortOrder
    fileUrl?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _avg?: DocumentAvgOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
    _sum?: DocumentSumOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Document"> | string
    projectId?: StringWithAggregatesFilter<"Document"> | string
    filename?: StringWithAggregatesFilter<"Document"> | string
    originalName?: StringWithAggregatesFilter<"Document"> | string
    fileType?: StringWithAggregatesFilter<"Document"> | string
    fileSize?: IntNullableWithAggregatesFilter<"Document"> | number | null
    fileUrl?: StringNullableWithAggregatesFilter<"Document"> | string | null
    uploadedAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
  }

  export type DocumentGenerationWhereInput = {
    AND?: DocumentGenerationWhereInput | DocumentGenerationWhereInput[]
    OR?: DocumentGenerationWhereInput[]
    NOT?: DocumentGenerationWhereInput | DocumentGenerationWhereInput[]
    id?: StringFilter<"DocumentGeneration"> | string
    documentId?: StringFilter<"DocumentGeneration"> | string
    documentType?: StringFilter<"DocumentGeneration"> | string
    documentNumber?: StringFilter<"DocumentGeneration"> | string
    templateData?: StringFilter<"DocumentGeneration"> | string
    status?: StringFilter<"DocumentGeneration"> | string
    generatedBy?: StringNullableFilter<"DocumentGeneration"> | string | null
    generatedAt?: DateTimeNullableFilter<"DocumentGeneration"> | Date | string | null
    autoSend?: BoolFilter<"DocumentGeneration"> | boolean
    emailSent?: BoolFilter<"DocumentGeneration"> | boolean
    emailSentAt?: DateTimeNullableFilter<"DocumentGeneration"> | Date | string | null
    recipientEmail?: StringNullableFilter<"DocumentGeneration"> | string | null
    fileUrl?: StringNullableFilter<"DocumentGeneration"> | string | null
    errorMessage?: StringNullableFilter<"DocumentGeneration"> | string | null
    createdAt?: DateTimeFilter<"DocumentGeneration"> | Date | string
    updatedAt?: DateTimeFilter<"DocumentGeneration"> | Date | string
    document?: XOR<DocumentScalarRelationFilter, DocumentWhereInput>
  }

  export type DocumentGenerationOrderByWithRelationInput = {
    id?: SortOrder
    documentId?: SortOrder
    documentType?: SortOrder
    documentNumber?: SortOrder
    templateData?: SortOrder
    status?: SortOrder
    generatedBy?: SortOrderInput | SortOrder
    generatedAt?: SortOrderInput | SortOrder
    autoSend?: SortOrder
    emailSent?: SortOrder
    emailSentAt?: SortOrderInput | SortOrder
    recipientEmail?: SortOrderInput | SortOrder
    fileUrl?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    document?: DocumentOrderByWithRelationInput
  }

  export type DocumentGenerationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    documentNumber?: string
    AND?: DocumentGenerationWhereInput | DocumentGenerationWhereInput[]
    OR?: DocumentGenerationWhereInput[]
    NOT?: DocumentGenerationWhereInput | DocumentGenerationWhereInput[]
    documentId?: StringFilter<"DocumentGeneration"> | string
    documentType?: StringFilter<"DocumentGeneration"> | string
    templateData?: StringFilter<"DocumentGeneration"> | string
    status?: StringFilter<"DocumentGeneration"> | string
    generatedBy?: StringNullableFilter<"DocumentGeneration"> | string | null
    generatedAt?: DateTimeNullableFilter<"DocumentGeneration"> | Date | string | null
    autoSend?: BoolFilter<"DocumentGeneration"> | boolean
    emailSent?: BoolFilter<"DocumentGeneration"> | boolean
    emailSentAt?: DateTimeNullableFilter<"DocumentGeneration"> | Date | string | null
    recipientEmail?: StringNullableFilter<"DocumentGeneration"> | string | null
    fileUrl?: StringNullableFilter<"DocumentGeneration"> | string | null
    errorMessage?: StringNullableFilter<"DocumentGeneration"> | string | null
    createdAt?: DateTimeFilter<"DocumentGeneration"> | Date | string
    updatedAt?: DateTimeFilter<"DocumentGeneration"> | Date | string
    document?: XOR<DocumentScalarRelationFilter, DocumentWhereInput>
  }, "id" | "documentNumber">

  export type DocumentGenerationOrderByWithAggregationInput = {
    id?: SortOrder
    documentId?: SortOrder
    documentType?: SortOrder
    documentNumber?: SortOrder
    templateData?: SortOrder
    status?: SortOrder
    generatedBy?: SortOrderInput | SortOrder
    generatedAt?: SortOrderInput | SortOrder
    autoSend?: SortOrder
    emailSent?: SortOrder
    emailSentAt?: SortOrderInput | SortOrder
    recipientEmail?: SortOrderInput | SortOrder
    fileUrl?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DocumentGenerationCountOrderByAggregateInput
    _max?: DocumentGenerationMaxOrderByAggregateInput
    _min?: DocumentGenerationMinOrderByAggregateInput
  }

  export type DocumentGenerationScalarWhereWithAggregatesInput = {
    AND?: DocumentGenerationScalarWhereWithAggregatesInput | DocumentGenerationScalarWhereWithAggregatesInput[]
    OR?: DocumentGenerationScalarWhereWithAggregatesInput[]
    NOT?: DocumentGenerationScalarWhereWithAggregatesInput | DocumentGenerationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DocumentGeneration"> | string
    documentId?: StringWithAggregatesFilter<"DocumentGeneration"> | string
    documentType?: StringWithAggregatesFilter<"DocumentGeneration"> | string
    documentNumber?: StringWithAggregatesFilter<"DocumentGeneration"> | string
    templateData?: StringWithAggregatesFilter<"DocumentGeneration"> | string
    status?: StringWithAggregatesFilter<"DocumentGeneration"> | string
    generatedBy?: StringNullableWithAggregatesFilter<"DocumentGeneration"> | string | null
    generatedAt?: DateTimeNullableWithAggregatesFilter<"DocumentGeneration"> | Date | string | null
    autoSend?: BoolWithAggregatesFilter<"DocumentGeneration"> | boolean
    emailSent?: BoolWithAggregatesFilter<"DocumentGeneration"> | boolean
    emailSentAt?: DateTimeNullableWithAggregatesFilter<"DocumentGeneration"> | Date | string | null
    recipientEmail?: StringNullableWithAggregatesFilter<"DocumentGeneration"> | string | null
    fileUrl?: StringNullableWithAggregatesFilter<"DocumentGeneration"> | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"DocumentGeneration"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DocumentGeneration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DocumentGeneration"> | Date | string
  }

  export type QuoteWhereInput = {
    AND?: QuoteWhereInput | QuoteWhereInput[]
    OR?: QuoteWhereInput[]
    NOT?: QuoteWhereInput | QuoteWhereInput[]
    id?: StringFilter<"Quote"> | string
    quoteNumber?: StringFilter<"Quote"> | string
    customerId?: StringFilter<"Quote"> | string
    title?: StringFilter<"Quote"> | string
    description?: StringNullableFilter<"Quote"> | string | null
    services?: JsonFilter<"Quote">
    subtotal?: FloatFilter<"Quote"> | number
    tax?: FloatFilter<"Quote"> | number
    total?: FloatFilter<"Quote"> | number
    currency?: StringFilter<"Quote"> | string
    validUntil?: DateTimeFilter<"Quote"> | Date | string
    status?: StringFilter<"Quote"> | string
    terms?: StringNullableFilter<"Quote"> | string | null
    notes?: StringNullableFilter<"Quote"> | string | null
    convertedToProjectId?: StringNullableFilter<"Quote"> | string | null
    createdAt?: DateTimeFilter<"Quote"> | Date | string
    updatedAt?: DateTimeFilter<"Quote"> | Date | string
    serviceId?: StringNullableFilter<"Quote"> | string | null
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    Service?: XOR<ServiceNullableScalarRelationFilter, ServiceWhereInput> | null
  }

  export type QuoteOrderByWithRelationInput = {
    id?: SortOrder
    quoteNumber?: SortOrder
    customerId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    services?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    currency?: SortOrder
    validUntil?: SortOrder
    status?: SortOrder
    terms?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    convertedToProjectId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceId?: SortOrderInput | SortOrder
    customer?: CustomerOrderByWithRelationInput
    Service?: ServiceOrderByWithRelationInput
  }

  export type QuoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    quoteNumber?: string
    AND?: QuoteWhereInput | QuoteWhereInput[]
    OR?: QuoteWhereInput[]
    NOT?: QuoteWhereInput | QuoteWhereInput[]
    customerId?: StringFilter<"Quote"> | string
    title?: StringFilter<"Quote"> | string
    description?: StringNullableFilter<"Quote"> | string | null
    services?: JsonFilter<"Quote">
    subtotal?: FloatFilter<"Quote"> | number
    tax?: FloatFilter<"Quote"> | number
    total?: FloatFilter<"Quote"> | number
    currency?: StringFilter<"Quote"> | string
    validUntil?: DateTimeFilter<"Quote"> | Date | string
    status?: StringFilter<"Quote"> | string
    terms?: StringNullableFilter<"Quote"> | string | null
    notes?: StringNullableFilter<"Quote"> | string | null
    convertedToProjectId?: StringNullableFilter<"Quote"> | string | null
    createdAt?: DateTimeFilter<"Quote"> | Date | string
    updatedAt?: DateTimeFilter<"Quote"> | Date | string
    serviceId?: StringNullableFilter<"Quote"> | string | null
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    Service?: XOR<ServiceNullableScalarRelationFilter, ServiceWhereInput> | null
  }, "id" | "quoteNumber">

  export type QuoteOrderByWithAggregationInput = {
    id?: SortOrder
    quoteNumber?: SortOrder
    customerId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    services?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    currency?: SortOrder
    validUntil?: SortOrder
    status?: SortOrder
    terms?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    convertedToProjectId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceId?: SortOrderInput | SortOrder
    _count?: QuoteCountOrderByAggregateInput
    _avg?: QuoteAvgOrderByAggregateInput
    _max?: QuoteMaxOrderByAggregateInput
    _min?: QuoteMinOrderByAggregateInput
    _sum?: QuoteSumOrderByAggregateInput
  }

  export type QuoteScalarWhereWithAggregatesInput = {
    AND?: QuoteScalarWhereWithAggregatesInput | QuoteScalarWhereWithAggregatesInput[]
    OR?: QuoteScalarWhereWithAggregatesInput[]
    NOT?: QuoteScalarWhereWithAggregatesInput | QuoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Quote"> | string
    quoteNumber?: StringWithAggregatesFilter<"Quote"> | string
    customerId?: StringWithAggregatesFilter<"Quote"> | string
    title?: StringWithAggregatesFilter<"Quote"> | string
    description?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    services?: JsonWithAggregatesFilter<"Quote">
    subtotal?: FloatWithAggregatesFilter<"Quote"> | number
    tax?: FloatWithAggregatesFilter<"Quote"> | number
    total?: FloatWithAggregatesFilter<"Quote"> | number
    currency?: StringWithAggregatesFilter<"Quote"> | string
    validUntil?: DateTimeWithAggregatesFilter<"Quote"> | Date | string
    status?: StringWithAggregatesFilter<"Quote"> | string
    terms?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    convertedToProjectId?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Quote"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Quote"> | Date | string
    serviceId?: StringNullableWithAggregatesFilter<"Quote"> | string | null
  }

  export type MaterialCostWhereInput = {
    AND?: MaterialCostWhereInput | MaterialCostWhereInput[]
    OR?: MaterialCostWhereInput[]
    NOT?: MaterialCostWhereInput | MaterialCostWhereInput[]
    id?: StringFilter<"MaterialCost"> | string
    projectId?: StringNullableFilter<"MaterialCost"> | string | null
    supplier?: StringFilter<"MaterialCost"> | string
    material?: StringFilter<"MaterialCost"> | string
    quantity?: FloatFilter<"MaterialCost"> | number
    unitCost?: FloatFilter<"MaterialCost"> | number
    totalCost?: FloatFilter<"MaterialCost"> | number
    invoiceRef?: StringNullableFilter<"MaterialCost"> | string | null
    date?: DateTimeFilter<"MaterialCost"> | Date | string
    category?: StringNullableFilter<"MaterialCost"> | string | null
    createdAt?: DateTimeFilter<"MaterialCost"> | Date | string
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
  }

  export type MaterialCostOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrderInput | SortOrder
    supplier?: SortOrder
    material?: SortOrder
    quantity?: SortOrder
    unitCost?: SortOrder
    totalCost?: SortOrder
    invoiceRef?: SortOrderInput | SortOrder
    date?: SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type MaterialCostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MaterialCostWhereInput | MaterialCostWhereInput[]
    OR?: MaterialCostWhereInput[]
    NOT?: MaterialCostWhereInput | MaterialCostWhereInput[]
    projectId?: StringNullableFilter<"MaterialCost"> | string | null
    supplier?: StringFilter<"MaterialCost"> | string
    material?: StringFilter<"MaterialCost"> | string
    quantity?: FloatFilter<"MaterialCost"> | number
    unitCost?: FloatFilter<"MaterialCost"> | number
    totalCost?: FloatFilter<"MaterialCost"> | number
    invoiceRef?: StringNullableFilter<"MaterialCost"> | string | null
    date?: DateTimeFilter<"MaterialCost"> | Date | string
    category?: StringNullableFilter<"MaterialCost"> | string | null
    createdAt?: DateTimeFilter<"MaterialCost"> | Date | string
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
  }, "id">

  export type MaterialCostOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrderInput | SortOrder
    supplier?: SortOrder
    material?: SortOrder
    quantity?: SortOrder
    unitCost?: SortOrder
    totalCost?: SortOrder
    invoiceRef?: SortOrderInput | SortOrder
    date?: SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MaterialCostCountOrderByAggregateInput
    _avg?: MaterialCostAvgOrderByAggregateInput
    _max?: MaterialCostMaxOrderByAggregateInput
    _min?: MaterialCostMinOrderByAggregateInput
    _sum?: MaterialCostSumOrderByAggregateInput
  }

  export type MaterialCostScalarWhereWithAggregatesInput = {
    AND?: MaterialCostScalarWhereWithAggregatesInput | MaterialCostScalarWhereWithAggregatesInput[]
    OR?: MaterialCostScalarWhereWithAggregatesInput[]
    NOT?: MaterialCostScalarWhereWithAggregatesInput | MaterialCostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MaterialCost"> | string
    projectId?: StringNullableWithAggregatesFilter<"MaterialCost"> | string | null
    supplier?: StringWithAggregatesFilter<"MaterialCost"> | string
    material?: StringWithAggregatesFilter<"MaterialCost"> | string
    quantity?: FloatWithAggregatesFilter<"MaterialCost"> | number
    unitCost?: FloatWithAggregatesFilter<"MaterialCost"> | number
    totalCost?: FloatWithAggregatesFilter<"MaterialCost"> | number
    invoiceRef?: StringNullableWithAggregatesFilter<"MaterialCost"> | string | null
    date?: DateTimeWithAggregatesFilter<"MaterialCost"> | Date | string
    category?: StringNullableWithAggregatesFilter<"MaterialCost"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MaterialCost"> | Date | string
  }

  export type SupplierInvoiceWhereInput = {
    AND?: SupplierInvoiceWhereInput | SupplierInvoiceWhereInput[]
    OR?: SupplierInvoiceWhereInput[]
    NOT?: SupplierInvoiceWhereInput | SupplierInvoiceWhereInput[]
    id?: StringFilter<"SupplierInvoice"> | string
    supplier?: StringFilter<"SupplierInvoice"> | string
    invoiceRef?: StringFilter<"SupplierInvoice"> | string
    date?: DateTimeFilter<"SupplierInvoice"> | Date | string
    totalAmount?: FloatFilter<"SupplierInvoice"> | number
    items?: JsonFilter<"SupplierInvoice">
    fileUrl?: StringNullableFilter<"SupplierInvoice"> | string | null
    processed?: BoolFilter<"SupplierInvoice"> | boolean
    createdAt?: DateTimeFilter<"SupplierInvoice"> | Date | string
  }

  export type SupplierInvoiceOrderByWithRelationInput = {
    id?: SortOrder
    supplier?: SortOrder
    invoiceRef?: SortOrder
    date?: SortOrder
    totalAmount?: SortOrder
    items?: SortOrder
    fileUrl?: SortOrderInput | SortOrder
    processed?: SortOrder
    createdAt?: SortOrder
  }

  export type SupplierInvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SupplierInvoiceWhereInput | SupplierInvoiceWhereInput[]
    OR?: SupplierInvoiceWhereInput[]
    NOT?: SupplierInvoiceWhereInput | SupplierInvoiceWhereInput[]
    supplier?: StringFilter<"SupplierInvoice"> | string
    invoiceRef?: StringFilter<"SupplierInvoice"> | string
    date?: DateTimeFilter<"SupplierInvoice"> | Date | string
    totalAmount?: FloatFilter<"SupplierInvoice"> | number
    items?: JsonFilter<"SupplierInvoice">
    fileUrl?: StringNullableFilter<"SupplierInvoice"> | string | null
    processed?: BoolFilter<"SupplierInvoice"> | boolean
    createdAt?: DateTimeFilter<"SupplierInvoice"> | Date | string
  }, "id">

  export type SupplierInvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    supplier?: SortOrder
    invoiceRef?: SortOrder
    date?: SortOrder
    totalAmount?: SortOrder
    items?: SortOrder
    fileUrl?: SortOrderInput | SortOrder
    processed?: SortOrder
    createdAt?: SortOrder
    _count?: SupplierInvoiceCountOrderByAggregateInput
    _avg?: SupplierInvoiceAvgOrderByAggregateInput
    _max?: SupplierInvoiceMaxOrderByAggregateInput
    _min?: SupplierInvoiceMinOrderByAggregateInput
    _sum?: SupplierInvoiceSumOrderByAggregateInput
  }

  export type SupplierInvoiceScalarWhereWithAggregatesInput = {
    AND?: SupplierInvoiceScalarWhereWithAggregatesInput | SupplierInvoiceScalarWhereWithAggregatesInput[]
    OR?: SupplierInvoiceScalarWhereWithAggregatesInput[]
    NOT?: SupplierInvoiceScalarWhereWithAggregatesInput | SupplierInvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SupplierInvoice"> | string
    supplier?: StringWithAggregatesFilter<"SupplierInvoice"> | string
    invoiceRef?: StringWithAggregatesFilter<"SupplierInvoice"> | string
    date?: DateTimeWithAggregatesFilter<"SupplierInvoice"> | Date | string
    totalAmount?: FloatWithAggregatesFilter<"SupplierInvoice"> | number
    items?: JsonWithAggregatesFilter<"SupplierInvoice">
    fileUrl?: StringNullableWithAggregatesFilter<"SupplierInvoice"> | string | null
    processed?: BoolWithAggregatesFilter<"SupplierInvoice"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SupplierInvoice"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email?: string | null
    name?: string | null
    password?: string | null
    role?: string
    externalId?: string | null
    mondayUserId?: string | null
    copilotUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: ChatSessionCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutUserInput
    customer?: CustomerCreateNestedOneWithoutUserInput
    cart?: CartCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email?: string | null
    name?: string | null
    password?: string | null
    role?: string
    externalId?: string | null
    mondayUserId?: string | null
    copilotUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: ChatSessionUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    customer?: CustomerUncheckedCreateNestedOneWithoutUserInput
    cart?: CartUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    mondayUserId?: NullableStringFieldUpdateOperationsInput | string | null
    copilotUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: ChatSessionUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    customer?: CustomerUpdateOneWithoutUserNestedInput
    cart?: CartUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    mondayUserId?: NullableStringFieldUpdateOperationsInput | string | null
    copilotUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: ChatSessionUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    customer?: CustomerUncheckedUpdateOneWithoutUserNestedInput
    cart?: CartUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email?: string | null
    name?: string | null
    password?: string | null
    role?: string
    externalId?: string | null
    mondayUserId?: string | null
    copilotUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    mondayUserId?: NullableStringFieldUpdateOperationsInput | string | null
    copilotUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    mondayUserId?: NullableStringFieldUpdateOperationsInput | string | null
    copilotUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatSessionCreateInput = {
    id: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    systemPrompt?: string | null
    isActive?: boolean
    userName?: string | null
    userEmail?: string | null
    ipAddress?: string | null
    location?: string | null
    source?: string | null
    category?: string | null
    mondayItemId?: string | null
    mondaySynced?: boolean
    copilotSynced?: boolean
    databaseSynced?: boolean
    lastMondaySync?: Date | string | null
    lastCopilotSync?: Date | string | null
    user?: UserCreateNestedOneWithoutSessionsInput
    messages?: MessageCreateNestedManyWithoutSessionInput
    tags?: SessionTagCreateNestedManyWithoutSessionInput
  }

  export type ChatSessionUncheckedCreateInput = {
    id: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    systemPrompt?: string | null
    isActive?: boolean
    userId?: string | null
    userName?: string | null
    userEmail?: string | null
    ipAddress?: string | null
    location?: string | null
    source?: string | null
    category?: string | null
    mondayItemId?: string | null
    mondaySynced?: boolean
    copilotSynced?: boolean
    databaseSynced?: boolean
    lastMondaySync?: Date | string | null
    lastCopilotSync?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutSessionInput
    tags?: SessionTagUncheckedCreateNestedManyWithoutSessionInput
  }

  export type ChatSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    systemPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    mondayItemId?: NullableStringFieldUpdateOperationsInput | string | null
    mondaySynced?: BoolFieldUpdateOperationsInput | boolean
    copilotSynced?: BoolFieldUpdateOperationsInput | boolean
    databaseSynced?: BoolFieldUpdateOperationsInput | boolean
    lastMondaySync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastCopilotSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutSessionsNestedInput
    messages?: MessageUpdateManyWithoutSessionNestedInput
    tags?: SessionTagUpdateManyWithoutSessionNestedInput
  }

  export type ChatSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    systemPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    mondayItemId?: NullableStringFieldUpdateOperationsInput | string | null
    mondaySynced?: BoolFieldUpdateOperationsInput | boolean
    copilotSynced?: BoolFieldUpdateOperationsInput | boolean
    databaseSynced?: BoolFieldUpdateOperationsInput | boolean
    lastMondaySync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastCopilotSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutSessionNestedInput
    tags?: SessionTagUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type ChatSessionCreateManyInput = {
    id: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    systemPrompt?: string | null
    isActive?: boolean
    userId?: string | null
    userName?: string | null
    userEmail?: string | null
    ipAddress?: string | null
    location?: string | null
    source?: string | null
    category?: string | null
    mondayItemId?: string | null
    mondaySynced?: boolean
    copilotSynced?: boolean
    databaseSynced?: boolean
    lastMondaySync?: Date | string | null
    lastCopilotSync?: Date | string | null
  }

  export type ChatSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    systemPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    mondayItemId?: NullableStringFieldUpdateOperationsInput | string | null
    mondaySynced?: BoolFieldUpdateOperationsInput | boolean
    copilotSynced?: BoolFieldUpdateOperationsInput | boolean
    databaseSynced?: BoolFieldUpdateOperationsInput | boolean
    lastMondaySync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastCopilotSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChatSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    systemPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    mondayItemId?: NullableStringFieldUpdateOperationsInput | string | null
    mondaySynced?: BoolFieldUpdateOperationsInput | boolean
    copilotSynced?: BoolFieldUpdateOperationsInput | boolean
    databaseSynced?: BoolFieldUpdateOperationsInput | boolean
    lastMondaySync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastCopilotSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageCreateInput = {
    id: string
    role: string
    content: string
    timestamp?: Date | string
    isError?: boolean | null
    functionName?: string | null
    functionArgs?: string | null
    session: ChatSessionCreateNestedOneWithoutMessagesInput
    user?: UserCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id: string
    sessionId: string
    role: string
    content: string
    timestamp?: Date | string
    isError?: boolean | null
    userId?: string | null
    functionName?: string | null
    functionArgs?: string | null
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isError?: NullableBoolFieldUpdateOperationsInput | boolean | null
    functionName?: NullableStringFieldUpdateOperationsInput | string | null
    functionArgs?: NullableStringFieldUpdateOperationsInput | string | null
    session?: ChatSessionUpdateOneRequiredWithoutMessagesNestedInput
    user?: UserUpdateOneWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isError?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    functionName?: NullableStringFieldUpdateOperationsInput | string | null
    functionArgs?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageCreateManyInput = {
    id: string
    sessionId: string
    role: string
    content: string
    timestamp?: Date | string
    isError?: boolean | null
    userId?: string | null
    functionName?: string | null
    functionArgs?: string | null
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isError?: NullableBoolFieldUpdateOperationsInput | boolean | null
    functionName?: NullableStringFieldUpdateOperationsInput | string | null
    functionArgs?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isError?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    functionName?: NullableStringFieldUpdateOperationsInput | string | null
    functionArgs?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionTagCreateInput = {
    id?: string
    name: string
    session: ChatSessionCreateNestedOneWithoutTagsInput
  }

  export type SessionTagUncheckedCreateInput = {
    id?: string
    name: string
    sessionId: string
  }

  export type SessionTagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    session?: ChatSessionUpdateOneRequiredWithoutTagsNestedInput
  }

  export type SessionTagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
  }

  export type SessionTagCreateManyInput = {
    id?: string
    name: string
    sessionId: string
  }

  export type SessionTagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SessionTagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
  }

  export type MondaySyncCreateInput = {
    id?: string
    sessionId: string
    itemId: string
    boardId: string
    lastSynced?: Date | string
  }

  export type MondaySyncUncheckedCreateInput = {
    id?: string
    sessionId: string
    itemId: string
    boardId: string
    lastSynced?: Date | string
  }

  export type MondaySyncUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    boardId?: StringFieldUpdateOperationsInput | string
    lastSynced?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MondaySyncUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    boardId?: StringFieldUpdateOperationsInput | string
    lastSynced?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MondaySyncCreateManyInput = {
    id?: string
    sessionId: string
    itemId: string
    boardId: string
    lastSynced?: Date | string
  }

  export type MondaySyncUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    boardId?: StringFieldUpdateOperationsInput | string
    lastSynced?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MondaySyncUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    boardId?: StringFieldUpdateOperationsInput | string
    lastSynced?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateInput = {
    id?: string
    companyName?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    taxId?: string | null
    phoneNumber?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCustomerInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceCreateNestedManyWithoutCustomerInput
    projects?: ProjectCreateNestedManyWithoutClientInput
    quotes?: QuoteCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    userId: string
    companyName?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    taxId?: string | null
    phoneNumber?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCustomerNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutCustomerNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUpdateManyWithoutCustomerNestedInput
    projects?: ProjectUpdateManyWithoutClientNestedInput
    quotes?: QuoteUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutCustomerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: string
    userId: string
    companyName?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    taxId?: string | null
    phoneNumber?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    category: string
    basePrice: number
    currency?: string
    specifications?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    priceHistory?: PriceHistoryCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    category: string
    basePrice: number
    currency?: string
    specifications?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    priceHistory?: PriceHistoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    specifications?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    priceHistory?: PriceHistoryUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    specifications?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    priceHistory?: PriceHistoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    category: string
    basePrice: number
    currency?: string
    specifications?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    specifications?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    specifications?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    id?: string
    orderNumber: string
    status?: string
    subtotal: number
    tax: number
    shipping: number
    total: number
    currency?: string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingMethod?: string | null
    trackingNumber?: string | null
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    paymentStatus?: string
    paymentIntentId?: string | null
    paidAt?: Date | string | null
    customerNotes?: string | null
    internalNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    invoice?: InvoiceCreateNestedOneWithoutOrderInput
    project?: ProjectCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    orderNumber: string
    customerId: string
    status?: string
    subtotal: number
    tax: number
    shipping: number
    total: number
    currency?: string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingMethod?: string | null
    trackingNumber?: string | null
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    paymentStatus?: string
    paymentIntentId?: string | null
    paidAt?: Date | string | null
    customerNotes?: string | null
    internalNotes?: string | null
    invoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    project?: ProjectUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    shipping?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    invoice?: InvoiceUpdateOneWithoutOrderNestedInput
    project?: ProjectUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    shipping?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    project?: ProjectUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: string
    orderNumber: string
    customerId: string
    status?: string
    subtotal: number
    tax: number
    shipping: number
    total: number
    currency?: string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingMethod?: string | null
    trackingNumber?: string | null
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    paymentStatus?: string
    paymentIntentId?: string | null
    paidAt?: Date | string | null
    customerNotes?: string | null
    internalNotes?: string | null
    invoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    shipping?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    shipping?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateInput = {
    id?: string
    quantity: number
    unitPrice: number
    totalPrice: number
    productSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    order: OrderCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateInput = {
    id?: string
    orderId: string
    productId: string
    quantity: number
    unitPrice: number
    totalPrice: number
    productSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type OrderItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    productSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    productSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateManyInput = {
    id?: string
    orderId: string
    productId: string
    quantity: number
    unitPrice: number
    totalPrice: number
    productSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type OrderItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    productSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    productSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateInput = {
    id?: string
    status?: string
    billingCycle?: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    nextBillingDate: Date | string
    stripeSubscriptionId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutSubscriptionsInput
    plan: SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput
    invoices?: InvoiceCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    customerId: string
    status?: string
    planId: string
    billingCycle?: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    nextBillingDate: Date | string
    stripeSubscriptionId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    billingCycle?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutSubscriptionsNestedInput
    plan?: SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    invoices?: InvoiceUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    billingCycle?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    customerId: string
    status?: string
    planId: string
    billingCycle?: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    nextBillingDate: Date | string
    stripeSubscriptionId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    billingCycle?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    billingCycle?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionPlanCreateInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    currency?: string
    interval?: string
    features?: NullableJsonNullValueInput | InputJsonValue
    limits?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: SubscriptionCreateNestedManyWithoutPlanInput
  }

  export type SubscriptionPlanUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    currency?: string
    interval?: string
    features?: NullableJsonNullValueInput | InputJsonValue
    limits?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type SubscriptionPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    features?: NullableJsonNullValueInput | InputJsonValue
    limits?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: SubscriptionUpdateManyWithoutPlanNestedInput
  }

  export type SubscriptionPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    features?: NullableJsonNullValueInput | InputJsonValue
    limits?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type SubscriptionPlanCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    currency?: string
    interval?: string
    features?: NullableJsonNullValueInput | InputJsonValue
    limits?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    features?: NullableJsonNullValueInput | InputJsonValue
    limits?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    features?: NullableJsonNullValueInput | InputJsonValue
    limits?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    id?: string
    invoiceNumber: string
    type: string
    subtotal: number
    tax: number
    total: number
    currency?: string
    status?: string
    dueDate: Date | string
    paidAt?: Date | string | null
    paymentIntentId?: string | null
    paymentMethod?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutInvoicesInput
    order?: OrderCreateNestedOneWithoutInvoiceInput
    subscription?: SubscriptionCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    invoiceNumber: string
    customerId: string
    type: string
    subscriptionId?: string | null
    subtotal: number
    tax: number
    total: number
    currency?: string
    status?: string
    dueDate: Date | string
    paidAt?: Date | string | null
    paymentIntentId?: string | null
    paymentMethod?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: OrderUncheckedCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutInvoicesNestedInput
    order?: OrderUpdateOneWithoutInvoiceNestedInput
    subscription?: SubscriptionUpdateOneWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUncheckedUpdateOneWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: string
    invoiceNumber: string
    customerId: string
    type: string
    subscriptionId?: string | null
    subtotal: number
    tax: number
    total: number
    currency?: string
    status?: string
    dueDate: Date | string
    paidAt?: Date | string | null
    paymentIntentId?: string | null
    paymentMethod?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodCreateInput = {
    id?: string
    stripePaymentMethodId: string
    type: string
    last4: string
    brand?: string | null
    expiryMonth?: number | null
    expiryYear?: number | null
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutPaymentMethodsInput
  }

  export type PaymentMethodUncheckedCreateInput = {
    id?: string
    customerId: string
    stripePaymentMethodId: string
    type: string
    last4: string
    brand?: string | null
    expiryMonth?: number | null
    expiryYear?: number | null
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentMethodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentMethodId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    last4?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    expiryMonth?: NullableIntFieldUpdateOperationsInput | number | null
    expiryYear?: NullableIntFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutPaymentMethodsNestedInput
  }

  export type PaymentMethodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    stripePaymentMethodId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    last4?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    expiryMonth?: NullableIntFieldUpdateOperationsInput | number | null
    expiryYear?: NullableIntFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodCreateManyInput = {
    id?: string
    customerId: string
    stripePaymentMethodId: string
    type: string
    last4: string
    brand?: string | null
    expiryMonth?: number | null
    expiryYear?: number | null
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentMethodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentMethodId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    last4?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    expiryMonth?: NullableIntFieldUpdateOperationsInput | number | null
    expiryYear?: NullableIntFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    stripePaymentMethodId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    last4?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    expiryMonth?: NullableIntFieldUpdateOperationsInput | number | null
    expiryYear?: NullableIntFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryCreateInput = {
    id?: string
    location: string
    quantity?: number
    reservedQuantity?: number
    availableQuantity?: number
    reorderPoint?: number
    reorderQuantity?: number
    batchNumber?: string | null
    serialNumbers?: NullableJsonNullValueInput | InputJsonValue
    lastRestocked?: Date | string | null
    lastCounted?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutInventoryItemsInput
  }

  export type InventoryUncheckedCreateInput = {
    id?: string
    productId: string
    location: string
    quantity?: number
    reservedQuantity?: number
    availableQuantity?: number
    reorderPoint?: number
    reorderQuantity?: number
    batchNumber?: string | null
    serialNumbers?: NullableJsonNullValueInput | InputJsonValue
    lastRestocked?: Date | string | null
    lastCounted?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    availableQuantity?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    reorderQuantity?: IntFieldUpdateOperationsInput | number
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumbers?: NullableJsonNullValueInput | InputJsonValue
    lastRestocked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastCounted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutInventoryItemsNestedInput
  }

  export type InventoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    availableQuantity?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    reorderQuantity?: IntFieldUpdateOperationsInput | number
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumbers?: NullableJsonNullValueInput | InputJsonValue
    lastRestocked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastCounted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryCreateManyInput = {
    id?: string
    productId: string
    location: string
    quantity?: number
    reservedQuantity?: number
    availableQuantity?: number
    reorderPoint?: number
    reorderQuantity?: number
    batchNumber?: string | null
    serialNumbers?: NullableJsonNullValueInput | InputJsonValue
    lastRestocked?: Date | string | null
    lastCounted?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    availableQuantity?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    reorderQuantity?: IntFieldUpdateOperationsInput | number
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumbers?: NullableJsonNullValueInput | InputJsonValue
    lastRestocked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastCounted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    availableQuantity?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    reorderQuantity?: IntFieldUpdateOperationsInput | number
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumbers?: NullableJsonNullValueInput | InputJsonValue
    lastRestocked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastCounted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartCreateInput = {
    id?: string
    sessionId?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutCartInput
    items?: CartItemCreateNestedManyWithoutCartInput
  }

  export type CartUncheckedCreateInput = {
    id?: string
    sessionId?: string | null
    userId?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: CartItemUncheckedCreateNestedManyWithoutCartInput
  }

  export type CartUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutCartNestedInput
    items?: CartItemUpdateManyWithoutCartNestedInput
  }

  export type CartUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: CartItemUncheckedUpdateManyWithoutCartNestedInput
  }

  export type CartCreateManyInput = {
    id?: string
    sessionId?: string | null
    userId?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemCreateInput = {
    id?: string
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cart: CartCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutCartItemsInput
  }

  export type CartItemUncheckedCreateInput = {
    id?: string
    cartId: string
    productId: string
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cart?: CartUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutCartItemsNestedInput
  }

  export type CartItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemCreateManyInput = {
    id?: string
    cartId: string
    productId: string
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceHistoryCreateInput = {
    id?: string
    price: number
    previousPrice?: number | null
    currency?: string
    reason?: string | null
    effectiveFrom: Date | string
    effectiveUntil?: Date | string | null
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutPriceHistoryInput
  }

  export type PriceHistoryUncheckedCreateInput = {
    id?: string
    productId: string
    price: number
    previousPrice?: number | null
    currency?: string
    reason?: string | null
    effectiveFrom: Date | string
    effectiveUntil?: Date | string | null
    createdAt?: Date | string
  }

  export type PriceHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    previousPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutPriceHistoryNestedInput
  }

  export type PriceHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    previousPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceHistoryCreateManyInput = {
    id?: string
    productId: string
    price: number
    previousPrice?: number | null
    currency?: string
    reason?: string | null
    effectiveFrom: Date | string
    effectiveUntil?: Date | string | null
    createdAt?: Date | string
  }

  export type PriceHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    previousPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    previousPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemHealthCreateInput = {
    id?: string
    service: string
    status: string
    responseTime?: number | null
    errorRate?: number | null
    uptime?: number | null
    message?: string | null
    lastCheck?: Date | string
    nextCheck?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemHealthUncheckedCreateInput = {
    id?: string
    service: string
    status: string
    responseTime?: number | null
    errorRate?: number | null
    uptime?: number | null
    message?: string | null
    lastCheck?: Date | string
    nextCheck?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemHealthUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    responseTime?: NullableFloatFieldUpdateOperationsInput | number | null
    errorRate?: NullableFloatFieldUpdateOperationsInput | number | null
    uptime?: NullableFloatFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    lastCheck?: DateTimeFieldUpdateOperationsInput | Date | string
    nextCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemHealthUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    responseTime?: NullableFloatFieldUpdateOperationsInput | number | null
    errorRate?: NullableFloatFieldUpdateOperationsInput | number | null
    uptime?: NullableFloatFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    lastCheck?: DateTimeFieldUpdateOperationsInput | Date | string
    nextCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemHealthCreateManyInput = {
    id?: string
    service: string
    status: string
    responseTime?: number | null
    errorRate?: number | null
    uptime?: number | null
    message?: string | null
    lastCheck?: Date | string
    nextCheck?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemHealthUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    responseTime?: NullableFloatFieldUpdateOperationsInput | number | null
    errorRate?: NullableFloatFieldUpdateOperationsInput | number | null
    uptime?: NullableFloatFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    lastCheck?: DateTimeFieldUpdateOperationsInput | Date | string
    nextCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemHealthUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    responseTime?: NullableFloatFieldUpdateOperationsInput | number | null
    errorRate?: NullableFloatFieldUpdateOperationsInput | number | null
    uptime?: NullableFloatFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    lastCheck?: DateTimeFieldUpdateOperationsInput | Date | string
    nextCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    userId?: string | null
    type: string
    title: string
    message: string
    priority?: string
    channel?: string
    read?: boolean
    readAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId?: string | null
    type: string
    title: string
    message: string
    priority?: string
    channel?: string
    read?: boolean
    readAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId?: string | null
    type: string
    title: string
    message: string
    priority?: string
    channel?: string
    read?: boolean
    readAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsEventCreateInput = {
    id?: string
    sessionId: string
    userId?: string | null
    eventName: string
    eventCategory: string
    eventData: JsonNullValueInput | InputJsonValue
    dataPoints: JsonNullValueInput | InputJsonValue
    context: JsonNullValueInput | InputJsonValue
    timestamp: Date | string
    createdAt?: Date | string
  }

  export type AnalyticsEventUncheckedCreateInput = {
    id?: string
    sessionId: string
    userId?: string | null
    eventName: string
    eventCategory: string
    eventData: JsonNullValueInput | InputJsonValue
    dataPoints: JsonNullValueInput | InputJsonValue
    context: JsonNullValueInput | InputJsonValue
    timestamp: Date | string
    createdAt?: Date | string
  }

  export type AnalyticsEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: StringFieldUpdateOperationsInput | string
    eventCategory?: StringFieldUpdateOperationsInput | string
    eventData?: JsonNullValueInput | InputJsonValue
    dataPoints?: JsonNullValueInput | InputJsonValue
    context?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: StringFieldUpdateOperationsInput | string
    eventCategory?: StringFieldUpdateOperationsInput | string
    eventData?: JsonNullValueInput | InputJsonValue
    dataPoints?: JsonNullValueInput | InputJsonValue
    context?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsEventCreateManyInput = {
    id?: string
    sessionId: string
    userId?: string | null
    eventName: string
    eventCategory: string
    eventData: JsonNullValueInput | InputJsonValue
    dataPoints: JsonNullValueInput | InputJsonValue
    context: JsonNullValueInput | InputJsonValue
    timestamp: Date | string
    createdAt?: Date | string
  }

  export type AnalyticsEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: StringFieldUpdateOperationsInput | string
    eventCategory?: StringFieldUpdateOperationsInput | string
    eventData?: JsonNullValueInput | InputJsonValue
    dataPoints?: JsonNullValueInput | InputJsonValue
    context?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: StringFieldUpdateOperationsInput | string
    eventCategory?: StringFieldUpdateOperationsInput | string
    eventData?: JsonNullValueInput | InputJsonValue
    dataPoints?: JsonNullValueInput | InputJsonValue
    context?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsSessionCreateInput = {
    id?: string
    userId?: string | null
    visitorId?: string | null
    startTime: Date | string
    endTime?: Date | string | null
    duration?: number | null
    pageViews?: number
    events?: number
    bounced?: boolean
    source?: string | null
    medium?: string | null
    campaign?: string | null
    content?: string | null
    term?: string | null
    deviceType?: string | null
    deviceBrand?: string | null
    browser?: string | null
    os?: string | null
    screenResolution?: string | null
    country?: string | null
    region?: string | null
    city?: string | null
    engagementScore?: number | null
    conversionValue?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalyticsSessionUncheckedCreateInput = {
    id?: string
    userId?: string | null
    visitorId?: string | null
    startTime: Date | string
    endTime?: Date | string | null
    duration?: number | null
    pageViews?: number
    events?: number
    bounced?: boolean
    source?: string | null
    medium?: string | null
    campaign?: string | null
    content?: string | null
    term?: string | null
    deviceType?: string | null
    deviceBrand?: string | null
    browser?: string | null
    os?: string | null
    screenResolution?: string | null
    country?: string | null
    region?: string | null
    city?: string | null
    engagementScore?: number | null
    conversionValue?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalyticsSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    visitorId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    pageViews?: IntFieldUpdateOperationsInput | number
    events?: IntFieldUpdateOperationsInput | number
    bounced?: BoolFieldUpdateOperationsInput | boolean
    source?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    deviceBrand?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    screenResolution?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    engagementScore?: NullableFloatFieldUpdateOperationsInput | number | null
    conversionValue?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    visitorId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    pageViews?: IntFieldUpdateOperationsInput | number
    events?: IntFieldUpdateOperationsInput | number
    bounced?: BoolFieldUpdateOperationsInput | boolean
    source?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    deviceBrand?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    screenResolution?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    engagementScore?: NullableFloatFieldUpdateOperationsInput | number | null
    conversionValue?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsSessionCreateManyInput = {
    id?: string
    userId?: string | null
    visitorId?: string | null
    startTime: Date | string
    endTime?: Date | string | null
    duration?: number | null
    pageViews?: number
    events?: number
    bounced?: boolean
    source?: string | null
    medium?: string | null
    campaign?: string | null
    content?: string | null
    term?: string | null
    deviceType?: string | null
    deviceBrand?: string | null
    browser?: string | null
    os?: string | null
    screenResolution?: string | null
    country?: string | null
    region?: string | null
    city?: string | null
    engagementScore?: number | null
    conversionValue?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalyticsSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    visitorId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    pageViews?: IntFieldUpdateOperationsInput | number
    events?: IntFieldUpdateOperationsInput | number
    bounced?: BoolFieldUpdateOperationsInput | boolean
    source?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    deviceBrand?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    screenResolution?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    engagementScore?: NullableFloatFieldUpdateOperationsInput | number | null
    conversionValue?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    visitorId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    pageViews?: IntFieldUpdateOperationsInput | number
    events?: IntFieldUpdateOperationsInput | number
    bounced?: BoolFieldUpdateOperationsInput | boolean
    source?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    deviceBrand?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    screenResolution?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    engagementScore?: NullableFloatFieldUpdateOperationsInput | number | null
    conversionValue?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsMetricCreateInput = {
    id?: string
    name: string
    type: string
    category: string
    calculation: JsonNullValueInput | InputJsonValue
    dailyValues?: NullableJsonNullValueInput | InputJsonValue
    weeklyValues?: NullableJsonNullValueInput | InputJsonValue
    monthlyValues?: NullableJsonNullValueInput | InputJsonValue
    lastCalculated?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalyticsMetricUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    category: string
    calculation: JsonNullValueInput | InputJsonValue
    dailyValues?: NullableJsonNullValueInput | InputJsonValue
    weeklyValues?: NullableJsonNullValueInput | InputJsonValue
    monthlyValues?: NullableJsonNullValueInput | InputJsonValue
    lastCalculated?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalyticsMetricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    calculation?: JsonNullValueInput | InputJsonValue
    dailyValues?: NullableJsonNullValueInput | InputJsonValue
    weeklyValues?: NullableJsonNullValueInput | InputJsonValue
    monthlyValues?: NullableJsonNullValueInput | InputJsonValue
    lastCalculated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsMetricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    calculation?: JsonNullValueInput | InputJsonValue
    dailyValues?: NullableJsonNullValueInput | InputJsonValue
    weeklyValues?: NullableJsonNullValueInput | InputJsonValue
    monthlyValues?: NullableJsonNullValueInput | InputJsonValue
    lastCalculated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsMetricCreateManyInput = {
    id?: string
    name: string
    type: string
    category: string
    calculation: JsonNullValueInput | InputJsonValue
    dailyValues?: NullableJsonNullValueInput | InputJsonValue
    weeklyValues?: NullableJsonNullValueInput | InputJsonValue
    monthlyValues?: NullableJsonNullValueInput | InputJsonValue
    lastCalculated?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalyticsMetricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    calculation?: JsonNullValueInput | InputJsonValue
    dailyValues?: NullableJsonNullValueInput | InputJsonValue
    weeklyValues?: NullableJsonNullValueInput | InputJsonValue
    monthlyValues?: NullableJsonNullValueInput | InputJsonValue
    lastCalculated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsMetricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    calculation?: JsonNullValueInput | InputJsonValue
    dailyValues?: NullableJsonNullValueInput | InputJsonValue
    weeklyValues?: NullableJsonNullValueInput | InputJsonValue
    monthlyValues?: NullableJsonNullValueInput | InputJsonValue
    lastCalculated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsCohortCreateInput = {
    id?: string
    name: string
    definition: JsonNullValueInput | InputJsonValue
    userCount?: number
    retentionData?: NullableJsonNullValueInput | InputJsonValue
    engagementData?: NullableJsonNullValueInput | InputJsonValue
    revenueData?: NullableJsonNullValueInput | InputJsonValue
    lastUpdated?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalyticsCohortUncheckedCreateInput = {
    id?: string
    name: string
    definition: JsonNullValueInput | InputJsonValue
    userCount?: number
    retentionData?: NullableJsonNullValueInput | InputJsonValue
    engagementData?: NullableJsonNullValueInput | InputJsonValue
    revenueData?: NullableJsonNullValueInput | InputJsonValue
    lastUpdated?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalyticsCohortUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    definition?: JsonNullValueInput | InputJsonValue
    userCount?: IntFieldUpdateOperationsInput | number
    retentionData?: NullableJsonNullValueInput | InputJsonValue
    engagementData?: NullableJsonNullValueInput | InputJsonValue
    revenueData?: NullableJsonNullValueInput | InputJsonValue
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsCohortUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    definition?: JsonNullValueInput | InputJsonValue
    userCount?: IntFieldUpdateOperationsInput | number
    retentionData?: NullableJsonNullValueInput | InputJsonValue
    engagementData?: NullableJsonNullValueInput | InputJsonValue
    revenueData?: NullableJsonNullValueInput | InputJsonValue
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsCohortCreateManyInput = {
    id?: string
    name: string
    definition: JsonNullValueInput | InputJsonValue
    userCount?: number
    retentionData?: NullableJsonNullValueInput | InputJsonValue
    engagementData?: NullableJsonNullValueInput | InputJsonValue
    revenueData?: NullableJsonNullValueInput | InputJsonValue
    lastUpdated?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalyticsCohortUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    definition?: JsonNullValueInput | InputJsonValue
    userCount?: IntFieldUpdateOperationsInput | number
    retentionData?: NullableJsonNullValueInput | InputJsonValue
    engagementData?: NullableJsonNullValueInput | InputJsonValue
    revenueData?: NullableJsonNullValueInput | InputJsonValue
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsCohortUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    definition?: JsonNullValueInput | InputJsonValue
    userCount?: IntFieldUpdateOperationsInput | number
    retentionData?: NullableJsonNullValueInput | InputJsonValue
    engagementData?: NullableJsonNullValueInput | InputJsonValue
    revenueData?: NullableJsonNullValueInput | InputJsonValue
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsFunnelCreateInput = {
    id?: string
    name: string
    steps: JsonNullValueInput | InputJsonValue
    conversionRates?: NullableJsonNullValueInput | InputJsonValue
    dropoffRates?: NullableJsonNullValueInput | InputJsonValue
    avgTimePerStep?: NullableJsonNullValueInput | InputJsonValue
    lastCalculated?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalyticsFunnelUncheckedCreateInput = {
    id?: string
    name: string
    steps: JsonNullValueInput | InputJsonValue
    conversionRates?: NullableJsonNullValueInput | InputJsonValue
    dropoffRates?: NullableJsonNullValueInput | InputJsonValue
    avgTimePerStep?: NullableJsonNullValueInput | InputJsonValue
    lastCalculated?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalyticsFunnelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    steps?: JsonNullValueInput | InputJsonValue
    conversionRates?: NullableJsonNullValueInput | InputJsonValue
    dropoffRates?: NullableJsonNullValueInput | InputJsonValue
    avgTimePerStep?: NullableJsonNullValueInput | InputJsonValue
    lastCalculated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsFunnelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    steps?: JsonNullValueInput | InputJsonValue
    conversionRates?: NullableJsonNullValueInput | InputJsonValue
    dropoffRates?: NullableJsonNullValueInput | InputJsonValue
    avgTimePerStep?: NullableJsonNullValueInput | InputJsonValue
    lastCalculated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsFunnelCreateManyInput = {
    id?: string
    name: string
    steps: JsonNullValueInput | InputJsonValue
    conversionRates?: NullableJsonNullValueInput | InputJsonValue
    dropoffRates?: NullableJsonNullValueInput | InputJsonValue
    avgTimePerStep?: NullableJsonNullValueInput | InputJsonValue
    lastCalculated?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalyticsFunnelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    steps?: JsonNullValueInput | InputJsonValue
    conversionRates?: NullableJsonNullValueInput | InputJsonValue
    dropoffRates?: NullableJsonNullValueInput | InputJsonValue
    avgTimePerStep?: NullableJsonNullValueInput | InputJsonValue
    lastCalculated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsFunnelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    steps?: JsonNullValueInput | InputJsonValue
    conversionRates?: NullableJsonNullValueInput | InputJsonValue
    dropoffRates?: NullableJsonNullValueInput | InputJsonValue
    avgTimePerStep?: NullableJsonNullValueInput | InputJsonValue
    lastCalculated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsAttributionCreateInput = {
    id?: string
    userId: string
    conversionId?: string | null
    conversionType: string
    conversionValue?: number | null
    touchpoints: JsonNullValueInput | InputJsonValue
    model: string
    channelWeights: JsonNullValueInput | InputJsonValue
    convertedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AnalyticsAttributionUncheckedCreateInput = {
    id?: string
    userId: string
    conversionId?: string | null
    conversionType: string
    conversionValue?: number | null
    touchpoints: JsonNullValueInput | InputJsonValue
    model: string
    channelWeights: JsonNullValueInput | InputJsonValue
    convertedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AnalyticsAttributionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    conversionId?: NullableStringFieldUpdateOperationsInput | string | null
    conversionType?: StringFieldUpdateOperationsInput | string
    conversionValue?: NullableFloatFieldUpdateOperationsInput | number | null
    touchpoints?: JsonNullValueInput | InputJsonValue
    model?: StringFieldUpdateOperationsInput | string
    channelWeights?: JsonNullValueInput | InputJsonValue
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsAttributionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    conversionId?: NullableStringFieldUpdateOperationsInput | string | null
    conversionType?: StringFieldUpdateOperationsInput | string
    conversionValue?: NullableFloatFieldUpdateOperationsInput | number | null
    touchpoints?: JsonNullValueInput | InputJsonValue
    model?: StringFieldUpdateOperationsInput | string
    channelWeights?: JsonNullValueInput | InputJsonValue
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsAttributionCreateManyInput = {
    id?: string
    userId: string
    conversionId?: string | null
    conversionType: string
    conversionValue?: number | null
    touchpoints: JsonNullValueInput | InputJsonValue
    model: string
    channelWeights: JsonNullValueInput | InputJsonValue
    convertedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AnalyticsAttributionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    conversionId?: NullableStringFieldUpdateOperationsInput | string | null
    conversionType?: StringFieldUpdateOperationsInput | string
    conversionValue?: NullableFloatFieldUpdateOperationsInput | number | null
    touchpoints?: JsonNullValueInput | InputJsonValue
    model?: StringFieldUpdateOperationsInput | string
    channelWeights?: JsonNullValueInput | InputJsonValue
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsAttributionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    conversionId?: NullableStringFieldUpdateOperationsInput | string | null
    conversionType?: StringFieldUpdateOperationsInput | string
    conversionValue?: NullableFloatFieldUpdateOperationsInput | number | null
    touchpoints?: JsonNullValueInput | InputJsonValue
    model?: StringFieldUpdateOperationsInput | string
    channelWeights?: JsonNullValueInput | InputJsonValue
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsSegmentCreateInput = {
    id?: string
    name: string
    type: string
    conditions: JsonNullValueInput | InputJsonValue
    userCount?: number
    avgEngagement?: number | null
    avgRevenue?: number | null
    conversionRate?: number | null
    lastUpdated?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalyticsSegmentUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    conditions: JsonNullValueInput | InputJsonValue
    userCount?: number
    avgEngagement?: number | null
    avgRevenue?: number | null
    conversionRate?: number | null
    lastUpdated?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalyticsSegmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    conditions?: JsonNullValueInput | InputJsonValue
    userCount?: IntFieldUpdateOperationsInput | number
    avgEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    avgRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    conversionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsSegmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    conditions?: JsonNullValueInput | InputJsonValue
    userCount?: IntFieldUpdateOperationsInput | number
    avgEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    avgRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    conversionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsSegmentCreateManyInput = {
    id?: string
    name: string
    type: string
    conditions: JsonNullValueInput | InputJsonValue
    userCount?: number
    avgEngagement?: number | null
    avgRevenue?: number | null
    conversionRate?: number | null
    lastUpdated?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalyticsSegmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    conditions?: JsonNullValueInput | InputJsonValue
    userCount?: IntFieldUpdateOperationsInput | number
    avgEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    avgRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    conversionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsSegmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    conditions?: JsonNullValueInput | InputJsonValue
    userCount?: IntFieldUpdateOperationsInput | number
    avgEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    avgRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    conversionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsReportCreateInput = {
    id?: string
    name: string
    type: string
    definition: JsonNullValueInput | InputJsonValue
    schedule?: string | null
    lastRun?: Date | string | null
    nextRun?: Date | string | null
    recipients?: NullableJsonNullValueInput | InputJsonValue
    format?: string
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalyticsReportUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    definition: JsonNullValueInput | InputJsonValue
    schedule?: string | null
    lastRun?: Date | string | null
    nextRun?: Date | string | null
    recipients?: NullableJsonNullValueInput | InputJsonValue
    format?: string
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalyticsReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    definition?: JsonNullValueInput | InputJsonValue
    schedule?: NullableStringFieldUpdateOperationsInput | string | null
    lastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipients?: NullableJsonNullValueInput | InputJsonValue
    format?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    definition?: JsonNullValueInput | InputJsonValue
    schedule?: NullableStringFieldUpdateOperationsInput | string | null
    lastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipients?: NullableJsonNullValueInput | InputJsonValue
    format?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsReportCreateManyInput = {
    id?: string
    name: string
    type: string
    definition: JsonNullValueInput | InputJsonValue
    schedule?: string | null
    lastRun?: Date | string | null
    nextRun?: Date | string | null
    recipients?: NullableJsonNullValueInput | InputJsonValue
    format?: string
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalyticsReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    definition?: JsonNullValueInput | InputJsonValue
    schedule?: NullableStringFieldUpdateOperationsInput | string | null
    lastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipients?: NullableJsonNullValueInput | InputJsonValue
    format?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    definition?: JsonNullValueInput | InputJsonValue
    schedule?: NullableStringFieldUpdateOperationsInput | string | null
    lastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipients?: NullableJsonNullValueInput | InputJsonValue
    format?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizSessionCreateInput = {
    id?: string
    sessionId: string
    quizId: string
    source?: string | null
    utmSource?: string | null
    utmMedium?: string | null
    utmCampaign?: string | null
    utmContent?: string | null
    contentId?: string | null
    campaignId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    landingPage?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    status?: string
    createdAt?: Date | string
    startTime?: Date | string
    endTime?: Date | string | null
    completionRate?: number | null
    userName?: string | null
    email?: string | null
    phoneNumber?: string | null
    companyName?: string | null
    userType?: string | null
    selectedBrand?: string | null
    userSegment?: string | null
    crewSize?: number | null
    leadQualityScore?: number | null
    version?: string | null
    responses?: QuizResponseCreateNestedManyWithoutSessionInput
    interactions?: BehavioralInteractionCreateNestedManyWithoutSessionInput
    conversions?: QuizConversionCreateNestedManyWithoutSessionInput
  }

  export type QuizSessionUncheckedCreateInput = {
    id?: string
    sessionId: string
    quizId: string
    source?: string | null
    utmSource?: string | null
    utmMedium?: string | null
    utmCampaign?: string | null
    utmContent?: string | null
    contentId?: string | null
    campaignId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    landingPage?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    status?: string
    createdAt?: Date | string
    startTime?: Date | string
    endTime?: Date | string | null
    completionRate?: number | null
    userName?: string | null
    email?: string | null
    phoneNumber?: string | null
    companyName?: string | null
    userType?: string | null
    selectedBrand?: string | null
    userSegment?: string | null
    crewSize?: number | null
    leadQualityScore?: number | null
    version?: string | null
    responses?: QuizResponseUncheckedCreateNestedManyWithoutSessionInput
    interactions?: BehavioralInteractionUncheckedCreateNestedManyWithoutSessionInput
    conversions?: QuizConversionUncheckedCreateNestedManyWithoutSessionInput
  }

  export type QuizSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    utmSource?: NullableStringFieldUpdateOperationsInput | string | null
    utmMedium?: NullableStringFieldUpdateOperationsInput | string | null
    utmCampaign?: NullableStringFieldUpdateOperationsInput | string | null
    utmContent?: NullableStringFieldUpdateOperationsInput | string | null
    contentId?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    landingPage?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: NullableStringFieldUpdateOperationsInput | string | null
    selectedBrand?: NullableStringFieldUpdateOperationsInput | string | null
    userSegment?: NullableStringFieldUpdateOperationsInput | string | null
    crewSize?: NullableIntFieldUpdateOperationsInput | number | null
    leadQualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    responses?: QuizResponseUpdateManyWithoutSessionNestedInput
    interactions?: BehavioralInteractionUpdateManyWithoutSessionNestedInput
    conversions?: QuizConversionUpdateManyWithoutSessionNestedInput
  }

  export type QuizSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    utmSource?: NullableStringFieldUpdateOperationsInput | string | null
    utmMedium?: NullableStringFieldUpdateOperationsInput | string | null
    utmCampaign?: NullableStringFieldUpdateOperationsInput | string | null
    utmContent?: NullableStringFieldUpdateOperationsInput | string | null
    contentId?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    landingPage?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: NullableStringFieldUpdateOperationsInput | string | null
    selectedBrand?: NullableStringFieldUpdateOperationsInput | string | null
    userSegment?: NullableStringFieldUpdateOperationsInput | string | null
    crewSize?: NullableIntFieldUpdateOperationsInput | number | null
    leadQualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    responses?: QuizResponseUncheckedUpdateManyWithoutSessionNestedInput
    interactions?: BehavioralInteractionUncheckedUpdateManyWithoutSessionNestedInput
    conversions?: QuizConversionUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type QuizSessionCreateManyInput = {
    id?: string
    sessionId: string
    quizId: string
    source?: string | null
    utmSource?: string | null
    utmMedium?: string | null
    utmCampaign?: string | null
    utmContent?: string | null
    contentId?: string | null
    campaignId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    landingPage?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    status?: string
    createdAt?: Date | string
    startTime?: Date | string
    endTime?: Date | string | null
    completionRate?: number | null
    userName?: string | null
    email?: string | null
    phoneNumber?: string | null
    companyName?: string | null
    userType?: string | null
    selectedBrand?: string | null
    userSegment?: string | null
    crewSize?: number | null
    leadQualityScore?: number | null
    version?: string | null
  }

  export type QuizSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    utmSource?: NullableStringFieldUpdateOperationsInput | string | null
    utmMedium?: NullableStringFieldUpdateOperationsInput | string | null
    utmCampaign?: NullableStringFieldUpdateOperationsInput | string | null
    utmContent?: NullableStringFieldUpdateOperationsInput | string | null
    contentId?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    landingPage?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: NullableStringFieldUpdateOperationsInput | string | null
    selectedBrand?: NullableStringFieldUpdateOperationsInput | string | null
    userSegment?: NullableStringFieldUpdateOperationsInput | string | null
    crewSize?: NullableIntFieldUpdateOperationsInput | number | null
    leadQualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuizSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    utmSource?: NullableStringFieldUpdateOperationsInput | string | null
    utmMedium?: NullableStringFieldUpdateOperationsInput | string | null
    utmCampaign?: NullableStringFieldUpdateOperationsInput | string | null
    utmContent?: NullableStringFieldUpdateOperationsInput | string | null
    contentId?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    landingPage?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: NullableStringFieldUpdateOperationsInput | string | null
    selectedBrand?: NullableStringFieldUpdateOperationsInput | string | null
    userSegment?: NullableStringFieldUpdateOperationsInput | string | null
    crewSize?: NullableIntFieldUpdateOperationsInput | number | null
    leadQualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuizResponseCreateInput = {
    id?: string
    questionId: string
    questionType: string
    responseValue: JsonNullValueInput | InputJsonValue
    responseTime?: number | null
    createdAt?: Date | string
    session: QuizSessionCreateNestedOneWithoutResponsesInput
  }

  export type QuizResponseUncheckedCreateInput = {
    id?: string
    sessionId: string
    questionId: string
    questionType: string
    responseValue: JsonNullValueInput | InputJsonValue
    responseTime?: number | null
    createdAt?: Date | string
  }

  export type QuizResponseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    questionType?: StringFieldUpdateOperationsInput | string
    responseValue?: JsonNullValueInput | InputJsonValue
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: QuizSessionUpdateOneRequiredWithoutResponsesNestedInput
  }

  export type QuizResponseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    questionType?: StringFieldUpdateOperationsInput | string
    responseValue?: JsonNullValueInput | InputJsonValue
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizResponseCreateManyInput = {
    id?: string
    sessionId: string
    questionId: string
    questionType: string
    responseValue: JsonNullValueInput | InputJsonValue
    responseTime?: number | null
    createdAt?: Date | string
  }

  export type QuizResponseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    questionType?: StringFieldUpdateOperationsInput | string
    responseValue?: JsonNullValueInput | InputJsonValue
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizResponseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    questionType?: StringFieldUpdateOperationsInput | string
    responseValue?: JsonNullValueInput | InputJsonValue
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BehavioralInteractionCreateInput = {
    id?: string
    interactionType: string
    element?: string | null
    position?: NullableJsonNullValueInput | InputJsonValue
    viewport?: NullableJsonNullValueInput | InputJsonValue
    duration?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    session: QuizSessionCreateNestedOneWithoutInteractionsInput
  }

  export type BehavioralInteractionUncheckedCreateInput = {
    id?: string
    sessionId: string
    interactionType: string
    element?: string | null
    position?: NullableJsonNullValueInput | InputJsonValue
    viewport?: NullableJsonNullValueInput | InputJsonValue
    duration?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type BehavioralInteractionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    interactionType?: StringFieldUpdateOperationsInput | string
    element?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableJsonNullValueInput | InputJsonValue
    viewport?: NullableJsonNullValueInput | InputJsonValue
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: QuizSessionUpdateOneRequiredWithoutInteractionsNestedInput
  }

  export type BehavioralInteractionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    interactionType?: StringFieldUpdateOperationsInput | string
    element?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableJsonNullValueInput | InputJsonValue
    viewport?: NullableJsonNullValueInput | InputJsonValue
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BehavioralInteractionCreateManyInput = {
    id?: string
    sessionId: string
    interactionType: string
    element?: string | null
    position?: NullableJsonNullValueInput | InputJsonValue
    viewport?: NullableJsonNullValueInput | InputJsonValue
    duration?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type BehavioralInteractionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    interactionType?: StringFieldUpdateOperationsInput | string
    element?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableJsonNullValueInput | InputJsonValue
    viewport?: NullableJsonNullValueInput | InputJsonValue
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BehavioralInteractionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    interactionType?: StringFieldUpdateOperationsInput | string
    element?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableJsonNullValueInput | InputJsonValue
    viewport?: NullableJsonNullValueInput | InputJsonValue
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizConversionCreateInput = {
    id?: string
    conversionType: string
    conversionValue?: number | null
    orderId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    session: QuizSessionCreateNestedOneWithoutConversionsInput
  }

  export type QuizConversionUncheckedCreateInput = {
    id?: string
    sessionId: string
    conversionType: string
    conversionValue?: number | null
    orderId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type QuizConversionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversionType?: StringFieldUpdateOperationsInput | string
    conversionValue?: NullableFloatFieldUpdateOperationsInput | number | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: QuizSessionUpdateOneRequiredWithoutConversionsNestedInput
  }

  export type QuizConversionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    conversionType?: StringFieldUpdateOperationsInput | string
    conversionValue?: NullableFloatFieldUpdateOperationsInput | number | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizConversionCreateManyInput = {
    id?: string
    sessionId: string
    conversionType: string
    conversionValue?: number | null
    orderId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type QuizConversionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversionType?: StringFieldUpdateOperationsInput | string
    conversionValue?: NullableFloatFieldUpdateOperationsInput | number | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizConversionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    conversionType?: StringFieldUpdateOperationsInput | string
    conversionValue?: NullableFloatFieldUpdateOperationsInput | number | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ABTestExperimentCreateInput = {
    id?: string
    name: string
    status?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    testType: string
    control: JsonNullValueInput | InputJsonValue
    variants: JsonNullValueInput | InputJsonValue
    allocation: JsonNullValueInput | InputJsonValue
    metrics: JsonNullValueInput | InputJsonValue
    results?: NullableJsonNullValueInput | InputJsonValue
    winner?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ABTestExperimentUncheckedCreateInput = {
    id?: string
    name: string
    status?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    testType: string
    control: JsonNullValueInput | InputJsonValue
    variants: JsonNullValueInput | InputJsonValue
    allocation: JsonNullValueInput | InputJsonValue
    metrics: JsonNullValueInput | InputJsonValue
    results?: NullableJsonNullValueInput | InputJsonValue
    winner?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ABTestExperimentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    testType?: StringFieldUpdateOperationsInput | string
    control?: JsonNullValueInput | InputJsonValue
    variants?: JsonNullValueInput | InputJsonValue
    allocation?: JsonNullValueInput | InputJsonValue
    metrics?: JsonNullValueInput | InputJsonValue
    results?: NullableJsonNullValueInput | InputJsonValue
    winner?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ABTestExperimentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    testType?: StringFieldUpdateOperationsInput | string
    control?: JsonNullValueInput | InputJsonValue
    variants?: JsonNullValueInput | InputJsonValue
    allocation?: JsonNullValueInput | InputJsonValue
    metrics?: JsonNullValueInput | InputJsonValue
    results?: NullableJsonNullValueInput | InputJsonValue
    winner?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ABTestExperimentCreateManyInput = {
    id?: string
    name: string
    status?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    testType: string
    control: JsonNullValueInput | InputJsonValue
    variants: JsonNullValueInput | InputJsonValue
    allocation: JsonNullValueInput | InputJsonValue
    metrics: JsonNullValueInput | InputJsonValue
    results?: NullableJsonNullValueInput | InputJsonValue
    winner?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ABTestExperimentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    testType?: StringFieldUpdateOperationsInput | string
    control?: JsonNullValueInput | InputJsonValue
    variants?: JsonNullValueInput | InputJsonValue
    allocation?: JsonNullValueInput | InputJsonValue
    metrics?: JsonNullValueInput | InputJsonValue
    results?: NullableJsonNullValueInput | InputJsonValue
    winner?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ABTestExperimentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    testType?: StringFieldUpdateOperationsInput | string
    control?: JsonNullValueInput | InputJsonValue
    variants?: JsonNullValueInput | InputJsonValue
    allocation?: JsonNullValueInput | InputJsonValue
    metrics?: JsonNullValueInput | InputJsonValue
    results?: NullableJsonNullValueInput | InputJsonValue
    winner?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizBrandCreateInput = {
    id?: string
    brandId: string
    name: string
    displayName: string
    color: string
    voltage: string
    voltageOptions: JsonNullValueInput | InputJsonValue
    marketShare?: number | null
    popularWith?: NullableJsonNullValueInput | InputJsonValue
    category?: string | null
    active?: boolean
    createdAt?: Date | string
  }

  export type QuizBrandUncheckedCreateInput = {
    id?: string
    brandId: string
    name: string
    displayName: string
    color: string
    voltage: string
    voltageOptions: JsonNullValueInput | InputJsonValue
    marketShare?: number | null
    popularWith?: NullableJsonNullValueInput | InputJsonValue
    category?: string | null
    active?: boolean
    createdAt?: Date | string
  }

  export type QuizBrandUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    brandId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    voltage?: StringFieldUpdateOperationsInput | string
    voltageOptions?: JsonNullValueInput | InputJsonValue
    marketShare?: NullableFloatFieldUpdateOperationsInput | number | null
    popularWith?: NullableJsonNullValueInput | InputJsonValue
    category?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizBrandUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    brandId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    voltage?: StringFieldUpdateOperationsInput | string
    voltageOptions?: JsonNullValueInput | InputJsonValue
    marketShare?: NullableFloatFieldUpdateOperationsInput | number | null
    popularWith?: NullableJsonNullValueInput | InputJsonValue
    category?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizBrandCreateManyInput = {
    id?: string
    brandId: string
    name: string
    displayName: string
    color: string
    voltage: string
    voltageOptions: JsonNullValueInput | InputJsonValue
    marketShare?: number | null
    popularWith?: NullableJsonNullValueInput | InputJsonValue
    category?: string | null
    active?: boolean
    createdAt?: Date | string
  }

  export type QuizBrandUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    brandId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    voltage?: StringFieldUpdateOperationsInput | string
    voltageOptions?: JsonNullValueInput | InputJsonValue
    marketShare?: NullableFloatFieldUpdateOperationsInput | number | null
    popularWith?: NullableJsonNullValueInput | InputJsonValue
    category?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizBrandUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    brandId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    voltage?: StringFieldUpdateOperationsInput | string
    voltageOptions?: JsonNullValueInput | InputJsonValue
    marketShare?: NullableFloatFieldUpdateOperationsInput | number | null
    popularWith?: NullableJsonNullValueInput | InputJsonValue
    category?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizRoutingRuleCreateInput = {
    id?: string
    userType?: string | null
    brand?: string | null
    trade?: string | null
    nextQuestionId: string
    condition?: NullableJsonNullValueInput | InputJsonValue
    priority?: number
    active?: boolean
    createdAt?: Date | string
  }

  export type QuizRoutingRuleUncheckedCreateInput = {
    id?: string
    userType?: string | null
    brand?: string | null
    trade?: string | null
    nextQuestionId: string
    condition?: NullableJsonNullValueInput | InputJsonValue
    priority?: number
    active?: boolean
    createdAt?: Date | string
  }

  export type QuizRoutingRuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    trade?: NullableStringFieldUpdateOperationsInput | string | null
    nextQuestionId?: StringFieldUpdateOperationsInput | string
    condition?: NullableJsonNullValueInput | InputJsonValue
    priority?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizRoutingRuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    trade?: NullableStringFieldUpdateOperationsInput | string | null
    nextQuestionId?: StringFieldUpdateOperationsInput | string
    condition?: NullableJsonNullValueInput | InputJsonValue
    priority?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizRoutingRuleCreateManyInput = {
    id?: string
    userType?: string | null
    brand?: string | null
    trade?: string | null
    nextQuestionId: string
    condition?: NullableJsonNullValueInput | InputJsonValue
    priority?: number
    active?: boolean
    createdAt?: Date | string
  }

  export type QuizRoutingRuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    trade?: NullableStringFieldUpdateOperationsInput | string | null
    nextQuestionId?: StringFieldUpdateOperationsInput | string
    condition?: NullableJsonNullValueInput | InputJsonValue
    priority?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizRoutingRuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    trade?: NullableStringFieldUpdateOperationsInput | string | null
    nextQuestionId?: StringFieldUpdateOperationsInput | string
    condition?: NullableJsonNullValueInput | InputJsonValue
    priority?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizInterventionCreateInput = {
    id?: string
    sessionId: string
    interventionType: string
    triggerReason: string
    questionId?: string | null
    shownAt?: Date | string
    userAction?: string | null
    actionTimestamp?: Date | string | null
  }

  export type QuizInterventionUncheckedCreateInput = {
    id?: string
    sessionId: string
    interventionType: string
    triggerReason: string
    questionId?: string | null
    shownAt?: Date | string
    userAction?: string | null
    actionTimestamp?: Date | string | null
  }

  export type QuizInterventionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    interventionType?: StringFieldUpdateOperationsInput | string
    triggerReason?: StringFieldUpdateOperationsInput | string
    questionId?: NullableStringFieldUpdateOperationsInput | string | null
    shownAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAction?: NullableStringFieldUpdateOperationsInput | string | null
    actionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizInterventionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    interventionType?: StringFieldUpdateOperationsInput | string
    triggerReason?: StringFieldUpdateOperationsInput | string
    questionId?: NullableStringFieldUpdateOperationsInput | string | null
    shownAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAction?: NullableStringFieldUpdateOperationsInput | string | null
    actionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizInterventionCreateManyInput = {
    id?: string
    sessionId: string
    interventionType: string
    triggerReason: string
    questionId?: string | null
    shownAt?: Date | string
    userAction?: string | null
    actionTimestamp?: Date | string | null
  }

  export type QuizInterventionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    interventionType?: StringFieldUpdateOperationsInput | string
    triggerReason?: StringFieldUpdateOperationsInput | string
    questionId?: NullableStringFieldUpdateOperationsInput | string | null
    shownAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAction?: NullableStringFieldUpdateOperationsInput | string | null
    actionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizInterventionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    interventionType?: StringFieldUpdateOperationsInput | string
    triggerReason?: StringFieldUpdateOperationsInput | string
    questionId?: NullableStringFieldUpdateOperationsInput | string | null
    shownAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAction?: NullableStringFieldUpdateOperationsInput | string | null
    actionTimestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ServiceCreateInput = {
    id?: string
    serviceCode: string
    name: string
    description?: string | null
    category: string
    basePrice?: number | null
    pricingModel?: string
    currency?: string
    specifications?: NullableJsonNullValueInput | InputJsonValue
    portfolio?: NullableJsonNullValueInput | InputJsonValue
    leadTime?: number | null
    capacity?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutServiceInput
    quotes?: QuoteCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: string
    serviceCode: string
    name: string
    description?: string | null
    category: string
    basePrice?: number | null
    pricingModel?: string
    currency?: string
    specifications?: NullableJsonNullValueInput | InputJsonValue
    portfolio?: NullableJsonNullValueInput | InputJsonValue
    leadTime?: number | null
    capacity?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutServiceInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    basePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    pricingModel?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    specifications?: NullableJsonNullValueInput | InputJsonValue
    portfolio?: NullableJsonNullValueInput | InputJsonValue
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    capacity?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutServiceNestedInput
    quotes?: QuoteUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    basePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    pricingModel?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    specifications?: NullableJsonNullValueInput | InputJsonValue
    portfolio?: NullableJsonNullValueInput | InputJsonValue
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    capacity?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutServiceNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: string
    serviceCode: string
    name: string
    description?: string | null
    category: string
    basePrice?: number | null
    pricingModel?: string
    currency?: string
    specifications?: NullableJsonNullValueInput | InputJsonValue
    portfolio?: NullableJsonNullValueInput | InputJsonValue
    leadTime?: number | null
    capacity?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    basePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    pricingModel?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    specifications?: NullableJsonNullValueInput | InputJsonValue
    portfolio?: NullableJsonNullValueInput | InputJsonValue
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    capacity?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    basePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    pricingModel?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    specifications?: NullableJsonNullValueInput | InputJsonValue
    portfolio?: NullableJsonNullValueInput | InputJsonValue
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    capacity?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateInput = {
    id?: string
    projectRef: string
    name: string
    description?: string | null
    service: string
    status?: string
    currentStage?: string
    stagesCompleted?: ProjectCreatestagesCompletedInput | string[]
    quotedAmount?: number | null
    actualCost?: number | null
    invoicedAmount?: number | null
    paidAmount?: number | null
    startDate?: Date | string | null
    targetDate?: Date | string | null
    completedDate?: Date | string | null
    location?: string | null
    notes?: string | null
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    client: CustomerCreateNestedOneWithoutProjectsInput
    documents?: DocumentCreateNestedManyWithoutProjectInput
    stages?: ProjectStageCreateNestedManyWithoutProjectInput
    costs?: MaterialCostCreateNestedManyWithoutProjectInput
    order?: OrderCreateNestedOneWithoutProjectInput
    Service?: ServiceCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    projectRef: string
    clientId: string
    name: string
    description?: string | null
    service: string
    status?: string
    currentStage?: string
    stagesCompleted?: ProjectCreatestagesCompletedInput | string[]
    quotedAmount?: number | null
    actualCost?: number | null
    invoicedAmount?: number | null
    paidAmount?: number | null
    startDate?: Date | string | null
    targetDate?: Date | string | null
    completedDate?: Date | string | null
    location?: string | null
    notes?: string | null
    priority?: string
    orderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceId?: string | null
    documents?: DocumentUncheckedCreateNestedManyWithoutProjectInput
    stages?: ProjectStageUncheckedCreateNestedManyWithoutProjectInput
    costs?: MaterialCostUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectRef?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentStage?: StringFieldUpdateOperationsInput | string
    stagesCompleted?: ProjectUpdatestagesCompletedInput | string[]
    quotedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    invoicedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: CustomerUpdateOneRequiredWithoutProjectsNestedInput
    documents?: DocumentUpdateManyWithoutProjectNestedInput
    stages?: ProjectStageUpdateManyWithoutProjectNestedInput
    costs?: MaterialCostUpdateManyWithoutProjectNestedInput
    order?: OrderUpdateOneWithoutProjectNestedInput
    Service?: ServiceUpdateOneWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectRef?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentStage?: StringFieldUpdateOperationsInput | string
    stagesCompleted?: ProjectUpdatestagesCompletedInput | string[]
    quotedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    invoicedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: DocumentUncheckedUpdateManyWithoutProjectNestedInput
    stages?: ProjectStageUncheckedUpdateManyWithoutProjectNestedInput
    costs?: MaterialCostUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: string
    projectRef: string
    clientId: string
    name: string
    description?: string | null
    service: string
    status?: string
    currentStage?: string
    stagesCompleted?: ProjectCreatestagesCompletedInput | string[]
    quotedAmount?: number | null
    actualCost?: number | null
    invoicedAmount?: number | null
    paidAmount?: number | null
    startDate?: Date | string | null
    targetDate?: Date | string | null
    completedDate?: Date | string | null
    location?: string | null
    notes?: string | null
    priority?: string
    orderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceId?: string | null
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectRef?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentStage?: StringFieldUpdateOperationsInput | string
    stagesCompleted?: ProjectUpdatestagesCompletedInput | string[]
    quotedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    invoicedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectRef?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentStage?: StringFieldUpdateOperationsInput | string
    stagesCompleted?: ProjectUpdatestagesCompletedInput | string[]
    quotedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    invoicedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectStageCreateInput = {
    id?: string
    stageName: string
    status?: string
    notes?: string | null
    completedAt?: Date | string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutStagesInput
  }

  export type ProjectStageUncheckedCreateInput = {
    id?: string
    projectId: string
    stageName: string
    status?: string
    notes?: string | null
    completedAt?: Date | string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectStageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stageName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutStagesNestedInput
  }

  export type ProjectStageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    stageName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectStageCreateManyInput = {
    id?: string
    projectId: string
    stageName: string
    status?: string
    notes?: string | null
    completedAt?: Date | string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectStageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stageName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectStageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    stageName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateInput = {
    id?: string
    filename: string
    originalName: string
    fileType: string
    fileSize?: number | null
    fileUrl?: string | null
    uploadedAt?: Date | string
    project: ProjectCreateNestedOneWithoutDocumentsInput
    generations?: DocumentGenerationCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    projectId: string
    filename: string
    originalName: string
    fileType: string
    fileSize?: number | null
    fileUrl?: string | null
    uploadedAt?: Date | string
    generations?: DocumentGenerationUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutDocumentsNestedInput
    generations?: DocumentGenerationUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generations?: DocumentGenerationUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentCreateManyInput = {
    id?: string
    projectId: string
    filename: string
    originalName: string
    fileType: string
    fileSize?: number | null
    fileUrl?: string | null
    uploadedAt?: Date | string
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentGenerationCreateInput = {
    id?: string
    documentType: string
    documentNumber: string
    templateData: string
    status?: string
    generatedBy?: string | null
    generatedAt?: Date | string | null
    autoSend?: boolean
    emailSent?: boolean
    emailSentAt?: Date | string | null
    recipientEmail?: string | null
    fileUrl?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    document: DocumentCreateNestedOneWithoutGenerationsInput
  }

  export type DocumentGenerationUncheckedCreateInput = {
    id?: string
    documentId: string
    documentType: string
    documentNumber: string
    templateData: string
    status?: string
    generatedBy?: string | null
    generatedAt?: Date | string | null
    autoSend?: boolean
    emailSent?: boolean
    emailSentAt?: Date | string | null
    recipientEmail?: string | null
    fileUrl?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentGenerationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    documentNumber?: StringFieldUpdateOperationsInput | string
    templateData?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    generatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoSend?: BoolFieldUpdateOperationsInput | boolean
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUpdateOneRequiredWithoutGenerationsNestedInput
  }

  export type DocumentGenerationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    documentNumber?: StringFieldUpdateOperationsInput | string
    templateData?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    generatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoSend?: BoolFieldUpdateOperationsInput | boolean
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentGenerationCreateManyInput = {
    id?: string
    documentId: string
    documentType: string
    documentNumber: string
    templateData: string
    status?: string
    generatedBy?: string | null
    generatedAt?: Date | string | null
    autoSend?: boolean
    emailSent?: boolean
    emailSentAt?: Date | string | null
    recipientEmail?: string | null
    fileUrl?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentGenerationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    documentNumber?: StringFieldUpdateOperationsInput | string
    templateData?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    generatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoSend?: BoolFieldUpdateOperationsInput | boolean
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentGenerationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    documentNumber?: StringFieldUpdateOperationsInput | string
    templateData?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    generatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoSend?: BoolFieldUpdateOperationsInput | boolean
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteCreateInput = {
    id?: string
    quoteNumber: string
    title: string
    description?: string | null
    services: JsonNullValueInput | InputJsonValue
    subtotal: number
    tax: number
    total: number
    currency?: string
    validUntil: Date | string
    status?: string
    terms?: string | null
    notes?: string | null
    convertedToProjectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutQuotesInput
    Service?: ServiceCreateNestedOneWithoutQuotesInput
  }

  export type QuoteUncheckedCreateInput = {
    id?: string
    quoteNumber: string
    customerId: string
    title: string
    description?: string | null
    services: JsonNullValueInput | InputJsonValue
    subtotal: number
    tax: number
    total: number
    currency?: string
    validUntil: Date | string
    status?: string
    terms?: string | null
    notes?: string | null
    convertedToProjectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceId?: string | null
  }

  export type QuoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    services?: JsonNullValueInput | InputJsonValue
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    convertedToProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutQuotesNestedInput
    Service?: ServiceUpdateOneWithoutQuotesNestedInput
  }

  export type QuoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    services?: JsonNullValueInput | InputJsonValue
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    convertedToProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuoteCreateManyInput = {
    id?: string
    quoteNumber: string
    customerId: string
    title: string
    description?: string | null
    services: JsonNullValueInput | InputJsonValue
    subtotal: number
    tax: number
    total: number
    currency?: string
    validUntil: Date | string
    status?: string
    terms?: string | null
    notes?: string | null
    convertedToProjectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceId?: string | null
  }

  export type QuoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    services?: JsonNullValueInput | InputJsonValue
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    convertedToProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    services?: JsonNullValueInput | InputJsonValue
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    convertedToProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaterialCostCreateInput = {
    id?: string
    supplier: string
    material: string
    quantity: number
    unitCost: number
    totalCost: number
    invoiceRef?: string | null
    date: Date | string
    category?: string | null
    createdAt?: Date | string
    project?: ProjectCreateNestedOneWithoutCostsInput
  }

  export type MaterialCostUncheckedCreateInput = {
    id?: string
    projectId?: string | null
    supplier: string
    material: string
    quantity: number
    unitCost: number
    totalCost: number
    invoiceRef?: string | null
    date: Date | string
    category?: string | null
    createdAt?: Date | string
  }

  export type MaterialCostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplier?: StringFieldUpdateOperationsInput | string
    material?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    invoiceRef?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutCostsNestedInput
  }

  export type MaterialCostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: StringFieldUpdateOperationsInput | string
    material?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    invoiceRef?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialCostCreateManyInput = {
    id?: string
    projectId?: string | null
    supplier: string
    material: string
    quantity: number
    unitCost: number
    totalCost: number
    invoiceRef?: string | null
    date: Date | string
    category?: string | null
    createdAt?: Date | string
  }

  export type MaterialCostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplier?: StringFieldUpdateOperationsInput | string
    material?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    invoiceRef?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialCostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: StringFieldUpdateOperationsInput | string
    material?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    invoiceRef?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierInvoiceCreateInput = {
    id?: string
    supplier: string
    invoiceRef: string
    date: Date | string
    totalAmount: number
    items: JsonNullValueInput | InputJsonValue
    fileUrl?: string | null
    processed?: boolean
    createdAt?: Date | string
  }

  export type SupplierInvoiceUncheckedCreateInput = {
    id?: string
    supplier: string
    invoiceRef: string
    date: Date | string
    totalAmount: number
    items: JsonNullValueInput | InputJsonValue
    fileUrl?: string | null
    processed?: boolean
    createdAt?: Date | string
  }

  export type SupplierInvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplier?: StringFieldUpdateOperationsInput | string
    invoiceRef?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    items?: JsonNullValueInput | InputJsonValue
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierInvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplier?: StringFieldUpdateOperationsInput | string
    invoiceRef?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    items?: JsonNullValueInput | InputJsonValue
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierInvoiceCreateManyInput = {
    id?: string
    supplier: string
    invoiceRef: string
    date: Date | string
    totalAmount: number
    items: JsonNullValueInput | InputJsonValue
    fileUrl?: string | null
    processed?: boolean
    createdAt?: Date | string
  }

  export type SupplierInvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplier?: StringFieldUpdateOperationsInput | string
    invoiceRef?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    items?: JsonNullValueInput | InputJsonValue
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierInvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplier?: StringFieldUpdateOperationsInput | string
    invoiceRef?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    items?: JsonNullValueInput | InputJsonValue
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ChatSessionListRelationFilter = {
    every?: ChatSessionWhereInput
    some?: ChatSessionWhereInput
    none?: ChatSessionWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type CustomerNullableScalarRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type CartNullableScalarRelationFilter = {
    is?: CartWhereInput | null
    isNot?: CartWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ChatSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    externalId?: SortOrder
    mondayUserId?: SortOrder
    copilotUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    externalId?: SortOrder
    mondayUserId?: SortOrder
    copilotUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    externalId?: SortOrder
    mondayUserId?: SortOrder
    copilotUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type SessionTagListRelationFilter = {
    every?: SessionTagWhereInput
    some?: SessionTagWhereInput
    none?: SessionTagWhereInput
  }

  export type SessionTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatSessionCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    systemPrompt?: SortOrder
    isActive?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    userEmail?: SortOrder
    ipAddress?: SortOrder
    location?: SortOrder
    source?: SortOrder
    category?: SortOrder
    mondayItemId?: SortOrder
    mondaySynced?: SortOrder
    copilotSynced?: SortOrder
    databaseSynced?: SortOrder
    lastMondaySync?: SortOrder
    lastCopilotSync?: SortOrder
  }

  export type ChatSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    systemPrompt?: SortOrder
    isActive?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    userEmail?: SortOrder
    ipAddress?: SortOrder
    location?: SortOrder
    source?: SortOrder
    category?: SortOrder
    mondayItemId?: SortOrder
    mondaySynced?: SortOrder
    copilotSynced?: SortOrder
    databaseSynced?: SortOrder
    lastMondaySync?: SortOrder
    lastCopilotSync?: SortOrder
  }

  export type ChatSessionMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    systemPrompt?: SortOrder
    isActive?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    userEmail?: SortOrder
    ipAddress?: SortOrder
    location?: SortOrder
    source?: SortOrder
    category?: SortOrder
    mondayItemId?: SortOrder
    mondaySynced?: SortOrder
    copilotSynced?: SortOrder
    databaseSynced?: SortOrder
    lastMondaySync?: SortOrder
    lastCopilotSync?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type ChatSessionScalarRelationFilter = {
    is?: ChatSessionWhereInput
    isNot?: ChatSessionWhereInput
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    timestamp?: SortOrder
    isError?: SortOrder
    userId?: SortOrder
    functionName?: SortOrder
    functionArgs?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    timestamp?: SortOrder
    isError?: SortOrder
    userId?: SortOrder
    functionName?: SortOrder
    functionArgs?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    timestamp?: SortOrder
    isError?: SortOrder
    userId?: SortOrder
    functionName?: SortOrder
    functionArgs?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type SessionTagSessionIdNameCompoundUniqueInput = {
    sessionId: string
    name: string
  }

  export type SessionTagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    sessionId?: SortOrder
  }

  export type SessionTagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    sessionId?: SortOrder
  }

  export type SessionTagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    sessionId?: SortOrder
  }

  export type MondaySyncCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    itemId?: SortOrder
    boardId?: SortOrder
    lastSynced?: SortOrder
  }

  export type MondaySyncMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    itemId?: SortOrder
    boardId?: SortOrder
    lastSynced?: SortOrder
  }

  export type MondaySyncMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    itemId?: SortOrder
    boardId?: SortOrder
    lastSynced?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type PaymentMethodListRelationFilter = {
    every?: PaymentMethodWhereInput
    some?: PaymentMethodWhereInput
    none?: PaymentMethodWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type SubscriptionListRelationFilter = {
    every?: SubscriptionWhereInput
    some?: SubscriptionWhereInput
    none?: SubscriptionWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type QuoteListRelationFilter = {
    every?: QuoteWhereInput
    some?: QuoteWhereInput
    none?: QuoteWhereInput
  }

  export type PaymentMethodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    billingAddress?: SortOrder
    shippingAddress?: SortOrder
    taxId?: SortOrder
    phoneNumber?: SortOrder
    stripeCustomerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    taxId?: SortOrder
    phoneNumber?: SortOrder
    stripeCustomerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    taxId?: SortOrder
    phoneNumber?: SortOrder
    stripeCustomerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type InventoryListRelationFilter = {
    every?: InventoryWhereInput
    some?: InventoryWhereInput
    none?: InventoryWhereInput
  }

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput
    some?: OrderItemWhereInput
    none?: OrderItemWhereInput
  }

  export type CartItemListRelationFilter = {
    every?: CartItemWhereInput
    some?: CartItemWhereInput
    none?: CartItemWhereInput
  }

  export type PriceHistoryListRelationFilter = {
    every?: PriceHistoryWhereInput
    some?: PriceHistoryWhereInput
    none?: PriceHistoryWhereInput
  }

  export type InventoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CartItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PriceHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    basePrice?: SortOrder
    currency?: SortOrder
    specifications?: SortOrder
    images?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    basePrice?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    basePrice?: SortOrder
    currency?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    basePrice?: SortOrder
    currency?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    basePrice?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type CustomerScalarRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type InvoiceNullableScalarRelationFilter = {
    is?: InvoiceWhereInput | null
    isNot?: InvoiceWhereInput | null
  }

  export type ProjectNullableScalarRelationFilter = {
    is?: ProjectWhereInput | null
    isNot?: ProjectWhereInput | null
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    customerId?: SortOrder
    status?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    shipping?: SortOrder
    total?: SortOrder
    currency?: SortOrder
    shippingAddress?: SortOrder
    shippingMethod?: SortOrder
    trackingNumber?: SortOrder
    shippedAt?: SortOrder
    deliveredAt?: SortOrder
    paymentStatus?: SortOrder
    paymentIntentId?: SortOrder
    paidAt?: SortOrder
    customerNotes?: SortOrder
    internalNotes?: SortOrder
    invoiceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    tax?: SortOrder
    shipping?: SortOrder
    total?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    customerId?: SortOrder
    status?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    shipping?: SortOrder
    total?: SortOrder
    currency?: SortOrder
    shippingMethod?: SortOrder
    trackingNumber?: SortOrder
    shippedAt?: SortOrder
    deliveredAt?: SortOrder
    paymentStatus?: SortOrder
    paymentIntentId?: SortOrder
    paidAt?: SortOrder
    customerNotes?: SortOrder
    internalNotes?: SortOrder
    invoiceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    customerId?: SortOrder
    status?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    shipping?: SortOrder
    total?: SortOrder
    currency?: SortOrder
    shippingMethod?: SortOrder
    trackingNumber?: SortOrder
    shippedAt?: SortOrder
    deliveredAt?: SortOrder
    paymentStatus?: SortOrder
    paymentIntentId?: SortOrder
    paidAt?: SortOrder
    customerNotes?: SortOrder
    internalNotes?: SortOrder
    invoiceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    subtotal?: SortOrder
    tax?: SortOrder
    shipping?: SortOrder
    total?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type OrderScalarRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type OrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    productSnapshot?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type OrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type SubscriptionPlanScalarRelationFilter = {
    is?: SubscriptionPlanWhereInput
    isNot?: SubscriptionPlanWhereInput
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    status?: SortOrder
    planId?: SortOrder
    billingCycle?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    nextBillingDate?: SortOrder
    stripeSubscriptionId?: SortOrder
    metadata?: SortOrder
    cancelledAt?: SortOrder
    cancelReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    status?: SortOrder
    planId?: SortOrder
    billingCycle?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    nextBillingDate?: SortOrder
    stripeSubscriptionId?: SortOrder
    cancelledAt?: SortOrder
    cancelReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    status?: SortOrder
    planId?: SortOrder
    billingCycle?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    nextBillingDate?: SortOrder
    stripeSubscriptionId?: SortOrder
    cancelledAt?: SortOrder
    cancelReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionPlanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    features?: SortOrder
    limits?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionPlanAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type SubscriptionPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionPlanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionPlanSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type OrderNullableScalarRelationFilter = {
    is?: OrderWhereInput | null
    isNot?: OrderWhereInput | null
  }

  export type SubscriptionNullableScalarRelationFilter = {
    is?: SubscriptionWhereInput | null
    isNot?: SubscriptionWhereInput | null
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    subscriptionId?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrder
    paymentIntentId?: SortOrder
    paymentMethod?: SortOrder
    pdfUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    subscriptionId?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrder
    paymentIntentId?: SortOrder
    paymentMethod?: SortOrder
    pdfUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    subscriptionId?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrder
    paymentIntentId?: SortOrder
    paymentMethod?: SortOrder
    pdfUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type PaymentMethodCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    stripePaymentMethodId?: SortOrder
    type?: SortOrder
    last4?: SortOrder
    brand?: SortOrder
    expiryMonth?: SortOrder
    expiryYear?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMethodAvgOrderByAggregateInput = {
    expiryMonth?: SortOrder
    expiryYear?: SortOrder
  }

  export type PaymentMethodMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    stripePaymentMethodId?: SortOrder
    type?: SortOrder
    last4?: SortOrder
    brand?: SortOrder
    expiryMonth?: SortOrder
    expiryYear?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMethodMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    stripePaymentMethodId?: SortOrder
    type?: SortOrder
    last4?: SortOrder
    brand?: SortOrder
    expiryMonth?: SortOrder
    expiryYear?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMethodSumOrderByAggregateInput = {
    expiryMonth?: SortOrder
    expiryYear?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type InventoryProductIdLocationCompoundUniqueInput = {
    productId: string
    location: string
  }

  export type InventoryCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    location?: SortOrder
    quantity?: SortOrder
    reservedQuantity?: SortOrder
    availableQuantity?: SortOrder
    reorderPoint?: SortOrder
    reorderQuantity?: SortOrder
    batchNumber?: SortOrder
    serialNumbers?: SortOrder
    lastRestocked?: SortOrder
    lastCounted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryAvgOrderByAggregateInput = {
    quantity?: SortOrder
    reservedQuantity?: SortOrder
    availableQuantity?: SortOrder
    reorderPoint?: SortOrder
    reorderQuantity?: SortOrder
  }

  export type InventoryMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    location?: SortOrder
    quantity?: SortOrder
    reservedQuantity?: SortOrder
    availableQuantity?: SortOrder
    reorderPoint?: SortOrder
    reorderQuantity?: SortOrder
    batchNumber?: SortOrder
    lastRestocked?: SortOrder
    lastCounted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    location?: SortOrder
    quantity?: SortOrder
    reservedQuantity?: SortOrder
    availableQuantity?: SortOrder
    reorderPoint?: SortOrder
    reorderQuantity?: SortOrder
    batchNumber?: SortOrder
    lastRestocked?: SortOrder
    lastCounted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventorySumOrderByAggregateInput = {
    quantity?: SortOrder
    reservedQuantity?: SortOrder
    availableQuantity?: SortOrder
    reorderPoint?: SortOrder
    reorderQuantity?: SortOrder
  }

  export type CartCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartScalarRelationFilter = {
    is?: CartWhereInput
    isNot?: CartWhereInput
  }

  export type CartItemCartIdProductIdCompoundUniqueInput = {
    cartId: string
    productId: string
  }

  export type CartItemCountOrderByAggregateInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type CartItemMaxOrderByAggregateInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartItemMinOrderByAggregateInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartItemSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type PriceHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    price?: SortOrder
    previousPrice?: SortOrder
    currency?: SortOrder
    reason?: SortOrder
    effectiveFrom?: SortOrder
    effectiveUntil?: SortOrder
    createdAt?: SortOrder
  }

  export type PriceHistoryAvgOrderByAggregateInput = {
    price?: SortOrder
    previousPrice?: SortOrder
  }

  export type PriceHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    price?: SortOrder
    previousPrice?: SortOrder
    currency?: SortOrder
    reason?: SortOrder
    effectiveFrom?: SortOrder
    effectiveUntil?: SortOrder
    createdAt?: SortOrder
  }

  export type PriceHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    price?: SortOrder
    previousPrice?: SortOrder
    currency?: SortOrder
    reason?: SortOrder
    effectiveFrom?: SortOrder
    effectiveUntil?: SortOrder
    createdAt?: SortOrder
  }

  export type PriceHistorySumOrderByAggregateInput = {
    price?: SortOrder
    previousPrice?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type SystemHealthCountOrderByAggregateInput = {
    id?: SortOrder
    service?: SortOrder
    status?: SortOrder
    responseTime?: SortOrder
    errorRate?: SortOrder
    uptime?: SortOrder
    message?: SortOrder
    lastCheck?: SortOrder
    nextCheck?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemHealthAvgOrderByAggregateInput = {
    responseTime?: SortOrder
    errorRate?: SortOrder
    uptime?: SortOrder
  }

  export type SystemHealthMaxOrderByAggregateInput = {
    id?: SortOrder
    service?: SortOrder
    status?: SortOrder
    responseTime?: SortOrder
    errorRate?: SortOrder
    uptime?: SortOrder
    message?: SortOrder
    lastCheck?: SortOrder
    nextCheck?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemHealthMinOrderByAggregateInput = {
    id?: SortOrder
    service?: SortOrder
    status?: SortOrder
    responseTime?: SortOrder
    errorRate?: SortOrder
    uptime?: SortOrder
    message?: SortOrder
    lastCheck?: SortOrder
    nextCheck?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemHealthSumOrderByAggregateInput = {
    responseTime?: SortOrder
    errorRate?: SortOrder
    uptime?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    priority?: SortOrder
    channel?: SortOrder
    read?: SortOrder
    readAt?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    priority?: SortOrder
    channel?: SortOrder
    read?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    priority?: SortOrder
    channel?: SortOrder
    read?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AnalyticsEventCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    eventName?: SortOrder
    eventCategory?: SortOrder
    eventData?: SortOrder
    dataPoints?: SortOrder
    context?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsEventMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    eventName?: SortOrder
    eventCategory?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsEventMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    eventName?: SortOrder
    eventCategory?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type AnalyticsSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    visitorId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    pageViews?: SortOrder
    events?: SortOrder
    bounced?: SortOrder
    source?: SortOrder
    medium?: SortOrder
    campaign?: SortOrder
    content?: SortOrder
    term?: SortOrder
    deviceType?: SortOrder
    deviceBrand?: SortOrder
    browser?: SortOrder
    os?: SortOrder
    screenResolution?: SortOrder
    country?: SortOrder
    region?: SortOrder
    city?: SortOrder
    engagementScore?: SortOrder
    conversionValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalyticsSessionAvgOrderByAggregateInput = {
    duration?: SortOrder
    pageViews?: SortOrder
    events?: SortOrder
    engagementScore?: SortOrder
    conversionValue?: SortOrder
  }

  export type AnalyticsSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    visitorId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    pageViews?: SortOrder
    events?: SortOrder
    bounced?: SortOrder
    source?: SortOrder
    medium?: SortOrder
    campaign?: SortOrder
    content?: SortOrder
    term?: SortOrder
    deviceType?: SortOrder
    deviceBrand?: SortOrder
    browser?: SortOrder
    os?: SortOrder
    screenResolution?: SortOrder
    country?: SortOrder
    region?: SortOrder
    city?: SortOrder
    engagementScore?: SortOrder
    conversionValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalyticsSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    visitorId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    pageViews?: SortOrder
    events?: SortOrder
    bounced?: SortOrder
    source?: SortOrder
    medium?: SortOrder
    campaign?: SortOrder
    content?: SortOrder
    term?: SortOrder
    deviceType?: SortOrder
    deviceBrand?: SortOrder
    browser?: SortOrder
    os?: SortOrder
    screenResolution?: SortOrder
    country?: SortOrder
    region?: SortOrder
    city?: SortOrder
    engagementScore?: SortOrder
    conversionValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalyticsSessionSumOrderByAggregateInput = {
    duration?: SortOrder
    pageViews?: SortOrder
    events?: SortOrder
    engagementScore?: SortOrder
    conversionValue?: SortOrder
  }

  export type AnalyticsMetricCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    category?: SortOrder
    calculation?: SortOrder
    dailyValues?: SortOrder
    weeklyValues?: SortOrder
    monthlyValues?: SortOrder
    lastCalculated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalyticsMetricMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    category?: SortOrder
    lastCalculated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalyticsMetricMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    category?: SortOrder
    lastCalculated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalyticsCohortCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    definition?: SortOrder
    userCount?: SortOrder
    retentionData?: SortOrder
    engagementData?: SortOrder
    revenueData?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalyticsCohortAvgOrderByAggregateInput = {
    userCount?: SortOrder
  }

  export type AnalyticsCohortMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    userCount?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalyticsCohortMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    userCount?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalyticsCohortSumOrderByAggregateInput = {
    userCount?: SortOrder
  }

  export type AnalyticsFunnelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    steps?: SortOrder
    conversionRates?: SortOrder
    dropoffRates?: SortOrder
    avgTimePerStep?: SortOrder
    lastCalculated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalyticsFunnelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    lastCalculated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalyticsFunnelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    lastCalculated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalyticsAttributionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    conversionId?: SortOrder
    conversionType?: SortOrder
    conversionValue?: SortOrder
    touchpoints?: SortOrder
    model?: SortOrder
    channelWeights?: SortOrder
    convertedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsAttributionAvgOrderByAggregateInput = {
    conversionValue?: SortOrder
  }

  export type AnalyticsAttributionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    conversionId?: SortOrder
    conversionType?: SortOrder
    conversionValue?: SortOrder
    model?: SortOrder
    convertedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsAttributionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    conversionId?: SortOrder
    conversionType?: SortOrder
    conversionValue?: SortOrder
    model?: SortOrder
    convertedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsAttributionSumOrderByAggregateInput = {
    conversionValue?: SortOrder
  }

  export type AnalyticsSegmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    conditions?: SortOrder
    userCount?: SortOrder
    avgEngagement?: SortOrder
    avgRevenue?: SortOrder
    conversionRate?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalyticsSegmentAvgOrderByAggregateInput = {
    userCount?: SortOrder
    avgEngagement?: SortOrder
    avgRevenue?: SortOrder
    conversionRate?: SortOrder
  }

  export type AnalyticsSegmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    userCount?: SortOrder
    avgEngagement?: SortOrder
    avgRevenue?: SortOrder
    conversionRate?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalyticsSegmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    userCount?: SortOrder
    avgEngagement?: SortOrder
    avgRevenue?: SortOrder
    conversionRate?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalyticsSegmentSumOrderByAggregateInput = {
    userCount?: SortOrder
    avgEngagement?: SortOrder
    avgRevenue?: SortOrder
    conversionRate?: SortOrder
  }

  export type AnalyticsReportCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    definition?: SortOrder
    schedule?: SortOrder
    lastRun?: SortOrder
    nextRun?: SortOrder
    recipients?: SortOrder
    format?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalyticsReportMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    schedule?: SortOrder
    lastRun?: SortOrder
    nextRun?: SortOrder
    format?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalyticsReportMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    schedule?: SortOrder
    lastRun?: SortOrder
    nextRun?: SortOrder
    format?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizResponseListRelationFilter = {
    every?: QuizResponseWhereInput
    some?: QuizResponseWhereInput
    none?: QuizResponseWhereInput
  }

  export type BehavioralInteractionListRelationFilter = {
    every?: BehavioralInteractionWhereInput
    some?: BehavioralInteractionWhereInput
    none?: BehavioralInteractionWhereInput
  }

  export type QuizConversionListRelationFilter = {
    every?: QuizConversionWhereInput
    some?: QuizConversionWhereInput
    none?: QuizConversionWhereInput
  }

  export type QuizResponseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BehavioralInteractionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizConversionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizSessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    quizId?: SortOrder
    source?: SortOrder
    utmSource?: SortOrder
    utmMedium?: SortOrder
    utmCampaign?: SortOrder
    utmContent?: SortOrder
    contentId?: SortOrder
    campaignId?: SortOrder
    deviceInfo?: SortOrder
    landingPage?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    completionRate?: SortOrder
    userName?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    companyName?: SortOrder
    userType?: SortOrder
    selectedBrand?: SortOrder
    userSegment?: SortOrder
    crewSize?: SortOrder
    leadQualityScore?: SortOrder
    version?: SortOrder
  }

  export type QuizSessionAvgOrderByAggregateInput = {
    completionRate?: SortOrder
    crewSize?: SortOrder
    leadQualityScore?: SortOrder
  }

  export type QuizSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    quizId?: SortOrder
    source?: SortOrder
    utmSource?: SortOrder
    utmMedium?: SortOrder
    utmCampaign?: SortOrder
    utmContent?: SortOrder
    contentId?: SortOrder
    campaignId?: SortOrder
    landingPage?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    completionRate?: SortOrder
    userName?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    companyName?: SortOrder
    userType?: SortOrder
    selectedBrand?: SortOrder
    userSegment?: SortOrder
    crewSize?: SortOrder
    leadQualityScore?: SortOrder
    version?: SortOrder
  }

  export type QuizSessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    quizId?: SortOrder
    source?: SortOrder
    utmSource?: SortOrder
    utmMedium?: SortOrder
    utmCampaign?: SortOrder
    utmContent?: SortOrder
    contentId?: SortOrder
    campaignId?: SortOrder
    landingPage?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    completionRate?: SortOrder
    userName?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    companyName?: SortOrder
    userType?: SortOrder
    selectedBrand?: SortOrder
    userSegment?: SortOrder
    crewSize?: SortOrder
    leadQualityScore?: SortOrder
    version?: SortOrder
  }

  export type QuizSessionSumOrderByAggregateInput = {
    completionRate?: SortOrder
    crewSize?: SortOrder
    leadQualityScore?: SortOrder
  }

  export type QuizSessionScalarRelationFilter = {
    is?: QuizSessionWhereInput
    isNot?: QuizSessionWhereInput
  }

  export type QuizResponseCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    questionId?: SortOrder
    questionType?: SortOrder
    responseValue?: SortOrder
    responseTime?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizResponseAvgOrderByAggregateInput = {
    responseTime?: SortOrder
  }

  export type QuizResponseMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    questionId?: SortOrder
    questionType?: SortOrder
    responseTime?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizResponseMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    questionId?: SortOrder
    questionType?: SortOrder
    responseTime?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizResponseSumOrderByAggregateInput = {
    responseTime?: SortOrder
  }

  export type BehavioralInteractionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    interactionType?: SortOrder
    element?: SortOrder
    position?: SortOrder
    viewport?: SortOrder
    duration?: SortOrder
    metadata?: SortOrder
    timestamp?: SortOrder
  }

  export type BehavioralInteractionAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type BehavioralInteractionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    interactionType?: SortOrder
    element?: SortOrder
    duration?: SortOrder
    timestamp?: SortOrder
  }

  export type BehavioralInteractionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    interactionType?: SortOrder
    element?: SortOrder
    duration?: SortOrder
    timestamp?: SortOrder
  }

  export type BehavioralInteractionSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type QuizConversionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    conversionType?: SortOrder
    conversionValue?: SortOrder
    orderId?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizConversionAvgOrderByAggregateInput = {
    conversionValue?: SortOrder
  }

  export type QuizConversionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    conversionType?: SortOrder
    conversionValue?: SortOrder
    orderId?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizConversionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    conversionType?: SortOrder
    conversionValue?: SortOrder
    orderId?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizConversionSumOrderByAggregateInput = {
    conversionValue?: SortOrder
  }

  export type ABTestExperimentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    testType?: SortOrder
    control?: SortOrder
    variants?: SortOrder
    allocation?: SortOrder
    metrics?: SortOrder
    results?: SortOrder
    winner?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ABTestExperimentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    testType?: SortOrder
    winner?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ABTestExperimentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    testType?: SortOrder
    winner?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizBrandCountOrderByAggregateInput = {
    id?: SortOrder
    brandId?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    color?: SortOrder
    voltage?: SortOrder
    voltageOptions?: SortOrder
    marketShare?: SortOrder
    popularWith?: SortOrder
    category?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizBrandAvgOrderByAggregateInput = {
    marketShare?: SortOrder
  }

  export type QuizBrandMaxOrderByAggregateInput = {
    id?: SortOrder
    brandId?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    color?: SortOrder
    voltage?: SortOrder
    marketShare?: SortOrder
    category?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizBrandMinOrderByAggregateInput = {
    id?: SortOrder
    brandId?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    color?: SortOrder
    voltage?: SortOrder
    marketShare?: SortOrder
    category?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizBrandSumOrderByAggregateInput = {
    marketShare?: SortOrder
  }

  export type QuizRoutingRuleCountOrderByAggregateInput = {
    id?: SortOrder
    userType?: SortOrder
    brand?: SortOrder
    trade?: SortOrder
    nextQuestionId?: SortOrder
    condition?: SortOrder
    priority?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizRoutingRuleAvgOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type QuizRoutingRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    userType?: SortOrder
    brand?: SortOrder
    trade?: SortOrder
    nextQuestionId?: SortOrder
    priority?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizRoutingRuleMinOrderByAggregateInput = {
    id?: SortOrder
    userType?: SortOrder
    brand?: SortOrder
    trade?: SortOrder
    nextQuestionId?: SortOrder
    priority?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizRoutingRuleSumOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type QuizInterventionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    interventionType?: SortOrder
    triggerReason?: SortOrder
    questionId?: SortOrder
    shownAt?: SortOrder
    userAction?: SortOrder
    actionTimestamp?: SortOrder
  }

  export type QuizInterventionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    interventionType?: SortOrder
    triggerReason?: SortOrder
    questionId?: SortOrder
    shownAt?: SortOrder
    userAction?: SortOrder
    actionTimestamp?: SortOrder
  }

  export type QuizInterventionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    interventionType?: SortOrder
    triggerReason?: SortOrder
    questionId?: SortOrder
    shownAt?: SortOrder
    userAction?: SortOrder
    actionTimestamp?: SortOrder
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    serviceCode?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    basePrice?: SortOrder
    pricingModel?: SortOrder
    currency?: SortOrder
    specifications?: SortOrder
    portfolio?: SortOrder
    leadTime?: SortOrder
    capacity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceAvgOrderByAggregateInput = {
    basePrice?: SortOrder
    leadTime?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    serviceCode?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    basePrice?: SortOrder
    pricingModel?: SortOrder
    currency?: SortOrder
    leadTime?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    serviceCode?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    basePrice?: SortOrder
    pricingModel?: SortOrder
    currency?: SortOrder
    leadTime?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceSumOrderByAggregateInput = {
    basePrice?: SortOrder
    leadTime?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type ProjectStageListRelationFilter = {
    every?: ProjectStageWhereInput
    some?: ProjectStageWhereInput
    none?: ProjectStageWhereInput
  }

  export type MaterialCostListRelationFilter = {
    every?: MaterialCostWhereInput
    some?: MaterialCostWhereInput
    none?: MaterialCostWhereInput
  }

  export type ServiceNullableScalarRelationFilter = {
    is?: ServiceWhereInput | null
    isNot?: ServiceWhereInput | null
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectStageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaterialCostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    projectRef?: SortOrder
    clientId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    service?: SortOrder
    status?: SortOrder
    currentStage?: SortOrder
    stagesCompleted?: SortOrder
    quotedAmount?: SortOrder
    actualCost?: SortOrder
    invoicedAmount?: SortOrder
    paidAmount?: SortOrder
    startDate?: SortOrder
    targetDate?: SortOrder
    completedDate?: SortOrder
    location?: SortOrder
    notes?: SortOrder
    priority?: SortOrder
    orderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceId?: SortOrder
  }

  export type ProjectAvgOrderByAggregateInput = {
    quotedAmount?: SortOrder
    actualCost?: SortOrder
    invoicedAmount?: SortOrder
    paidAmount?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    projectRef?: SortOrder
    clientId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    service?: SortOrder
    status?: SortOrder
    currentStage?: SortOrder
    quotedAmount?: SortOrder
    actualCost?: SortOrder
    invoicedAmount?: SortOrder
    paidAmount?: SortOrder
    startDate?: SortOrder
    targetDate?: SortOrder
    completedDate?: SortOrder
    location?: SortOrder
    notes?: SortOrder
    priority?: SortOrder
    orderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceId?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    projectRef?: SortOrder
    clientId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    service?: SortOrder
    status?: SortOrder
    currentStage?: SortOrder
    quotedAmount?: SortOrder
    actualCost?: SortOrder
    invoicedAmount?: SortOrder
    paidAmount?: SortOrder
    startDate?: SortOrder
    targetDate?: SortOrder
    completedDate?: SortOrder
    location?: SortOrder
    notes?: SortOrder
    priority?: SortOrder
    orderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceId?: SortOrder
  }

  export type ProjectSumOrderByAggregateInput = {
    quotedAmount?: SortOrder
    actualCost?: SortOrder
    invoicedAmount?: SortOrder
    paidAmount?: SortOrder
  }

  export type ProjectScalarRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type ProjectStageCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    stageName?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    completedAt?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectStageAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ProjectStageMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    stageName?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    completedAt?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectStageMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    stageName?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    completedAt?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectStageSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type DocumentGenerationListRelationFilter = {
    every?: DocumentGenerationWhereInput
    some?: DocumentGenerationWhereInput
    none?: DocumentGenerationWhereInput
  }

  export type DocumentGenerationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    fileUrl?: SortOrder
    uploadedAt?: SortOrder
  }

  export type DocumentAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    fileUrl?: SortOrder
    uploadedAt?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    fileUrl?: SortOrder
    uploadedAt?: SortOrder
  }

  export type DocumentSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type DocumentScalarRelationFilter = {
    is?: DocumentWhereInput
    isNot?: DocumentWhereInput
  }

  export type DocumentGenerationCountOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    documentType?: SortOrder
    documentNumber?: SortOrder
    templateData?: SortOrder
    status?: SortOrder
    generatedBy?: SortOrder
    generatedAt?: SortOrder
    autoSend?: SortOrder
    emailSent?: SortOrder
    emailSentAt?: SortOrder
    recipientEmail?: SortOrder
    fileUrl?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentGenerationMaxOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    documentType?: SortOrder
    documentNumber?: SortOrder
    templateData?: SortOrder
    status?: SortOrder
    generatedBy?: SortOrder
    generatedAt?: SortOrder
    autoSend?: SortOrder
    emailSent?: SortOrder
    emailSentAt?: SortOrder
    recipientEmail?: SortOrder
    fileUrl?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentGenerationMinOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    documentType?: SortOrder
    documentNumber?: SortOrder
    templateData?: SortOrder
    status?: SortOrder
    generatedBy?: SortOrder
    generatedAt?: SortOrder
    autoSend?: SortOrder
    emailSent?: SortOrder
    emailSentAt?: SortOrder
    recipientEmail?: SortOrder
    fileUrl?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuoteCountOrderByAggregateInput = {
    id?: SortOrder
    quoteNumber?: SortOrder
    customerId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    services?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    currency?: SortOrder
    validUntil?: SortOrder
    status?: SortOrder
    terms?: SortOrder
    notes?: SortOrder
    convertedToProjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceId?: SortOrder
  }

  export type QuoteAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
  }

  export type QuoteMaxOrderByAggregateInput = {
    id?: SortOrder
    quoteNumber?: SortOrder
    customerId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    currency?: SortOrder
    validUntil?: SortOrder
    status?: SortOrder
    terms?: SortOrder
    notes?: SortOrder
    convertedToProjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceId?: SortOrder
  }

  export type QuoteMinOrderByAggregateInput = {
    id?: SortOrder
    quoteNumber?: SortOrder
    customerId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    currency?: SortOrder
    validUntil?: SortOrder
    status?: SortOrder
    terms?: SortOrder
    notes?: SortOrder
    convertedToProjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceId?: SortOrder
  }

  export type QuoteSumOrderByAggregateInput = {
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
  }

  export type MaterialCostCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    supplier?: SortOrder
    material?: SortOrder
    quantity?: SortOrder
    unitCost?: SortOrder
    totalCost?: SortOrder
    invoiceRef?: SortOrder
    date?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type MaterialCostAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitCost?: SortOrder
    totalCost?: SortOrder
  }

  export type MaterialCostMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    supplier?: SortOrder
    material?: SortOrder
    quantity?: SortOrder
    unitCost?: SortOrder
    totalCost?: SortOrder
    invoiceRef?: SortOrder
    date?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type MaterialCostMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    supplier?: SortOrder
    material?: SortOrder
    quantity?: SortOrder
    unitCost?: SortOrder
    totalCost?: SortOrder
    invoiceRef?: SortOrder
    date?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type MaterialCostSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitCost?: SortOrder
    totalCost?: SortOrder
  }

  export type SupplierInvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    supplier?: SortOrder
    invoiceRef?: SortOrder
    date?: SortOrder
    totalAmount?: SortOrder
    items?: SortOrder
    fileUrl?: SortOrder
    processed?: SortOrder
    createdAt?: SortOrder
  }

  export type SupplierInvoiceAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type SupplierInvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    supplier?: SortOrder
    invoiceRef?: SortOrder
    date?: SortOrder
    totalAmount?: SortOrder
    fileUrl?: SortOrder
    processed?: SortOrder
    createdAt?: SortOrder
  }

  export type SupplierInvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    supplier?: SortOrder
    invoiceRef?: SortOrder
    date?: SortOrder
    totalAmount?: SortOrder
    fileUrl?: SortOrder
    processed?: SortOrder
    createdAt?: SortOrder
  }

  export type SupplierInvoiceSumOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type ChatSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<ChatSessionCreateWithoutUserInput, ChatSessionUncheckedCreateWithoutUserInput> | ChatSessionCreateWithoutUserInput[] | ChatSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatSessionCreateOrConnectWithoutUserInput | ChatSessionCreateOrConnectWithoutUserInput[]
    createMany?: ChatSessionCreateManyUserInputEnvelope
    connect?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput> | MessageCreateWithoutUserInput[] | MessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUserInput | MessageCreateOrConnectWithoutUserInput[]
    createMany?: MessageCreateManyUserInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type CustomerCreateNestedOneWithoutUserInput = {
    create?: XOR<CustomerCreateWithoutUserInput, CustomerUncheckedCreateWithoutUserInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutUserInput
    connect?: CustomerWhereUniqueInput
  }

  export type CartCreateNestedOneWithoutUserInput = {
    create?: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput>
    connectOrCreate?: CartCreateOrConnectWithoutUserInput
    connect?: CartWhereUniqueInput
  }

  export type ChatSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ChatSessionCreateWithoutUserInput, ChatSessionUncheckedCreateWithoutUserInput> | ChatSessionCreateWithoutUserInput[] | ChatSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatSessionCreateOrConnectWithoutUserInput | ChatSessionCreateOrConnectWithoutUserInput[]
    createMany?: ChatSessionCreateManyUserInputEnvelope
    connect?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput> | MessageCreateWithoutUserInput[] | MessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUserInput | MessageCreateOrConnectWithoutUserInput[]
    createMany?: MessageCreateManyUserInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type CustomerUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<CustomerCreateWithoutUserInput, CustomerUncheckedCreateWithoutUserInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutUserInput
    connect?: CustomerWhereUniqueInput
  }

  export type CartUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput>
    connectOrCreate?: CartCreateOrConnectWithoutUserInput
    connect?: CartWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ChatSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChatSessionCreateWithoutUserInput, ChatSessionUncheckedCreateWithoutUserInput> | ChatSessionCreateWithoutUserInput[] | ChatSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatSessionCreateOrConnectWithoutUserInput | ChatSessionCreateOrConnectWithoutUserInput[]
    upsert?: ChatSessionUpsertWithWhereUniqueWithoutUserInput | ChatSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChatSessionCreateManyUserInputEnvelope
    set?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    disconnect?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    delete?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    connect?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    update?: ChatSessionUpdateWithWhereUniqueWithoutUserInput | ChatSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChatSessionUpdateManyWithWhereWithoutUserInput | ChatSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChatSessionScalarWhereInput | ChatSessionScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput> | MessageCreateWithoutUserInput[] | MessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUserInput | MessageCreateOrConnectWithoutUserInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutUserInput | MessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageCreateManyUserInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutUserInput | MessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutUserInput | MessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type CustomerUpdateOneWithoutUserNestedInput = {
    create?: XOR<CustomerCreateWithoutUserInput, CustomerUncheckedCreateWithoutUserInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutUserInput
    upsert?: CustomerUpsertWithoutUserInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutUserInput, CustomerUpdateWithoutUserInput>, CustomerUncheckedUpdateWithoutUserInput>
  }

  export type CartUpdateOneWithoutUserNestedInput = {
    create?: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput>
    connectOrCreate?: CartCreateOrConnectWithoutUserInput
    upsert?: CartUpsertWithoutUserInput
    disconnect?: CartWhereInput | boolean
    delete?: CartWhereInput | boolean
    connect?: CartWhereUniqueInput
    update?: XOR<XOR<CartUpdateToOneWithWhereWithoutUserInput, CartUpdateWithoutUserInput>, CartUncheckedUpdateWithoutUserInput>
  }

  export type ChatSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChatSessionCreateWithoutUserInput, ChatSessionUncheckedCreateWithoutUserInput> | ChatSessionCreateWithoutUserInput[] | ChatSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatSessionCreateOrConnectWithoutUserInput | ChatSessionCreateOrConnectWithoutUserInput[]
    upsert?: ChatSessionUpsertWithWhereUniqueWithoutUserInput | ChatSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChatSessionCreateManyUserInputEnvelope
    set?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    disconnect?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    delete?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    connect?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    update?: ChatSessionUpdateWithWhereUniqueWithoutUserInput | ChatSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChatSessionUpdateManyWithWhereWithoutUserInput | ChatSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChatSessionScalarWhereInput | ChatSessionScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput> | MessageCreateWithoutUserInput[] | MessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUserInput | MessageCreateOrConnectWithoutUserInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutUserInput | MessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageCreateManyUserInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutUserInput | MessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutUserInput | MessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type CustomerUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<CustomerCreateWithoutUserInput, CustomerUncheckedCreateWithoutUserInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutUserInput
    upsert?: CustomerUpsertWithoutUserInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutUserInput, CustomerUpdateWithoutUserInput>, CustomerUncheckedUpdateWithoutUserInput>
  }

  export type CartUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput>
    connectOrCreate?: CartCreateOrConnectWithoutUserInput
    upsert?: CartUpsertWithoutUserInput
    disconnect?: CartWhereInput | boolean
    delete?: CartWhereInput | boolean
    connect?: CartWhereUniqueInput
    update?: XOR<XOR<CartUpdateToOneWithWhereWithoutUserInput, CartUpdateWithoutUserInput>, CartUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type MessageCreateNestedManyWithoutSessionInput = {
    create?: XOR<MessageCreateWithoutSessionInput, MessageUncheckedCreateWithoutSessionInput> | MessageCreateWithoutSessionInput[] | MessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSessionInput | MessageCreateOrConnectWithoutSessionInput[]
    createMany?: MessageCreateManySessionInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type SessionTagCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionTagCreateWithoutSessionInput, SessionTagUncheckedCreateWithoutSessionInput> | SessionTagCreateWithoutSessionInput[] | SessionTagUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionTagCreateOrConnectWithoutSessionInput | SessionTagCreateOrConnectWithoutSessionInput[]
    createMany?: SessionTagCreateManySessionInputEnvelope
    connect?: SessionTagWhereUniqueInput | SessionTagWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<MessageCreateWithoutSessionInput, MessageUncheckedCreateWithoutSessionInput> | MessageCreateWithoutSessionInput[] | MessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSessionInput | MessageCreateOrConnectWithoutSessionInput[]
    createMany?: MessageCreateManySessionInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type SessionTagUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionTagCreateWithoutSessionInput, SessionTagUncheckedCreateWithoutSessionInput> | SessionTagCreateWithoutSessionInput[] | SessionTagUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionTagCreateOrConnectWithoutSessionInput | SessionTagCreateOrConnectWithoutSessionInput[]
    createMany?: SessionTagCreateManySessionInputEnvelope
    connect?: SessionTagWhereUniqueInput | SessionTagWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type MessageUpdateManyWithoutSessionNestedInput = {
    create?: XOR<MessageCreateWithoutSessionInput, MessageUncheckedCreateWithoutSessionInput> | MessageCreateWithoutSessionInput[] | MessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSessionInput | MessageCreateOrConnectWithoutSessionInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSessionInput | MessageUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: MessageCreateManySessionInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSessionInput | MessageUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSessionInput | MessageUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type SessionTagUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionTagCreateWithoutSessionInput, SessionTagUncheckedCreateWithoutSessionInput> | SessionTagCreateWithoutSessionInput[] | SessionTagUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionTagCreateOrConnectWithoutSessionInput | SessionTagCreateOrConnectWithoutSessionInput[]
    upsert?: SessionTagUpsertWithWhereUniqueWithoutSessionInput | SessionTagUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionTagCreateManySessionInputEnvelope
    set?: SessionTagWhereUniqueInput | SessionTagWhereUniqueInput[]
    disconnect?: SessionTagWhereUniqueInput | SessionTagWhereUniqueInput[]
    delete?: SessionTagWhereUniqueInput | SessionTagWhereUniqueInput[]
    connect?: SessionTagWhereUniqueInput | SessionTagWhereUniqueInput[]
    update?: SessionTagUpdateWithWhereUniqueWithoutSessionInput | SessionTagUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionTagUpdateManyWithWhereWithoutSessionInput | SessionTagUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionTagScalarWhereInput | SessionTagScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<MessageCreateWithoutSessionInput, MessageUncheckedCreateWithoutSessionInput> | MessageCreateWithoutSessionInput[] | MessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSessionInput | MessageCreateOrConnectWithoutSessionInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSessionInput | MessageUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: MessageCreateManySessionInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSessionInput | MessageUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSessionInput | MessageUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type SessionTagUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionTagCreateWithoutSessionInput, SessionTagUncheckedCreateWithoutSessionInput> | SessionTagCreateWithoutSessionInput[] | SessionTagUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionTagCreateOrConnectWithoutSessionInput | SessionTagCreateOrConnectWithoutSessionInput[]
    upsert?: SessionTagUpsertWithWhereUniqueWithoutSessionInput | SessionTagUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionTagCreateManySessionInputEnvelope
    set?: SessionTagWhereUniqueInput | SessionTagWhereUniqueInput[]
    disconnect?: SessionTagWhereUniqueInput | SessionTagWhereUniqueInput[]
    delete?: SessionTagWhereUniqueInput | SessionTagWhereUniqueInput[]
    connect?: SessionTagWhereUniqueInput | SessionTagWhereUniqueInput[]
    update?: SessionTagUpdateWithWhereUniqueWithoutSessionInput | SessionTagUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionTagUpdateManyWithWhereWithoutSessionInput | SessionTagUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionTagScalarWhereInput | SessionTagScalarWhereInput[]
  }

  export type ChatSessionCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ChatSessionCreateWithoutMessagesInput, ChatSessionUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatSessionCreateOrConnectWithoutMessagesInput
    connect?: ChatSessionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMessagesInput = {
    create?: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type ChatSessionUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ChatSessionCreateWithoutMessagesInput, ChatSessionUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatSessionCreateOrConnectWithoutMessagesInput
    upsert?: ChatSessionUpsertWithoutMessagesInput
    connect?: ChatSessionWhereUniqueInput
    update?: XOR<XOR<ChatSessionUpdateToOneWithWhereWithoutMessagesInput, ChatSessionUpdateWithoutMessagesInput>, ChatSessionUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneWithoutMessagesNestedInput = {
    create?: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesInput
    upsert?: UserUpsertWithoutMessagesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessagesInput, UserUpdateWithoutMessagesInput>, UserUncheckedUpdateWithoutMessagesInput>
  }

  export type ChatSessionCreateNestedOneWithoutTagsInput = {
    create?: XOR<ChatSessionCreateWithoutTagsInput, ChatSessionUncheckedCreateWithoutTagsInput>
    connectOrCreate?: ChatSessionCreateOrConnectWithoutTagsInput
    connect?: ChatSessionWhereUniqueInput
  }

  export type ChatSessionUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<ChatSessionCreateWithoutTagsInput, ChatSessionUncheckedCreateWithoutTagsInput>
    connectOrCreate?: ChatSessionCreateOrConnectWithoutTagsInput
    upsert?: ChatSessionUpsertWithoutTagsInput
    connect?: ChatSessionWhereUniqueInput
    update?: XOR<XOR<ChatSessionUpdateToOneWithWhereWithoutTagsInput, ChatSessionUpdateWithoutTagsInput>, ChatSessionUncheckedUpdateWithoutTagsInput>
  }

  export type UserCreateNestedOneWithoutCustomerInput = {
    create?: XOR<UserCreateWithoutCustomerInput, UserUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: UserCreateOrConnectWithoutCustomerInput
    connect?: UserWhereUniqueInput
  }

  export type PaymentMethodCreateNestedManyWithoutCustomerInput = {
    create?: XOR<PaymentMethodCreateWithoutCustomerInput, PaymentMethodUncheckedCreateWithoutCustomerInput> | PaymentMethodCreateWithoutCustomerInput[] | PaymentMethodUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutCustomerInput | PaymentMethodCreateOrConnectWithoutCustomerInput[]
    createMany?: PaymentMethodCreateManyCustomerInputEnvelope
    connect?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SubscriptionCreateWithoutCustomerInput, SubscriptionUncheckedCreateWithoutCustomerInput> | SubscriptionCreateWithoutCustomerInput[] | SubscriptionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutCustomerInput | SubscriptionCreateOrConnectWithoutCustomerInput[]
    createMany?: SubscriptionCreateManyCustomerInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutCustomerInput = {
    create?: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput> | InvoiceCreateWithoutCustomerInput[] | InvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCustomerInput | InvoiceCreateOrConnectWithoutCustomerInput[]
    createMany?: InvoiceCreateManyCustomerInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutClientInput = {
    create?: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput> | ProjectCreateWithoutClientInput[] | ProjectUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutClientInput | ProjectCreateOrConnectWithoutClientInput[]
    createMany?: ProjectCreateManyClientInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type QuoteCreateNestedManyWithoutCustomerInput = {
    create?: XOR<QuoteCreateWithoutCustomerInput, QuoteUncheckedCreateWithoutCustomerInput> | QuoteCreateWithoutCustomerInput[] | QuoteUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutCustomerInput | QuoteCreateOrConnectWithoutCustomerInput[]
    createMany?: QuoteCreateManyCustomerInputEnvelope
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
  }

  export type PaymentMethodUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<PaymentMethodCreateWithoutCustomerInput, PaymentMethodUncheckedCreateWithoutCustomerInput> | PaymentMethodCreateWithoutCustomerInput[] | PaymentMethodUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutCustomerInput | PaymentMethodCreateOrConnectWithoutCustomerInput[]
    createMany?: PaymentMethodCreateManyCustomerInputEnvelope
    connect?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SubscriptionCreateWithoutCustomerInput, SubscriptionUncheckedCreateWithoutCustomerInput> | SubscriptionCreateWithoutCustomerInput[] | SubscriptionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutCustomerInput | SubscriptionCreateOrConnectWithoutCustomerInput[]
    createMany?: SubscriptionCreateManyCustomerInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput> | InvoiceCreateWithoutCustomerInput[] | InvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCustomerInput | InvoiceCreateOrConnectWithoutCustomerInput[]
    createMany?: InvoiceCreateManyCustomerInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput> | ProjectCreateWithoutClientInput[] | ProjectUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutClientInput | ProjectCreateOrConnectWithoutClientInput[]
    createMany?: ProjectCreateManyClientInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type QuoteUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<QuoteCreateWithoutCustomerInput, QuoteUncheckedCreateWithoutCustomerInput> | QuoteCreateWithoutCustomerInput[] | QuoteUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutCustomerInput | QuoteCreateOrConnectWithoutCustomerInput[]
    createMany?: QuoteCreateManyCustomerInputEnvelope
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutCustomerNestedInput = {
    create?: XOR<UserCreateWithoutCustomerInput, UserUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: UserCreateOrConnectWithoutCustomerInput
    upsert?: UserUpsertWithoutCustomerInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCustomerInput, UserUpdateWithoutCustomerInput>, UserUncheckedUpdateWithoutCustomerInput>
  }

  export type PaymentMethodUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<PaymentMethodCreateWithoutCustomerInput, PaymentMethodUncheckedCreateWithoutCustomerInput> | PaymentMethodCreateWithoutCustomerInput[] | PaymentMethodUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutCustomerInput | PaymentMethodCreateOrConnectWithoutCustomerInput[]
    upsert?: PaymentMethodUpsertWithWhereUniqueWithoutCustomerInput | PaymentMethodUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: PaymentMethodCreateManyCustomerInputEnvelope
    set?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    disconnect?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    delete?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    connect?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    update?: PaymentMethodUpdateWithWhereUniqueWithoutCustomerInput | PaymentMethodUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: PaymentMethodUpdateManyWithWhereWithoutCustomerInput | PaymentMethodUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: PaymentMethodScalarWhereInput | PaymentMethodScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCustomerInput | OrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCustomerInput | OrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCustomerInput | OrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type SubscriptionUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SubscriptionCreateWithoutCustomerInput, SubscriptionUncheckedCreateWithoutCustomerInput> | SubscriptionCreateWithoutCustomerInput[] | SubscriptionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutCustomerInput | SubscriptionCreateOrConnectWithoutCustomerInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutCustomerInput | SubscriptionUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SubscriptionCreateManyCustomerInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutCustomerInput | SubscriptionUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutCustomerInput | SubscriptionUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput> | InvoiceCreateWithoutCustomerInput[] | InvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCustomerInput | InvoiceCreateOrConnectWithoutCustomerInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutCustomerInput | InvoiceUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: InvoiceCreateManyCustomerInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutCustomerInput | InvoiceUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutCustomerInput | InvoiceUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutClientNestedInput = {
    create?: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput> | ProjectCreateWithoutClientInput[] | ProjectUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutClientInput | ProjectCreateOrConnectWithoutClientInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutClientInput | ProjectUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ProjectCreateManyClientInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutClientInput | ProjectUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutClientInput | ProjectUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type QuoteUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<QuoteCreateWithoutCustomerInput, QuoteUncheckedCreateWithoutCustomerInput> | QuoteCreateWithoutCustomerInput[] | QuoteUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutCustomerInput | QuoteCreateOrConnectWithoutCustomerInput[]
    upsert?: QuoteUpsertWithWhereUniqueWithoutCustomerInput | QuoteUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: QuoteCreateManyCustomerInputEnvelope
    set?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    disconnect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    delete?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    update?: QuoteUpdateWithWhereUniqueWithoutCustomerInput | QuoteUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: QuoteUpdateManyWithWhereWithoutCustomerInput | QuoteUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
  }

  export type PaymentMethodUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<PaymentMethodCreateWithoutCustomerInput, PaymentMethodUncheckedCreateWithoutCustomerInput> | PaymentMethodCreateWithoutCustomerInput[] | PaymentMethodUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutCustomerInput | PaymentMethodCreateOrConnectWithoutCustomerInput[]
    upsert?: PaymentMethodUpsertWithWhereUniqueWithoutCustomerInput | PaymentMethodUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: PaymentMethodCreateManyCustomerInputEnvelope
    set?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    disconnect?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    delete?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    connect?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    update?: PaymentMethodUpdateWithWhereUniqueWithoutCustomerInput | PaymentMethodUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: PaymentMethodUpdateManyWithWhereWithoutCustomerInput | PaymentMethodUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: PaymentMethodScalarWhereInput | PaymentMethodScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCustomerInput | OrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCustomerInput | OrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCustomerInput | OrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SubscriptionCreateWithoutCustomerInput, SubscriptionUncheckedCreateWithoutCustomerInput> | SubscriptionCreateWithoutCustomerInput[] | SubscriptionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutCustomerInput | SubscriptionCreateOrConnectWithoutCustomerInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutCustomerInput | SubscriptionUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SubscriptionCreateManyCustomerInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutCustomerInput | SubscriptionUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutCustomerInput | SubscriptionUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput> | InvoiceCreateWithoutCustomerInput[] | InvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCustomerInput | InvoiceCreateOrConnectWithoutCustomerInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutCustomerInput | InvoiceUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: InvoiceCreateManyCustomerInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutCustomerInput | InvoiceUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutCustomerInput | InvoiceUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput> | ProjectCreateWithoutClientInput[] | ProjectUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutClientInput | ProjectCreateOrConnectWithoutClientInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutClientInput | ProjectUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ProjectCreateManyClientInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutClientInput | ProjectUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutClientInput | ProjectUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type QuoteUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<QuoteCreateWithoutCustomerInput, QuoteUncheckedCreateWithoutCustomerInput> | QuoteCreateWithoutCustomerInput[] | QuoteUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutCustomerInput | QuoteCreateOrConnectWithoutCustomerInput[]
    upsert?: QuoteUpsertWithWhereUniqueWithoutCustomerInput | QuoteUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: QuoteCreateManyCustomerInputEnvelope
    set?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    disconnect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    delete?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    update?: QuoteUpdateWithWhereUniqueWithoutCustomerInput | QuoteUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: QuoteUpdateManyWithWhereWithoutCustomerInput | QuoteUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
  }

  export type InventoryCreateNestedManyWithoutProductInput = {
    create?: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput> | InventoryCreateWithoutProductInput[] | InventoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutProductInput | InventoryCreateOrConnectWithoutProductInput[]
    createMany?: InventoryCreateManyProductInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type OrderItemCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type CartItemCreateNestedManyWithoutProductInput = {
    create?: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput> | CartItemCreateWithoutProductInput[] | CartItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductInput | CartItemCreateOrConnectWithoutProductInput[]
    createMany?: CartItemCreateManyProductInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type PriceHistoryCreateNestedManyWithoutProductInput = {
    create?: XOR<PriceHistoryCreateWithoutProductInput, PriceHistoryUncheckedCreateWithoutProductInput> | PriceHistoryCreateWithoutProductInput[] | PriceHistoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PriceHistoryCreateOrConnectWithoutProductInput | PriceHistoryCreateOrConnectWithoutProductInput[]
    createMany?: PriceHistoryCreateManyProductInputEnvelope
    connect?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
  }

  export type InventoryUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput> | InventoryCreateWithoutProductInput[] | InventoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutProductInput | InventoryCreateOrConnectWithoutProductInput[]
    createMany?: InventoryCreateManyProductInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type CartItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput> | CartItemCreateWithoutProductInput[] | CartItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductInput | CartItemCreateOrConnectWithoutProductInput[]
    createMany?: CartItemCreateManyProductInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type PriceHistoryUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<PriceHistoryCreateWithoutProductInput, PriceHistoryUncheckedCreateWithoutProductInput> | PriceHistoryCreateWithoutProductInput[] | PriceHistoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PriceHistoryCreateOrConnectWithoutProductInput | PriceHistoryCreateOrConnectWithoutProductInput[]
    createMany?: PriceHistoryCreateManyProductInputEnvelope
    connect?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type InventoryUpdateManyWithoutProductNestedInput = {
    create?: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput> | InventoryCreateWithoutProductInput[] | InventoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutProductInput | InventoryCreateOrConnectWithoutProductInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutProductInput | InventoryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: InventoryCreateManyProductInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutProductInput | InventoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutProductInput | InventoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type OrderItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type CartItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput> | CartItemCreateWithoutProductInput[] | CartItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductInput | CartItemCreateOrConnectWithoutProductInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutProductInput | CartItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CartItemCreateManyProductInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutProductInput | CartItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutProductInput | CartItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type PriceHistoryUpdateManyWithoutProductNestedInput = {
    create?: XOR<PriceHistoryCreateWithoutProductInput, PriceHistoryUncheckedCreateWithoutProductInput> | PriceHistoryCreateWithoutProductInput[] | PriceHistoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PriceHistoryCreateOrConnectWithoutProductInput | PriceHistoryCreateOrConnectWithoutProductInput[]
    upsert?: PriceHistoryUpsertWithWhereUniqueWithoutProductInput | PriceHistoryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PriceHistoryCreateManyProductInputEnvelope
    set?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
    disconnect?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
    delete?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
    connect?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
    update?: PriceHistoryUpdateWithWhereUniqueWithoutProductInput | PriceHistoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PriceHistoryUpdateManyWithWhereWithoutProductInput | PriceHistoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PriceHistoryScalarWhereInput | PriceHistoryScalarWhereInput[]
  }

  export type InventoryUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput> | InventoryCreateWithoutProductInput[] | InventoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutProductInput | InventoryCreateOrConnectWithoutProductInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutProductInput | InventoryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: InventoryCreateManyProductInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutProductInput | InventoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutProductInput | InventoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type CartItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput> | CartItemCreateWithoutProductInput[] | CartItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductInput | CartItemCreateOrConnectWithoutProductInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutProductInput | CartItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CartItemCreateManyProductInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutProductInput | CartItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutProductInput | CartItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type PriceHistoryUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<PriceHistoryCreateWithoutProductInput, PriceHistoryUncheckedCreateWithoutProductInput> | PriceHistoryCreateWithoutProductInput[] | PriceHistoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PriceHistoryCreateOrConnectWithoutProductInput | PriceHistoryCreateOrConnectWithoutProductInput[]
    upsert?: PriceHistoryUpsertWithWhereUniqueWithoutProductInput | PriceHistoryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PriceHistoryCreateManyProductInputEnvelope
    set?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
    disconnect?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
    delete?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
    connect?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
    update?: PriceHistoryUpdateWithWhereUniqueWithoutProductInput | PriceHistoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PriceHistoryUpdateManyWithWhereWithoutProductInput | PriceHistoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PriceHistoryScalarWhereInput | PriceHistoryScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutOrdersInput = {
    create?: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOrdersInput
    connect?: CustomerWhereUniqueInput
  }

  export type OrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type InvoiceCreateNestedOneWithoutOrderInput = {
    create?: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutOrderInput
    connect?: InvoiceWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutOrderInput = {
    create?: XOR<ProjectCreateWithoutOrderInput, ProjectUncheckedCreateWithoutOrderInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutOrderInput
    connect?: ProjectWhereUniqueInput
  }

  export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedOneWithoutOrderInput = {
    create?: XOR<ProjectCreateWithoutOrderInput, ProjectUncheckedCreateWithoutOrderInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutOrderInput
    connect?: ProjectWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOrdersInput
    upsert?: CustomerUpsertWithoutOrdersInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutOrdersInput, CustomerUpdateWithoutOrdersInput>, CustomerUncheckedUpdateWithoutOrdersInput>
  }

  export type OrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type InvoiceUpdateOneWithoutOrderNestedInput = {
    create?: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutOrderInput
    upsert?: InvoiceUpsertWithoutOrderInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutOrderInput, InvoiceUpdateWithoutOrderInput>, InvoiceUncheckedUpdateWithoutOrderInput>
  }

  export type ProjectUpdateOneWithoutOrderNestedInput = {
    create?: XOR<ProjectCreateWithoutOrderInput, ProjectUncheckedCreateWithoutOrderInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutOrderInput
    upsert?: ProjectUpsertWithoutOrderInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutOrderInput, ProjectUpdateWithoutOrderInput>, ProjectUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateOneWithoutOrderNestedInput = {
    create?: XOR<ProjectCreateWithoutOrderInput, ProjectUncheckedCreateWithoutOrderInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutOrderInput
    upsert?: ProjectUpsertWithoutOrderInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutOrderInput, ProjectUpdateWithoutOrderInput>, ProjectUncheckedUpdateWithoutOrderInput>
  }

  export type OrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    connect?: OrderWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    upsert?: OrderUpsertWithoutItemsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutItemsInput, OrderUpdateWithoutItemsInput>, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemsInput
    upsert?: ProductUpsertWithoutOrderItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutOrderItemsInput, ProductUpdateWithoutOrderItemsInput>, ProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type CustomerCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<CustomerCreateWithoutSubscriptionsInput, CustomerUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSubscriptionsInput
    connect?: CustomerWhereUniqueInput
  }

  export type SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<SubscriptionPlanCreateWithoutSubscriptionsInput, SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: SubscriptionPlanCreateOrConnectWithoutSubscriptionsInput
    connect?: SubscriptionPlanWhereUniqueInput
  }

  export type InvoiceCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<InvoiceCreateWithoutSubscriptionInput, InvoiceUncheckedCreateWithoutSubscriptionInput> | InvoiceCreateWithoutSubscriptionInput[] | InvoiceUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSubscriptionInput | InvoiceCreateOrConnectWithoutSubscriptionInput[]
    createMany?: InvoiceCreateManySubscriptionInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<InvoiceCreateWithoutSubscriptionInput, InvoiceUncheckedCreateWithoutSubscriptionInput> | InvoiceCreateWithoutSubscriptionInput[] | InvoiceUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSubscriptionInput | InvoiceCreateOrConnectWithoutSubscriptionInput[]
    createMany?: InvoiceCreateManySubscriptionInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type CustomerUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<CustomerCreateWithoutSubscriptionsInput, CustomerUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSubscriptionsInput
    upsert?: CustomerUpsertWithoutSubscriptionsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutSubscriptionsInput, CustomerUpdateWithoutSubscriptionsInput>, CustomerUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<SubscriptionPlanCreateWithoutSubscriptionsInput, SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: SubscriptionPlanCreateOrConnectWithoutSubscriptionsInput
    upsert?: SubscriptionPlanUpsertWithoutSubscriptionsInput
    connect?: SubscriptionPlanWhereUniqueInput
    update?: XOR<XOR<SubscriptionPlanUpdateToOneWithWhereWithoutSubscriptionsInput, SubscriptionPlanUpdateWithoutSubscriptionsInput>, SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type InvoiceUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<InvoiceCreateWithoutSubscriptionInput, InvoiceUncheckedCreateWithoutSubscriptionInput> | InvoiceCreateWithoutSubscriptionInput[] | InvoiceUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSubscriptionInput | InvoiceCreateOrConnectWithoutSubscriptionInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutSubscriptionInput | InvoiceUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: InvoiceCreateManySubscriptionInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutSubscriptionInput | InvoiceUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutSubscriptionInput | InvoiceUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<InvoiceCreateWithoutSubscriptionInput, InvoiceUncheckedCreateWithoutSubscriptionInput> | InvoiceCreateWithoutSubscriptionInput[] | InvoiceUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSubscriptionInput | InvoiceCreateOrConnectWithoutSubscriptionInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutSubscriptionInput | InvoiceUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: InvoiceCreateManySubscriptionInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutSubscriptionInput | InvoiceUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutSubscriptionInput | InvoiceUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type SubscriptionCreateNestedManyWithoutPlanInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type SubscriptionUpdateManyWithoutPlanNestedInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutPlanInput | SubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutPlanInput | SubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutPlanInput | SubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutPlanInput | SubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutPlanInput | SubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutPlanInput | SubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<CustomerCreateWithoutInvoicesInput, CustomerUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutInvoicesInput
    connect?: CustomerWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<OrderCreateWithoutInvoiceInput, OrderUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: OrderCreateOrConnectWithoutInvoiceInput
    connect?: OrderWhereUniqueInput
  }

  export type SubscriptionCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<SubscriptionCreateWithoutInvoicesInput, SubscriptionUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutInvoicesInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type OrderUncheckedCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<OrderCreateWithoutInvoiceInput, OrderUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: OrderCreateOrConnectWithoutInvoiceInput
    connect?: OrderWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<CustomerCreateWithoutInvoicesInput, CustomerUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutInvoicesInput
    upsert?: CustomerUpsertWithoutInvoicesInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutInvoicesInput, CustomerUpdateWithoutInvoicesInput>, CustomerUncheckedUpdateWithoutInvoicesInput>
  }

  export type OrderUpdateOneWithoutInvoiceNestedInput = {
    create?: XOR<OrderCreateWithoutInvoiceInput, OrderUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: OrderCreateOrConnectWithoutInvoiceInput
    upsert?: OrderUpsertWithoutInvoiceInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutInvoiceInput, OrderUpdateWithoutInvoiceInput>, OrderUncheckedUpdateWithoutInvoiceInput>
  }

  export type SubscriptionUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<SubscriptionCreateWithoutInvoicesInput, SubscriptionUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutInvoicesInput
    upsert?: SubscriptionUpsertWithoutInvoicesInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutInvoicesInput, SubscriptionUpdateWithoutInvoicesInput>, SubscriptionUncheckedUpdateWithoutInvoicesInput>
  }

  export type OrderUncheckedUpdateOneWithoutInvoiceNestedInput = {
    create?: XOR<OrderCreateWithoutInvoiceInput, OrderUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: OrderCreateOrConnectWithoutInvoiceInput
    upsert?: OrderUpsertWithoutInvoiceInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutInvoiceInput, OrderUpdateWithoutInvoiceInput>, OrderUncheckedUpdateWithoutInvoiceInput>
  }

  export type CustomerCreateNestedOneWithoutPaymentMethodsInput = {
    create?: XOR<CustomerCreateWithoutPaymentMethodsInput, CustomerUncheckedCreateWithoutPaymentMethodsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPaymentMethodsInput
    connect?: CustomerWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CustomerUpdateOneRequiredWithoutPaymentMethodsNestedInput = {
    create?: XOR<CustomerCreateWithoutPaymentMethodsInput, CustomerUncheckedCreateWithoutPaymentMethodsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPaymentMethodsInput
    upsert?: CustomerUpsertWithoutPaymentMethodsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutPaymentMethodsInput, CustomerUpdateWithoutPaymentMethodsInput>, CustomerUncheckedUpdateWithoutPaymentMethodsInput>
  }

  export type ProductCreateNestedOneWithoutInventoryItemsInput = {
    create?: XOR<ProductCreateWithoutInventoryItemsInput, ProductUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutInventoryItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutInventoryItemsNestedInput = {
    create?: XOR<ProductCreateWithoutInventoryItemsInput, ProductUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutInventoryItemsInput
    upsert?: ProductUpsertWithoutInventoryItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutInventoryItemsInput, ProductUpdateWithoutInventoryItemsInput>, ProductUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type UserCreateNestedOneWithoutCartInput = {
    create?: XOR<UserCreateWithoutCartInput, UserUncheckedCreateWithoutCartInput>
    connectOrCreate?: UserCreateOrConnectWithoutCartInput
    connect?: UserWhereUniqueInput
  }

  export type CartItemCreateNestedManyWithoutCartInput = {
    create?: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput> | CartItemCreateWithoutCartInput[] | CartItemUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutCartInput | CartItemCreateOrConnectWithoutCartInput[]
    createMany?: CartItemCreateManyCartInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type CartItemUncheckedCreateNestedManyWithoutCartInput = {
    create?: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput> | CartItemCreateWithoutCartInput[] | CartItemUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutCartInput | CartItemCreateOrConnectWithoutCartInput[]
    createMany?: CartItemCreateManyCartInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutCartNestedInput = {
    create?: XOR<UserCreateWithoutCartInput, UserUncheckedCreateWithoutCartInput>
    connectOrCreate?: UserCreateOrConnectWithoutCartInput
    upsert?: UserUpsertWithoutCartInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCartInput, UserUpdateWithoutCartInput>, UserUncheckedUpdateWithoutCartInput>
  }

  export type CartItemUpdateManyWithoutCartNestedInput = {
    create?: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput> | CartItemCreateWithoutCartInput[] | CartItemUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutCartInput | CartItemCreateOrConnectWithoutCartInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutCartInput | CartItemUpsertWithWhereUniqueWithoutCartInput[]
    createMany?: CartItemCreateManyCartInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutCartInput | CartItemUpdateWithWhereUniqueWithoutCartInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutCartInput | CartItemUpdateManyWithWhereWithoutCartInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type CartItemUncheckedUpdateManyWithoutCartNestedInput = {
    create?: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput> | CartItemCreateWithoutCartInput[] | CartItemUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutCartInput | CartItemCreateOrConnectWithoutCartInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutCartInput | CartItemUpsertWithWhereUniqueWithoutCartInput[]
    createMany?: CartItemCreateManyCartInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutCartInput | CartItemUpdateWithWhereUniqueWithoutCartInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutCartInput | CartItemUpdateManyWithWhereWithoutCartInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type CartCreateNestedOneWithoutItemsInput = {
    create?: XOR<CartCreateWithoutItemsInput, CartUncheckedCreateWithoutItemsInput>
    connectOrCreate?: CartCreateOrConnectWithoutItemsInput
    connect?: CartWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutCartItemsInput = {
    create?: XOR<ProductCreateWithoutCartItemsInput, ProductUncheckedCreateWithoutCartItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCartItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type CartUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<CartCreateWithoutItemsInput, CartUncheckedCreateWithoutItemsInput>
    connectOrCreate?: CartCreateOrConnectWithoutItemsInput
    upsert?: CartUpsertWithoutItemsInput
    connect?: CartWhereUniqueInput
    update?: XOR<XOR<CartUpdateToOneWithWhereWithoutItemsInput, CartUpdateWithoutItemsInput>, CartUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutCartItemsNestedInput = {
    create?: XOR<ProductCreateWithoutCartItemsInput, ProductUncheckedCreateWithoutCartItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCartItemsInput
    upsert?: ProductUpsertWithoutCartItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutCartItemsInput, ProductUpdateWithoutCartItemsInput>, ProductUncheckedUpdateWithoutCartItemsInput>
  }

  export type ProductCreateNestedOneWithoutPriceHistoryInput = {
    create?: XOR<ProductCreateWithoutPriceHistoryInput, ProductUncheckedCreateWithoutPriceHistoryInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPriceHistoryInput
    connect?: ProductWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProductUpdateOneRequiredWithoutPriceHistoryNestedInput = {
    create?: XOR<ProductCreateWithoutPriceHistoryInput, ProductUncheckedCreateWithoutPriceHistoryInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPriceHistoryInput
    upsert?: ProductUpsertWithoutPriceHistoryInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutPriceHistoryInput, ProductUpdateWithoutPriceHistoryInput>, ProductUncheckedUpdateWithoutPriceHistoryInput>
  }

  export type QuizResponseCreateNestedManyWithoutSessionInput = {
    create?: XOR<QuizResponseCreateWithoutSessionInput, QuizResponseUncheckedCreateWithoutSessionInput> | QuizResponseCreateWithoutSessionInput[] | QuizResponseUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: QuizResponseCreateOrConnectWithoutSessionInput | QuizResponseCreateOrConnectWithoutSessionInput[]
    createMany?: QuizResponseCreateManySessionInputEnvelope
    connect?: QuizResponseWhereUniqueInput | QuizResponseWhereUniqueInput[]
  }

  export type BehavioralInteractionCreateNestedManyWithoutSessionInput = {
    create?: XOR<BehavioralInteractionCreateWithoutSessionInput, BehavioralInteractionUncheckedCreateWithoutSessionInput> | BehavioralInteractionCreateWithoutSessionInput[] | BehavioralInteractionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: BehavioralInteractionCreateOrConnectWithoutSessionInput | BehavioralInteractionCreateOrConnectWithoutSessionInput[]
    createMany?: BehavioralInteractionCreateManySessionInputEnvelope
    connect?: BehavioralInteractionWhereUniqueInput | BehavioralInteractionWhereUniqueInput[]
  }

  export type QuizConversionCreateNestedManyWithoutSessionInput = {
    create?: XOR<QuizConversionCreateWithoutSessionInput, QuizConversionUncheckedCreateWithoutSessionInput> | QuizConversionCreateWithoutSessionInput[] | QuizConversionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: QuizConversionCreateOrConnectWithoutSessionInput | QuizConversionCreateOrConnectWithoutSessionInput[]
    createMany?: QuizConversionCreateManySessionInputEnvelope
    connect?: QuizConversionWhereUniqueInput | QuizConversionWhereUniqueInput[]
  }

  export type QuizResponseUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<QuizResponseCreateWithoutSessionInput, QuizResponseUncheckedCreateWithoutSessionInput> | QuizResponseCreateWithoutSessionInput[] | QuizResponseUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: QuizResponseCreateOrConnectWithoutSessionInput | QuizResponseCreateOrConnectWithoutSessionInput[]
    createMany?: QuizResponseCreateManySessionInputEnvelope
    connect?: QuizResponseWhereUniqueInput | QuizResponseWhereUniqueInput[]
  }

  export type BehavioralInteractionUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<BehavioralInteractionCreateWithoutSessionInput, BehavioralInteractionUncheckedCreateWithoutSessionInput> | BehavioralInteractionCreateWithoutSessionInput[] | BehavioralInteractionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: BehavioralInteractionCreateOrConnectWithoutSessionInput | BehavioralInteractionCreateOrConnectWithoutSessionInput[]
    createMany?: BehavioralInteractionCreateManySessionInputEnvelope
    connect?: BehavioralInteractionWhereUniqueInput | BehavioralInteractionWhereUniqueInput[]
  }

  export type QuizConversionUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<QuizConversionCreateWithoutSessionInput, QuizConversionUncheckedCreateWithoutSessionInput> | QuizConversionCreateWithoutSessionInput[] | QuizConversionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: QuizConversionCreateOrConnectWithoutSessionInput | QuizConversionCreateOrConnectWithoutSessionInput[]
    createMany?: QuizConversionCreateManySessionInputEnvelope
    connect?: QuizConversionWhereUniqueInput | QuizConversionWhereUniqueInput[]
  }

  export type QuizResponseUpdateManyWithoutSessionNestedInput = {
    create?: XOR<QuizResponseCreateWithoutSessionInput, QuizResponseUncheckedCreateWithoutSessionInput> | QuizResponseCreateWithoutSessionInput[] | QuizResponseUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: QuizResponseCreateOrConnectWithoutSessionInput | QuizResponseCreateOrConnectWithoutSessionInput[]
    upsert?: QuizResponseUpsertWithWhereUniqueWithoutSessionInput | QuizResponseUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: QuizResponseCreateManySessionInputEnvelope
    set?: QuizResponseWhereUniqueInput | QuizResponseWhereUniqueInput[]
    disconnect?: QuizResponseWhereUniqueInput | QuizResponseWhereUniqueInput[]
    delete?: QuizResponseWhereUniqueInput | QuizResponseWhereUniqueInput[]
    connect?: QuizResponseWhereUniqueInput | QuizResponseWhereUniqueInput[]
    update?: QuizResponseUpdateWithWhereUniqueWithoutSessionInput | QuizResponseUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: QuizResponseUpdateManyWithWhereWithoutSessionInput | QuizResponseUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: QuizResponseScalarWhereInput | QuizResponseScalarWhereInput[]
  }

  export type BehavioralInteractionUpdateManyWithoutSessionNestedInput = {
    create?: XOR<BehavioralInteractionCreateWithoutSessionInput, BehavioralInteractionUncheckedCreateWithoutSessionInput> | BehavioralInteractionCreateWithoutSessionInput[] | BehavioralInteractionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: BehavioralInteractionCreateOrConnectWithoutSessionInput | BehavioralInteractionCreateOrConnectWithoutSessionInput[]
    upsert?: BehavioralInteractionUpsertWithWhereUniqueWithoutSessionInput | BehavioralInteractionUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: BehavioralInteractionCreateManySessionInputEnvelope
    set?: BehavioralInteractionWhereUniqueInput | BehavioralInteractionWhereUniqueInput[]
    disconnect?: BehavioralInteractionWhereUniqueInput | BehavioralInteractionWhereUniqueInput[]
    delete?: BehavioralInteractionWhereUniqueInput | BehavioralInteractionWhereUniqueInput[]
    connect?: BehavioralInteractionWhereUniqueInput | BehavioralInteractionWhereUniqueInput[]
    update?: BehavioralInteractionUpdateWithWhereUniqueWithoutSessionInput | BehavioralInteractionUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: BehavioralInteractionUpdateManyWithWhereWithoutSessionInput | BehavioralInteractionUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: BehavioralInteractionScalarWhereInput | BehavioralInteractionScalarWhereInput[]
  }

  export type QuizConversionUpdateManyWithoutSessionNestedInput = {
    create?: XOR<QuizConversionCreateWithoutSessionInput, QuizConversionUncheckedCreateWithoutSessionInput> | QuizConversionCreateWithoutSessionInput[] | QuizConversionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: QuizConversionCreateOrConnectWithoutSessionInput | QuizConversionCreateOrConnectWithoutSessionInput[]
    upsert?: QuizConversionUpsertWithWhereUniqueWithoutSessionInput | QuizConversionUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: QuizConversionCreateManySessionInputEnvelope
    set?: QuizConversionWhereUniqueInput | QuizConversionWhereUniqueInput[]
    disconnect?: QuizConversionWhereUniqueInput | QuizConversionWhereUniqueInput[]
    delete?: QuizConversionWhereUniqueInput | QuizConversionWhereUniqueInput[]
    connect?: QuizConversionWhereUniqueInput | QuizConversionWhereUniqueInput[]
    update?: QuizConversionUpdateWithWhereUniqueWithoutSessionInput | QuizConversionUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: QuizConversionUpdateManyWithWhereWithoutSessionInput | QuizConversionUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: QuizConversionScalarWhereInput | QuizConversionScalarWhereInput[]
  }

  export type QuizResponseUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<QuizResponseCreateWithoutSessionInput, QuizResponseUncheckedCreateWithoutSessionInput> | QuizResponseCreateWithoutSessionInput[] | QuizResponseUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: QuizResponseCreateOrConnectWithoutSessionInput | QuizResponseCreateOrConnectWithoutSessionInput[]
    upsert?: QuizResponseUpsertWithWhereUniqueWithoutSessionInput | QuizResponseUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: QuizResponseCreateManySessionInputEnvelope
    set?: QuizResponseWhereUniqueInput | QuizResponseWhereUniqueInput[]
    disconnect?: QuizResponseWhereUniqueInput | QuizResponseWhereUniqueInput[]
    delete?: QuizResponseWhereUniqueInput | QuizResponseWhereUniqueInput[]
    connect?: QuizResponseWhereUniqueInput | QuizResponseWhereUniqueInput[]
    update?: QuizResponseUpdateWithWhereUniqueWithoutSessionInput | QuizResponseUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: QuizResponseUpdateManyWithWhereWithoutSessionInput | QuizResponseUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: QuizResponseScalarWhereInput | QuizResponseScalarWhereInput[]
  }

  export type BehavioralInteractionUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<BehavioralInteractionCreateWithoutSessionInput, BehavioralInteractionUncheckedCreateWithoutSessionInput> | BehavioralInteractionCreateWithoutSessionInput[] | BehavioralInteractionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: BehavioralInteractionCreateOrConnectWithoutSessionInput | BehavioralInteractionCreateOrConnectWithoutSessionInput[]
    upsert?: BehavioralInteractionUpsertWithWhereUniqueWithoutSessionInput | BehavioralInteractionUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: BehavioralInteractionCreateManySessionInputEnvelope
    set?: BehavioralInteractionWhereUniqueInput | BehavioralInteractionWhereUniqueInput[]
    disconnect?: BehavioralInteractionWhereUniqueInput | BehavioralInteractionWhereUniqueInput[]
    delete?: BehavioralInteractionWhereUniqueInput | BehavioralInteractionWhereUniqueInput[]
    connect?: BehavioralInteractionWhereUniqueInput | BehavioralInteractionWhereUniqueInput[]
    update?: BehavioralInteractionUpdateWithWhereUniqueWithoutSessionInput | BehavioralInteractionUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: BehavioralInteractionUpdateManyWithWhereWithoutSessionInput | BehavioralInteractionUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: BehavioralInteractionScalarWhereInput | BehavioralInteractionScalarWhereInput[]
  }

  export type QuizConversionUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<QuizConversionCreateWithoutSessionInput, QuizConversionUncheckedCreateWithoutSessionInput> | QuizConversionCreateWithoutSessionInput[] | QuizConversionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: QuizConversionCreateOrConnectWithoutSessionInput | QuizConversionCreateOrConnectWithoutSessionInput[]
    upsert?: QuizConversionUpsertWithWhereUniqueWithoutSessionInput | QuizConversionUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: QuizConversionCreateManySessionInputEnvelope
    set?: QuizConversionWhereUniqueInput | QuizConversionWhereUniqueInput[]
    disconnect?: QuizConversionWhereUniqueInput | QuizConversionWhereUniqueInput[]
    delete?: QuizConversionWhereUniqueInput | QuizConversionWhereUniqueInput[]
    connect?: QuizConversionWhereUniqueInput | QuizConversionWhereUniqueInput[]
    update?: QuizConversionUpdateWithWhereUniqueWithoutSessionInput | QuizConversionUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: QuizConversionUpdateManyWithWhereWithoutSessionInput | QuizConversionUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: QuizConversionScalarWhereInput | QuizConversionScalarWhereInput[]
  }

  export type QuizSessionCreateNestedOneWithoutResponsesInput = {
    create?: XOR<QuizSessionCreateWithoutResponsesInput, QuizSessionUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: QuizSessionCreateOrConnectWithoutResponsesInput
    connect?: QuizSessionWhereUniqueInput
  }

  export type QuizSessionUpdateOneRequiredWithoutResponsesNestedInput = {
    create?: XOR<QuizSessionCreateWithoutResponsesInput, QuizSessionUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: QuizSessionCreateOrConnectWithoutResponsesInput
    upsert?: QuizSessionUpsertWithoutResponsesInput
    connect?: QuizSessionWhereUniqueInput
    update?: XOR<XOR<QuizSessionUpdateToOneWithWhereWithoutResponsesInput, QuizSessionUpdateWithoutResponsesInput>, QuizSessionUncheckedUpdateWithoutResponsesInput>
  }

  export type QuizSessionCreateNestedOneWithoutInteractionsInput = {
    create?: XOR<QuizSessionCreateWithoutInteractionsInput, QuizSessionUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: QuizSessionCreateOrConnectWithoutInteractionsInput
    connect?: QuizSessionWhereUniqueInput
  }

  export type QuizSessionUpdateOneRequiredWithoutInteractionsNestedInput = {
    create?: XOR<QuizSessionCreateWithoutInteractionsInput, QuizSessionUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: QuizSessionCreateOrConnectWithoutInteractionsInput
    upsert?: QuizSessionUpsertWithoutInteractionsInput
    connect?: QuizSessionWhereUniqueInput
    update?: XOR<XOR<QuizSessionUpdateToOneWithWhereWithoutInteractionsInput, QuizSessionUpdateWithoutInteractionsInput>, QuizSessionUncheckedUpdateWithoutInteractionsInput>
  }

  export type QuizSessionCreateNestedOneWithoutConversionsInput = {
    create?: XOR<QuizSessionCreateWithoutConversionsInput, QuizSessionUncheckedCreateWithoutConversionsInput>
    connectOrCreate?: QuizSessionCreateOrConnectWithoutConversionsInput
    connect?: QuizSessionWhereUniqueInput
  }

  export type QuizSessionUpdateOneRequiredWithoutConversionsNestedInput = {
    create?: XOR<QuizSessionCreateWithoutConversionsInput, QuizSessionUncheckedCreateWithoutConversionsInput>
    connectOrCreate?: QuizSessionCreateOrConnectWithoutConversionsInput
    upsert?: QuizSessionUpsertWithoutConversionsInput
    connect?: QuizSessionWhereUniqueInput
    update?: XOR<XOR<QuizSessionUpdateToOneWithWhereWithoutConversionsInput, QuizSessionUpdateWithoutConversionsInput>, QuizSessionUncheckedUpdateWithoutConversionsInput>
  }

  export type ProjectCreateNestedManyWithoutServiceInput = {
    create?: XOR<ProjectCreateWithoutServiceInput, ProjectUncheckedCreateWithoutServiceInput> | ProjectCreateWithoutServiceInput[] | ProjectUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutServiceInput | ProjectCreateOrConnectWithoutServiceInput[]
    createMany?: ProjectCreateManyServiceInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type QuoteCreateNestedManyWithoutServiceInput = {
    create?: XOR<QuoteCreateWithoutServiceInput, QuoteUncheckedCreateWithoutServiceInput> | QuoteCreateWithoutServiceInput[] | QuoteUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutServiceInput | QuoteCreateOrConnectWithoutServiceInput[]
    createMany?: QuoteCreateManyServiceInputEnvelope
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<ProjectCreateWithoutServiceInput, ProjectUncheckedCreateWithoutServiceInput> | ProjectCreateWithoutServiceInput[] | ProjectUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutServiceInput | ProjectCreateOrConnectWithoutServiceInput[]
    createMany?: ProjectCreateManyServiceInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type QuoteUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<QuoteCreateWithoutServiceInput, QuoteUncheckedCreateWithoutServiceInput> | QuoteCreateWithoutServiceInput[] | QuoteUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutServiceInput | QuoteCreateOrConnectWithoutServiceInput[]
    createMany?: QuoteCreateManyServiceInputEnvelope
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
  }

  export type ProjectUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ProjectCreateWithoutServiceInput, ProjectUncheckedCreateWithoutServiceInput> | ProjectCreateWithoutServiceInput[] | ProjectUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutServiceInput | ProjectCreateOrConnectWithoutServiceInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutServiceInput | ProjectUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ProjectCreateManyServiceInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutServiceInput | ProjectUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutServiceInput | ProjectUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type QuoteUpdateManyWithoutServiceNestedInput = {
    create?: XOR<QuoteCreateWithoutServiceInput, QuoteUncheckedCreateWithoutServiceInput> | QuoteCreateWithoutServiceInput[] | QuoteUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutServiceInput | QuoteCreateOrConnectWithoutServiceInput[]
    upsert?: QuoteUpsertWithWhereUniqueWithoutServiceInput | QuoteUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: QuoteCreateManyServiceInputEnvelope
    set?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    disconnect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    delete?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    update?: QuoteUpdateWithWhereUniqueWithoutServiceInput | QuoteUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: QuoteUpdateManyWithWhereWithoutServiceInput | QuoteUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ProjectCreateWithoutServiceInput, ProjectUncheckedCreateWithoutServiceInput> | ProjectCreateWithoutServiceInput[] | ProjectUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutServiceInput | ProjectCreateOrConnectWithoutServiceInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutServiceInput | ProjectUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ProjectCreateManyServiceInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutServiceInput | ProjectUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutServiceInput | ProjectUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type QuoteUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<QuoteCreateWithoutServiceInput, QuoteUncheckedCreateWithoutServiceInput> | QuoteCreateWithoutServiceInput[] | QuoteUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutServiceInput | QuoteCreateOrConnectWithoutServiceInput[]
    upsert?: QuoteUpsertWithWhereUniqueWithoutServiceInput | QuoteUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: QuoteCreateManyServiceInputEnvelope
    set?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    disconnect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    delete?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    update?: QuoteUpdateWithWhereUniqueWithoutServiceInput | QuoteUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: QuoteUpdateManyWithWhereWithoutServiceInput | QuoteUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
  }

  export type ProjectCreatestagesCompletedInput = {
    set: string[]
  }

  export type CustomerCreateNestedOneWithoutProjectsInput = {
    create?: XOR<CustomerCreateWithoutProjectsInput, CustomerUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutProjectsInput
    connect?: CustomerWhereUniqueInput
  }

  export type DocumentCreateNestedManyWithoutProjectInput = {
    create?: XOR<DocumentCreateWithoutProjectInput, DocumentUncheckedCreateWithoutProjectInput> | DocumentCreateWithoutProjectInput[] | DocumentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutProjectInput | DocumentCreateOrConnectWithoutProjectInput[]
    createMany?: DocumentCreateManyProjectInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type ProjectStageCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectStageCreateWithoutProjectInput, ProjectStageUncheckedCreateWithoutProjectInput> | ProjectStageCreateWithoutProjectInput[] | ProjectStageUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectStageCreateOrConnectWithoutProjectInput | ProjectStageCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectStageCreateManyProjectInputEnvelope
    connect?: ProjectStageWhereUniqueInput | ProjectStageWhereUniqueInput[]
  }

  export type MaterialCostCreateNestedManyWithoutProjectInput = {
    create?: XOR<MaterialCostCreateWithoutProjectInput, MaterialCostUncheckedCreateWithoutProjectInput> | MaterialCostCreateWithoutProjectInput[] | MaterialCostUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MaterialCostCreateOrConnectWithoutProjectInput | MaterialCostCreateOrConnectWithoutProjectInput[]
    createMany?: MaterialCostCreateManyProjectInputEnvelope
    connect?: MaterialCostWhereUniqueInput | MaterialCostWhereUniqueInput[]
  }

  export type OrderCreateNestedOneWithoutProjectInput = {
    create?: XOR<OrderCreateWithoutProjectInput, OrderUncheckedCreateWithoutProjectInput>
    connectOrCreate?: OrderCreateOrConnectWithoutProjectInput
    connect?: OrderWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutProjectsInput = {
    create?: XOR<ServiceCreateWithoutProjectsInput, ServiceUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutProjectsInput
    connect?: ServiceWhereUniqueInput
  }

  export type DocumentUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<DocumentCreateWithoutProjectInput, DocumentUncheckedCreateWithoutProjectInput> | DocumentCreateWithoutProjectInput[] | DocumentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutProjectInput | DocumentCreateOrConnectWithoutProjectInput[]
    createMany?: DocumentCreateManyProjectInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type ProjectStageUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectStageCreateWithoutProjectInput, ProjectStageUncheckedCreateWithoutProjectInput> | ProjectStageCreateWithoutProjectInput[] | ProjectStageUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectStageCreateOrConnectWithoutProjectInput | ProjectStageCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectStageCreateManyProjectInputEnvelope
    connect?: ProjectStageWhereUniqueInput | ProjectStageWhereUniqueInput[]
  }

  export type MaterialCostUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<MaterialCostCreateWithoutProjectInput, MaterialCostUncheckedCreateWithoutProjectInput> | MaterialCostCreateWithoutProjectInput[] | MaterialCostUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MaterialCostCreateOrConnectWithoutProjectInput | MaterialCostCreateOrConnectWithoutProjectInput[]
    createMany?: MaterialCostCreateManyProjectInputEnvelope
    connect?: MaterialCostWhereUniqueInput | MaterialCostWhereUniqueInput[]
  }

  export type ProjectUpdatestagesCompletedInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CustomerUpdateOneRequiredWithoutProjectsNestedInput = {
    create?: XOR<CustomerCreateWithoutProjectsInput, CustomerUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutProjectsInput
    upsert?: CustomerUpsertWithoutProjectsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutProjectsInput, CustomerUpdateWithoutProjectsInput>, CustomerUncheckedUpdateWithoutProjectsInput>
  }

  export type DocumentUpdateManyWithoutProjectNestedInput = {
    create?: XOR<DocumentCreateWithoutProjectInput, DocumentUncheckedCreateWithoutProjectInput> | DocumentCreateWithoutProjectInput[] | DocumentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutProjectInput | DocumentCreateOrConnectWithoutProjectInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutProjectInput | DocumentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: DocumentCreateManyProjectInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutProjectInput | DocumentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutProjectInput | DocumentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type ProjectStageUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectStageCreateWithoutProjectInput, ProjectStageUncheckedCreateWithoutProjectInput> | ProjectStageCreateWithoutProjectInput[] | ProjectStageUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectStageCreateOrConnectWithoutProjectInput | ProjectStageCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectStageUpsertWithWhereUniqueWithoutProjectInput | ProjectStageUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectStageCreateManyProjectInputEnvelope
    set?: ProjectStageWhereUniqueInput | ProjectStageWhereUniqueInput[]
    disconnect?: ProjectStageWhereUniqueInput | ProjectStageWhereUniqueInput[]
    delete?: ProjectStageWhereUniqueInput | ProjectStageWhereUniqueInput[]
    connect?: ProjectStageWhereUniqueInput | ProjectStageWhereUniqueInput[]
    update?: ProjectStageUpdateWithWhereUniqueWithoutProjectInput | ProjectStageUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectStageUpdateManyWithWhereWithoutProjectInput | ProjectStageUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectStageScalarWhereInput | ProjectStageScalarWhereInput[]
  }

  export type MaterialCostUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MaterialCostCreateWithoutProjectInput, MaterialCostUncheckedCreateWithoutProjectInput> | MaterialCostCreateWithoutProjectInput[] | MaterialCostUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MaterialCostCreateOrConnectWithoutProjectInput | MaterialCostCreateOrConnectWithoutProjectInput[]
    upsert?: MaterialCostUpsertWithWhereUniqueWithoutProjectInput | MaterialCostUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MaterialCostCreateManyProjectInputEnvelope
    set?: MaterialCostWhereUniqueInput | MaterialCostWhereUniqueInput[]
    disconnect?: MaterialCostWhereUniqueInput | MaterialCostWhereUniqueInput[]
    delete?: MaterialCostWhereUniqueInput | MaterialCostWhereUniqueInput[]
    connect?: MaterialCostWhereUniqueInput | MaterialCostWhereUniqueInput[]
    update?: MaterialCostUpdateWithWhereUniqueWithoutProjectInput | MaterialCostUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MaterialCostUpdateManyWithWhereWithoutProjectInput | MaterialCostUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MaterialCostScalarWhereInput | MaterialCostScalarWhereInput[]
  }

  export type OrderUpdateOneWithoutProjectNestedInput = {
    create?: XOR<OrderCreateWithoutProjectInput, OrderUncheckedCreateWithoutProjectInput>
    connectOrCreate?: OrderCreateOrConnectWithoutProjectInput
    upsert?: OrderUpsertWithoutProjectInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutProjectInput, OrderUpdateWithoutProjectInput>, OrderUncheckedUpdateWithoutProjectInput>
  }

  export type ServiceUpdateOneWithoutProjectsNestedInput = {
    create?: XOR<ServiceCreateWithoutProjectsInput, ServiceUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutProjectsInput
    upsert?: ServiceUpsertWithoutProjectsInput
    disconnect?: ServiceWhereInput | boolean
    delete?: ServiceWhereInput | boolean
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutProjectsInput, ServiceUpdateWithoutProjectsInput>, ServiceUncheckedUpdateWithoutProjectsInput>
  }

  export type DocumentUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<DocumentCreateWithoutProjectInput, DocumentUncheckedCreateWithoutProjectInput> | DocumentCreateWithoutProjectInput[] | DocumentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutProjectInput | DocumentCreateOrConnectWithoutProjectInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutProjectInput | DocumentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: DocumentCreateManyProjectInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutProjectInput | DocumentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutProjectInput | DocumentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type ProjectStageUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectStageCreateWithoutProjectInput, ProjectStageUncheckedCreateWithoutProjectInput> | ProjectStageCreateWithoutProjectInput[] | ProjectStageUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectStageCreateOrConnectWithoutProjectInput | ProjectStageCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectStageUpsertWithWhereUniqueWithoutProjectInput | ProjectStageUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectStageCreateManyProjectInputEnvelope
    set?: ProjectStageWhereUniqueInput | ProjectStageWhereUniqueInput[]
    disconnect?: ProjectStageWhereUniqueInput | ProjectStageWhereUniqueInput[]
    delete?: ProjectStageWhereUniqueInput | ProjectStageWhereUniqueInput[]
    connect?: ProjectStageWhereUniqueInput | ProjectStageWhereUniqueInput[]
    update?: ProjectStageUpdateWithWhereUniqueWithoutProjectInput | ProjectStageUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectStageUpdateManyWithWhereWithoutProjectInput | ProjectStageUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectStageScalarWhereInput | ProjectStageScalarWhereInput[]
  }

  export type MaterialCostUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MaterialCostCreateWithoutProjectInput, MaterialCostUncheckedCreateWithoutProjectInput> | MaterialCostCreateWithoutProjectInput[] | MaterialCostUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MaterialCostCreateOrConnectWithoutProjectInput | MaterialCostCreateOrConnectWithoutProjectInput[]
    upsert?: MaterialCostUpsertWithWhereUniqueWithoutProjectInput | MaterialCostUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MaterialCostCreateManyProjectInputEnvelope
    set?: MaterialCostWhereUniqueInput | MaterialCostWhereUniqueInput[]
    disconnect?: MaterialCostWhereUniqueInput | MaterialCostWhereUniqueInput[]
    delete?: MaterialCostWhereUniqueInput | MaterialCostWhereUniqueInput[]
    connect?: MaterialCostWhereUniqueInput | MaterialCostWhereUniqueInput[]
    update?: MaterialCostUpdateWithWhereUniqueWithoutProjectInput | MaterialCostUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MaterialCostUpdateManyWithWhereWithoutProjectInput | MaterialCostUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MaterialCostScalarWhereInput | MaterialCostScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutStagesInput = {
    create?: XOR<ProjectCreateWithoutStagesInput, ProjectUncheckedCreateWithoutStagesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutStagesInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutStagesNestedInput = {
    create?: XOR<ProjectCreateWithoutStagesInput, ProjectUncheckedCreateWithoutStagesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutStagesInput
    upsert?: ProjectUpsertWithoutStagesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutStagesInput, ProjectUpdateWithoutStagesInput>, ProjectUncheckedUpdateWithoutStagesInput>
  }

  export type ProjectCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<ProjectCreateWithoutDocumentsInput, ProjectUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDocumentsInput
    connect?: ProjectWhereUniqueInput
  }

  export type DocumentGenerationCreateNestedManyWithoutDocumentInput = {
    create?: XOR<DocumentGenerationCreateWithoutDocumentInput, DocumentGenerationUncheckedCreateWithoutDocumentInput> | DocumentGenerationCreateWithoutDocumentInput[] | DocumentGenerationUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentGenerationCreateOrConnectWithoutDocumentInput | DocumentGenerationCreateOrConnectWithoutDocumentInput[]
    createMany?: DocumentGenerationCreateManyDocumentInputEnvelope
    connect?: DocumentGenerationWhereUniqueInput | DocumentGenerationWhereUniqueInput[]
  }

  export type DocumentGenerationUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<DocumentGenerationCreateWithoutDocumentInput, DocumentGenerationUncheckedCreateWithoutDocumentInput> | DocumentGenerationCreateWithoutDocumentInput[] | DocumentGenerationUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentGenerationCreateOrConnectWithoutDocumentInput | DocumentGenerationCreateOrConnectWithoutDocumentInput[]
    createMany?: DocumentGenerationCreateManyDocumentInputEnvelope
    connect?: DocumentGenerationWhereUniqueInput | DocumentGenerationWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<ProjectCreateWithoutDocumentsInput, ProjectUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDocumentsInput
    upsert?: ProjectUpsertWithoutDocumentsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutDocumentsInput, ProjectUpdateWithoutDocumentsInput>, ProjectUncheckedUpdateWithoutDocumentsInput>
  }

  export type DocumentGenerationUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<DocumentGenerationCreateWithoutDocumentInput, DocumentGenerationUncheckedCreateWithoutDocumentInput> | DocumentGenerationCreateWithoutDocumentInput[] | DocumentGenerationUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentGenerationCreateOrConnectWithoutDocumentInput | DocumentGenerationCreateOrConnectWithoutDocumentInput[]
    upsert?: DocumentGenerationUpsertWithWhereUniqueWithoutDocumentInput | DocumentGenerationUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: DocumentGenerationCreateManyDocumentInputEnvelope
    set?: DocumentGenerationWhereUniqueInput | DocumentGenerationWhereUniqueInput[]
    disconnect?: DocumentGenerationWhereUniqueInput | DocumentGenerationWhereUniqueInput[]
    delete?: DocumentGenerationWhereUniqueInput | DocumentGenerationWhereUniqueInput[]
    connect?: DocumentGenerationWhereUniqueInput | DocumentGenerationWhereUniqueInput[]
    update?: DocumentGenerationUpdateWithWhereUniqueWithoutDocumentInput | DocumentGenerationUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: DocumentGenerationUpdateManyWithWhereWithoutDocumentInput | DocumentGenerationUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: DocumentGenerationScalarWhereInput | DocumentGenerationScalarWhereInput[]
  }

  export type DocumentGenerationUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<DocumentGenerationCreateWithoutDocumentInput, DocumentGenerationUncheckedCreateWithoutDocumentInput> | DocumentGenerationCreateWithoutDocumentInput[] | DocumentGenerationUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentGenerationCreateOrConnectWithoutDocumentInput | DocumentGenerationCreateOrConnectWithoutDocumentInput[]
    upsert?: DocumentGenerationUpsertWithWhereUniqueWithoutDocumentInput | DocumentGenerationUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: DocumentGenerationCreateManyDocumentInputEnvelope
    set?: DocumentGenerationWhereUniqueInput | DocumentGenerationWhereUniqueInput[]
    disconnect?: DocumentGenerationWhereUniqueInput | DocumentGenerationWhereUniqueInput[]
    delete?: DocumentGenerationWhereUniqueInput | DocumentGenerationWhereUniqueInput[]
    connect?: DocumentGenerationWhereUniqueInput | DocumentGenerationWhereUniqueInput[]
    update?: DocumentGenerationUpdateWithWhereUniqueWithoutDocumentInput | DocumentGenerationUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: DocumentGenerationUpdateManyWithWhereWithoutDocumentInput | DocumentGenerationUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: DocumentGenerationScalarWhereInput | DocumentGenerationScalarWhereInput[]
  }

  export type DocumentCreateNestedOneWithoutGenerationsInput = {
    create?: XOR<DocumentCreateWithoutGenerationsInput, DocumentUncheckedCreateWithoutGenerationsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutGenerationsInput
    connect?: DocumentWhereUniqueInput
  }

  export type DocumentUpdateOneRequiredWithoutGenerationsNestedInput = {
    create?: XOR<DocumentCreateWithoutGenerationsInput, DocumentUncheckedCreateWithoutGenerationsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutGenerationsInput
    upsert?: DocumentUpsertWithoutGenerationsInput
    connect?: DocumentWhereUniqueInput
    update?: XOR<XOR<DocumentUpdateToOneWithWhereWithoutGenerationsInput, DocumentUpdateWithoutGenerationsInput>, DocumentUncheckedUpdateWithoutGenerationsInput>
  }

  export type CustomerCreateNestedOneWithoutQuotesInput = {
    create?: XOR<CustomerCreateWithoutQuotesInput, CustomerUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutQuotesInput
    connect?: CustomerWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutQuotesInput = {
    create?: XOR<ServiceCreateWithoutQuotesInput, ServiceUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutQuotesInput
    connect?: ServiceWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutQuotesNestedInput = {
    create?: XOR<CustomerCreateWithoutQuotesInput, CustomerUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutQuotesInput
    upsert?: CustomerUpsertWithoutQuotesInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutQuotesInput, CustomerUpdateWithoutQuotesInput>, CustomerUncheckedUpdateWithoutQuotesInput>
  }

  export type ServiceUpdateOneWithoutQuotesNestedInput = {
    create?: XOR<ServiceCreateWithoutQuotesInput, ServiceUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutQuotesInput
    upsert?: ServiceUpsertWithoutQuotesInput
    disconnect?: ServiceWhereInput | boolean
    delete?: ServiceWhereInput | boolean
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutQuotesInput, ServiceUpdateWithoutQuotesInput>, ServiceUncheckedUpdateWithoutQuotesInput>
  }

  export type ProjectCreateNestedOneWithoutCostsInput = {
    create?: XOR<ProjectCreateWithoutCostsInput, ProjectUncheckedCreateWithoutCostsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCostsInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneWithoutCostsNestedInput = {
    create?: XOR<ProjectCreateWithoutCostsInput, ProjectUncheckedCreateWithoutCostsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCostsInput
    upsert?: ProjectUpsertWithoutCostsInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutCostsInput, ProjectUpdateWithoutCostsInput>, ProjectUncheckedUpdateWithoutCostsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ChatSessionCreateWithoutUserInput = {
    id: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    systemPrompt?: string | null
    isActive?: boolean
    userName?: string | null
    userEmail?: string | null
    ipAddress?: string | null
    location?: string | null
    source?: string | null
    category?: string | null
    mondayItemId?: string | null
    mondaySynced?: boolean
    copilotSynced?: boolean
    databaseSynced?: boolean
    lastMondaySync?: Date | string | null
    lastCopilotSync?: Date | string | null
    messages?: MessageCreateNestedManyWithoutSessionInput
    tags?: SessionTagCreateNestedManyWithoutSessionInput
  }

  export type ChatSessionUncheckedCreateWithoutUserInput = {
    id: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    systemPrompt?: string | null
    isActive?: boolean
    userName?: string | null
    userEmail?: string | null
    ipAddress?: string | null
    location?: string | null
    source?: string | null
    category?: string | null
    mondayItemId?: string | null
    mondaySynced?: boolean
    copilotSynced?: boolean
    databaseSynced?: boolean
    lastMondaySync?: Date | string | null
    lastCopilotSync?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutSessionInput
    tags?: SessionTagUncheckedCreateNestedManyWithoutSessionInput
  }

  export type ChatSessionCreateOrConnectWithoutUserInput = {
    where: ChatSessionWhereUniqueInput
    create: XOR<ChatSessionCreateWithoutUserInput, ChatSessionUncheckedCreateWithoutUserInput>
  }

  export type ChatSessionCreateManyUserInputEnvelope = {
    data: ChatSessionCreateManyUserInput | ChatSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutUserInput = {
    id: string
    role: string
    content: string
    timestamp?: Date | string
    isError?: boolean | null
    functionName?: string | null
    functionArgs?: string | null
    session: ChatSessionCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutUserInput = {
    id: string
    sessionId: string
    role: string
    content: string
    timestamp?: Date | string
    isError?: boolean | null
    functionName?: string | null
    functionArgs?: string | null
  }

  export type MessageCreateOrConnectWithoutUserInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput>
  }

  export type MessageCreateManyUserInputEnvelope = {
    data: MessageCreateManyUserInput | MessageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CustomerCreateWithoutUserInput = {
    id?: string
    companyName?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    taxId?: string | null
    phoneNumber?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentMethods?: PaymentMethodCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceCreateNestedManyWithoutCustomerInput
    projects?: ProjectCreateNestedManyWithoutClientInput
    quotes?: QuoteCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutUserInput = {
    id?: string
    companyName?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    taxId?: string | null
    phoneNumber?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutUserInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutUserInput, CustomerUncheckedCreateWithoutUserInput>
  }

  export type CartCreateWithoutUserInput = {
    id?: string
    sessionId?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: CartItemCreateNestedManyWithoutCartInput
  }

  export type CartUncheckedCreateWithoutUserInput = {
    id?: string
    sessionId?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: CartItemUncheckedCreateNestedManyWithoutCartInput
  }

  export type CartCreateOrConnectWithoutUserInput = {
    where: CartWhereUniqueInput
    create: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput>
  }

  export type ChatSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: ChatSessionWhereUniqueInput
    update: XOR<ChatSessionUpdateWithoutUserInput, ChatSessionUncheckedUpdateWithoutUserInput>
    create: XOR<ChatSessionCreateWithoutUserInput, ChatSessionUncheckedCreateWithoutUserInput>
  }

  export type ChatSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: ChatSessionWhereUniqueInput
    data: XOR<ChatSessionUpdateWithoutUserInput, ChatSessionUncheckedUpdateWithoutUserInput>
  }

  export type ChatSessionUpdateManyWithWhereWithoutUserInput = {
    where: ChatSessionScalarWhereInput
    data: XOR<ChatSessionUpdateManyMutationInput, ChatSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type ChatSessionScalarWhereInput = {
    AND?: ChatSessionScalarWhereInput | ChatSessionScalarWhereInput[]
    OR?: ChatSessionScalarWhereInput[]
    NOT?: ChatSessionScalarWhereInput | ChatSessionScalarWhereInput[]
    id?: StringFilter<"ChatSession"> | string
    title?: StringFilter<"ChatSession"> | string
    createdAt?: DateTimeFilter<"ChatSession"> | Date | string
    updatedAt?: DateTimeFilter<"ChatSession"> | Date | string
    systemPrompt?: StringNullableFilter<"ChatSession"> | string | null
    isActive?: BoolFilter<"ChatSession"> | boolean
    userId?: StringNullableFilter<"ChatSession"> | string | null
    userName?: StringNullableFilter<"ChatSession"> | string | null
    userEmail?: StringNullableFilter<"ChatSession"> | string | null
    ipAddress?: StringNullableFilter<"ChatSession"> | string | null
    location?: StringNullableFilter<"ChatSession"> | string | null
    source?: StringNullableFilter<"ChatSession"> | string | null
    category?: StringNullableFilter<"ChatSession"> | string | null
    mondayItemId?: StringNullableFilter<"ChatSession"> | string | null
    mondaySynced?: BoolFilter<"ChatSession"> | boolean
    copilotSynced?: BoolFilter<"ChatSession"> | boolean
    databaseSynced?: BoolFilter<"ChatSession"> | boolean
    lastMondaySync?: DateTimeNullableFilter<"ChatSession"> | Date | string | null
    lastCopilotSync?: DateTimeNullableFilter<"ChatSession"> | Date | string | null
  }

  export type MessageUpsertWithWhereUniqueWithoutUserInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutUserInput, MessageUncheckedUpdateWithoutUserInput>
    create: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutUserInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutUserInput, MessageUncheckedUpdateWithoutUserInput>
  }

  export type MessageUpdateManyWithWhereWithoutUserInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutUserInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    sessionId?: StringFilter<"Message"> | string
    role?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    timestamp?: DateTimeFilter<"Message"> | Date | string
    isError?: BoolNullableFilter<"Message"> | boolean | null
    userId?: StringNullableFilter<"Message"> | string | null
    functionName?: StringNullableFilter<"Message"> | string | null
    functionArgs?: StringNullableFilter<"Message"> | string | null
  }

  export type CustomerUpsertWithoutUserInput = {
    update: XOR<CustomerUpdateWithoutUserInput, CustomerUncheckedUpdateWithoutUserInput>
    create: XOR<CustomerCreateWithoutUserInput, CustomerUncheckedCreateWithoutUserInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutUserInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutUserInput, CustomerUncheckedUpdateWithoutUserInput>
  }

  export type CustomerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethods?: PaymentMethodUpdateManyWithoutCustomerNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUpdateManyWithoutCustomerNestedInput
    projects?: ProjectUpdateManyWithoutClientNestedInput
    quotes?: QuoteUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutCustomerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CartUpsertWithoutUserInput = {
    update: XOR<CartUpdateWithoutUserInput, CartUncheckedUpdateWithoutUserInput>
    create: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput>
    where?: CartWhereInput
  }

  export type CartUpdateToOneWithWhereWithoutUserInput = {
    where?: CartWhereInput
    data: XOR<CartUpdateWithoutUserInput, CartUncheckedUpdateWithoutUserInput>
  }

  export type CartUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: CartItemUpdateManyWithoutCartNestedInput
  }

  export type CartUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: CartItemUncheckedUpdateManyWithoutCartNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email?: string | null
    name?: string | null
    password?: string | null
    role?: string
    externalId?: string | null
    mondayUserId?: string | null
    copilotUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageCreateNestedManyWithoutUserInput
    customer?: CustomerCreateNestedOneWithoutUserInput
    cart?: CartCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email?: string | null
    name?: string | null
    password?: string | null
    role?: string
    externalId?: string | null
    mondayUserId?: string | null
    copilotUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    customer?: CustomerUncheckedCreateNestedOneWithoutUserInput
    cart?: CartUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type MessageCreateWithoutSessionInput = {
    id: string
    role: string
    content: string
    timestamp?: Date | string
    isError?: boolean | null
    functionName?: string | null
    functionArgs?: string | null
    user?: UserCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutSessionInput = {
    id: string
    role: string
    content: string
    timestamp?: Date | string
    isError?: boolean | null
    userId?: string | null
    functionName?: string | null
    functionArgs?: string | null
  }

  export type MessageCreateOrConnectWithoutSessionInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSessionInput, MessageUncheckedCreateWithoutSessionInput>
  }

  export type MessageCreateManySessionInputEnvelope = {
    data: MessageCreateManySessionInput | MessageCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type SessionTagCreateWithoutSessionInput = {
    id?: string
    name: string
  }

  export type SessionTagUncheckedCreateWithoutSessionInput = {
    id?: string
    name: string
  }

  export type SessionTagCreateOrConnectWithoutSessionInput = {
    where: SessionTagWhereUniqueInput
    create: XOR<SessionTagCreateWithoutSessionInput, SessionTagUncheckedCreateWithoutSessionInput>
  }

  export type SessionTagCreateManySessionInputEnvelope = {
    data: SessionTagCreateManySessionInput | SessionTagCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    mondayUserId?: NullableStringFieldUpdateOperationsInput | string | null
    copilotUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUpdateManyWithoutUserNestedInput
    customer?: CustomerUpdateOneWithoutUserNestedInput
    cart?: CartUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    mondayUserId?: NullableStringFieldUpdateOperationsInput | string | null
    copilotUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    customer?: CustomerUncheckedUpdateOneWithoutUserNestedInput
    cart?: CartUncheckedUpdateOneWithoutUserNestedInput
  }

  export type MessageUpsertWithWhereUniqueWithoutSessionInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSessionInput, MessageUncheckedUpdateWithoutSessionInput>
    create: XOR<MessageCreateWithoutSessionInput, MessageUncheckedCreateWithoutSessionInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSessionInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSessionInput, MessageUncheckedUpdateWithoutSessionInput>
  }

  export type MessageUpdateManyWithWhereWithoutSessionInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSessionInput>
  }

  export type SessionTagUpsertWithWhereUniqueWithoutSessionInput = {
    where: SessionTagWhereUniqueInput
    update: XOR<SessionTagUpdateWithoutSessionInput, SessionTagUncheckedUpdateWithoutSessionInput>
    create: XOR<SessionTagCreateWithoutSessionInput, SessionTagUncheckedCreateWithoutSessionInput>
  }

  export type SessionTagUpdateWithWhereUniqueWithoutSessionInput = {
    where: SessionTagWhereUniqueInput
    data: XOR<SessionTagUpdateWithoutSessionInput, SessionTagUncheckedUpdateWithoutSessionInput>
  }

  export type SessionTagUpdateManyWithWhereWithoutSessionInput = {
    where: SessionTagScalarWhereInput
    data: XOR<SessionTagUpdateManyMutationInput, SessionTagUncheckedUpdateManyWithoutSessionInput>
  }

  export type SessionTagScalarWhereInput = {
    AND?: SessionTagScalarWhereInput | SessionTagScalarWhereInput[]
    OR?: SessionTagScalarWhereInput[]
    NOT?: SessionTagScalarWhereInput | SessionTagScalarWhereInput[]
    id?: StringFilter<"SessionTag"> | string
    name?: StringFilter<"SessionTag"> | string
    sessionId?: StringFilter<"SessionTag"> | string
  }

  export type ChatSessionCreateWithoutMessagesInput = {
    id: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    systemPrompt?: string | null
    isActive?: boolean
    userName?: string | null
    userEmail?: string | null
    ipAddress?: string | null
    location?: string | null
    source?: string | null
    category?: string | null
    mondayItemId?: string | null
    mondaySynced?: boolean
    copilotSynced?: boolean
    databaseSynced?: boolean
    lastMondaySync?: Date | string | null
    lastCopilotSync?: Date | string | null
    user?: UserCreateNestedOneWithoutSessionsInput
    tags?: SessionTagCreateNestedManyWithoutSessionInput
  }

  export type ChatSessionUncheckedCreateWithoutMessagesInput = {
    id: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    systemPrompt?: string | null
    isActive?: boolean
    userId?: string | null
    userName?: string | null
    userEmail?: string | null
    ipAddress?: string | null
    location?: string | null
    source?: string | null
    category?: string | null
    mondayItemId?: string | null
    mondaySynced?: boolean
    copilotSynced?: boolean
    databaseSynced?: boolean
    lastMondaySync?: Date | string | null
    lastCopilotSync?: Date | string | null
    tags?: SessionTagUncheckedCreateNestedManyWithoutSessionInput
  }

  export type ChatSessionCreateOrConnectWithoutMessagesInput = {
    where: ChatSessionWhereUniqueInput
    create: XOR<ChatSessionCreateWithoutMessagesInput, ChatSessionUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutMessagesInput = {
    id?: string
    email?: string | null
    name?: string | null
    password?: string | null
    role?: string
    externalId?: string | null
    mondayUserId?: string | null
    copilotUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: ChatSessionCreateNestedManyWithoutUserInput
    customer?: CustomerCreateNestedOneWithoutUserInput
    cart?: CartCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMessagesInput = {
    id?: string
    email?: string | null
    name?: string | null
    password?: string | null
    role?: string
    externalId?: string | null
    mondayUserId?: string | null
    copilotUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: ChatSessionUncheckedCreateNestedManyWithoutUserInput
    customer?: CustomerUncheckedCreateNestedOneWithoutUserInput
    cart?: CartUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
  }

  export type ChatSessionUpsertWithoutMessagesInput = {
    update: XOR<ChatSessionUpdateWithoutMessagesInput, ChatSessionUncheckedUpdateWithoutMessagesInput>
    create: XOR<ChatSessionCreateWithoutMessagesInput, ChatSessionUncheckedCreateWithoutMessagesInput>
    where?: ChatSessionWhereInput
  }

  export type ChatSessionUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ChatSessionWhereInput
    data: XOR<ChatSessionUpdateWithoutMessagesInput, ChatSessionUncheckedUpdateWithoutMessagesInput>
  }

  export type ChatSessionUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    systemPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    mondayItemId?: NullableStringFieldUpdateOperationsInput | string | null
    mondaySynced?: BoolFieldUpdateOperationsInput | boolean
    copilotSynced?: BoolFieldUpdateOperationsInput | boolean
    databaseSynced?: BoolFieldUpdateOperationsInput | boolean
    lastMondaySync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastCopilotSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutSessionsNestedInput
    tags?: SessionTagUpdateManyWithoutSessionNestedInput
  }

  export type ChatSessionUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    systemPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    mondayItemId?: NullableStringFieldUpdateOperationsInput | string | null
    mondaySynced?: BoolFieldUpdateOperationsInput | boolean
    copilotSynced?: BoolFieldUpdateOperationsInput | boolean
    databaseSynced?: BoolFieldUpdateOperationsInput | boolean
    lastMondaySync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastCopilotSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: SessionTagUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type UserUpsertWithoutMessagesInput = {
    update: XOR<UserUpdateWithoutMessagesInput, UserUncheckedUpdateWithoutMessagesInput>
    create: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessagesInput, UserUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    mondayUserId?: NullableStringFieldUpdateOperationsInput | string | null
    copilotUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: ChatSessionUpdateManyWithoutUserNestedInput
    customer?: CustomerUpdateOneWithoutUserNestedInput
    cart?: CartUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    mondayUserId?: NullableStringFieldUpdateOperationsInput | string | null
    copilotUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: ChatSessionUncheckedUpdateManyWithoutUserNestedInput
    customer?: CustomerUncheckedUpdateOneWithoutUserNestedInput
    cart?: CartUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ChatSessionCreateWithoutTagsInput = {
    id: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    systemPrompt?: string | null
    isActive?: boolean
    userName?: string | null
    userEmail?: string | null
    ipAddress?: string | null
    location?: string | null
    source?: string | null
    category?: string | null
    mondayItemId?: string | null
    mondaySynced?: boolean
    copilotSynced?: boolean
    databaseSynced?: boolean
    lastMondaySync?: Date | string | null
    lastCopilotSync?: Date | string | null
    user?: UserCreateNestedOneWithoutSessionsInput
    messages?: MessageCreateNestedManyWithoutSessionInput
  }

  export type ChatSessionUncheckedCreateWithoutTagsInput = {
    id: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    systemPrompt?: string | null
    isActive?: boolean
    userId?: string | null
    userName?: string | null
    userEmail?: string | null
    ipAddress?: string | null
    location?: string | null
    source?: string | null
    category?: string | null
    mondayItemId?: string | null
    mondaySynced?: boolean
    copilotSynced?: boolean
    databaseSynced?: boolean
    lastMondaySync?: Date | string | null
    lastCopilotSync?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutSessionInput
  }

  export type ChatSessionCreateOrConnectWithoutTagsInput = {
    where: ChatSessionWhereUniqueInput
    create: XOR<ChatSessionCreateWithoutTagsInput, ChatSessionUncheckedCreateWithoutTagsInput>
  }

  export type ChatSessionUpsertWithoutTagsInput = {
    update: XOR<ChatSessionUpdateWithoutTagsInput, ChatSessionUncheckedUpdateWithoutTagsInput>
    create: XOR<ChatSessionCreateWithoutTagsInput, ChatSessionUncheckedCreateWithoutTagsInput>
    where?: ChatSessionWhereInput
  }

  export type ChatSessionUpdateToOneWithWhereWithoutTagsInput = {
    where?: ChatSessionWhereInput
    data: XOR<ChatSessionUpdateWithoutTagsInput, ChatSessionUncheckedUpdateWithoutTagsInput>
  }

  export type ChatSessionUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    systemPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    mondayItemId?: NullableStringFieldUpdateOperationsInput | string | null
    mondaySynced?: BoolFieldUpdateOperationsInput | boolean
    copilotSynced?: BoolFieldUpdateOperationsInput | boolean
    databaseSynced?: BoolFieldUpdateOperationsInput | boolean
    lastMondaySync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastCopilotSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutSessionsNestedInput
    messages?: MessageUpdateManyWithoutSessionNestedInput
  }

  export type ChatSessionUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    systemPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    mondayItemId?: NullableStringFieldUpdateOperationsInput | string | null
    mondaySynced?: BoolFieldUpdateOperationsInput | boolean
    copilotSynced?: BoolFieldUpdateOperationsInput | boolean
    databaseSynced?: BoolFieldUpdateOperationsInput | boolean
    lastMondaySync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastCopilotSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type UserCreateWithoutCustomerInput = {
    id?: string
    email?: string | null
    name?: string | null
    password?: string | null
    role?: string
    externalId?: string | null
    mondayUserId?: string | null
    copilotUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: ChatSessionCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutUserInput
    cart?: CartCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCustomerInput = {
    id?: string
    email?: string | null
    name?: string | null
    password?: string | null
    role?: string
    externalId?: string | null
    mondayUserId?: string | null
    copilotUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: ChatSessionUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    cart?: CartUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCustomerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCustomerInput, UserUncheckedCreateWithoutCustomerInput>
  }

  export type PaymentMethodCreateWithoutCustomerInput = {
    id?: string
    stripePaymentMethodId: string
    type: string
    last4: string
    brand?: string | null
    expiryMonth?: number | null
    expiryYear?: number | null
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentMethodUncheckedCreateWithoutCustomerInput = {
    id?: string
    stripePaymentMethodId: string
    type: string
    last4: string
    brand?: string | null
    expiryMonth?: number | null
    expiryYear?: number | null
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentMethodCreateOrConnectWithoutCustomerInput = {
    where: PaymentMethodWhereUniqueInput
    create: XOR<PaymentMethodCreateWithoutCustomerInput, PaymentMethodUncheckedCreateWithoutCustomerInput>
  }

  export type PaymentMethodCreateManyCustomerInputEnvelope = {
    data: PaymentMethodCreateManyCustomerInput | PaymentMethodCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutCustomerInput = {
    id?: string
    orderNumber: string
    status?: string
    subtotal: number
    tax: number
    shipping: number
    total: number
    currency?: string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingMethod?: string | null
    trackingNumber?: string | null
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    paymentStatus?: string
    paymentIntentId?: string | null
    paidAt?: Date | string | null
    customerNotes?: string | null
    internalNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemCreateNestedManyWithoutOrderInput
    invoice?: InvoiceCreateNestedOneWithoutOrderInput
    project?: ProjectCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutCustomerInput = {
    id?: string
    orderNumber: string
    status?: string
    subtotal: number
    tax: number
    shipping: number
    total: number
    currency?: string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingMethod?: string | null
    trackingNumber?: string | null
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    paymentStatus?: string
    paymentIntentId?: string | null
    paidAt?: Date | string | null
    customerNotes?: string | null
    internalNotes?: string | null
    invoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    project?: ProjectUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderCreateManyCustomerInputEnvelope = {
    data: OrderCreateManyCustomerInput | OrderCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutCustomerInput = {
    id?: string
    status?: string
    billingCycle?: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    nextBillingDate: Date | string
    stripeSubscriptionId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput
    invoices?: InvoiceCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutCustomerInput = {
    id?: string
    status?: string
    planId: string
    billingCycle?: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    nextBillingDate: Date | string
    stripeSubscriptionId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutCustomerInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutCustomerInput, SubscriptionUncheckedCreateWithoutCustomerInput>
  }

  export type SubscriptionCreateManyCustomerInputEnvelope = {
    data: SubscriptionCreateManyCustomerInput | SubscriptionCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutCustomerInput = {
    id?: string
    invoiceNumber: string
    type: string
    subtotal: number
    tax: number
    total: number
    currency?: string
    status?: string
    dueDate: Date | string
    paidAt?: Date | string | null
    paymentIntentId?: string | null
    paymentMethod?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: OrderCreateNestedOneWithoutInvoiceInput
    subscription?: SubscriptionCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutCustomerInput = {
    id?: string
    invoiceNumber: string
    type: string
    subscriptionId?: string | null
    subtotal: number
    tax: number
    total: number
    currency?: string
    status?: string
    dueDate: Date | string
    paidAt?: Date | string | null
    paymentIntentId?: string | null
    paymentMethod?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: OrderUncheckedCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutCustomerInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput>
  }

  export type InvoiceCreateManyCustomerInputEnvelope = {
    data: InvoiceCreateManyCustomerInput | InvoiceCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutClientInput = {
    id?: string
    projectRef: string
    name: string
    description?: string | null
    service: string
    status?: string
    currentStage?: string
    stagesCompleted?: ProjectCreatestagesCompletedInput | string[]
    quotedAmount?: number | null
    actualCost?: number | null
    invoicedAmount?: number | null
    paidAmount?: number | null
    startDate?: Date | string | null
    targetDate?: Date | string | null
    completedDate?: Date | string | null
    location?: string | null
    notes?: string | null
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentCreateNestedManyWithoutProjectInput
    stages?: ProjectStageCreateNestedManyWithoutProjectInput
    costs?: MaterialCostCreateNestedManyWithoutProjectInput
    order?: OrderCreateNestedOneWithoutProjectInput
    Service?: ServiceCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutClientInput = {
    id?: string
    projectRef: string
    name: string
    description?: string | null
    service: string
    status?: string
    currentStage?: string
    stagesCompleted?: ProjectCreatestagesCompletedInput | string[]
    quotedAmount?: number | null
    actualCost?: number | null
    invoicedAmount?: number | null
    paidAmount?: number | null
    startDate?: Date | string | null
    targetDate?: Date | string | null
    completedDate?: Date | string | null
    location?: string | null
    notes?: string | null
    priority?: string
    orderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceId?: string | null
    documents?: DocumentUncheckedCreateNestedManyWithoutProjectInput
    stages?: ProjectStageUncheckedCreateNestedManyWithoutProjectInput
    costs?: MaterialCostUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutClientInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput>
  }

  export type ProjectCreateManyClientInputEnvelope = {
    data: ProjectCreateManyClientInput | ProjectCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type QuoteCreateWithoutCustomerInput = {
    id?: string
    quoteNumber: string
    title: string
    description?: string | null
    services: JsonNullValueInput | InputJsonValue
    subtotal: number
    tax: number
    total: number
    currency?: string
    validUntil: Date | string
    status?: string
    terms?: string | null
    notes?: string | null
    convertedToProjectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Service?: ServiceCreateNestedOneWithoutQuotesInput
  }

  export type QuoteUncheckedCreateWithoutCustomerInput = {
    id?: string
    quoteNumber: string
    title: string
    description?: string | null
    services: JsonNullValueInput | InputJsonValue
    subtotal: number
    tax: number
    total: number
    currency?: string
    validUntil: Date | string
    status?: string
    terms?: string | null
    notes?: string | null
    convertedToProjectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceId?: string | null
  }

  export type QuoteCreateOrConnectWithoutCustomerInput = {
    where: QuoteWhereUniqueInput
    create: XOR<QuoteCreateWithoutCustomerInput, QuoteUncheckedCreateWithoutCustomerInput>
  }

  export type QuoteCreateManyCustomerInputEnvelope = {
    data: QuoteCreateManyCustomerInput | QuoteCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCustomerInput = {
    update: XOR<UserUpdateWithoutCustomerInput, UserUncheckedUpdateWithoutCustomerInput>
    create: XOR<UserCreateWithoutCustomerInput, UserUncheckedCreateWithoutCustomerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCustomerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCustomerInput, UserUncheckedUpdateWithoutCustomerInput>
  }

  export type UserUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    mondayUserId?: NullableStringFieldUpdateOperationsInput | string | null
    copilotUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: ChatSessionUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    cart?: CartUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    mondayUserId?: NullableStringFieldUpdateOperationsInput | string | null
    copilotUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: ChatSessionUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    cart?: CartUncheckedUpdateOneWithoutUserNestedInput
  }

  export type PaymentMethodUpsertWithWhereUniqueWithoutCustomerInput = {
    where: PaymentMethodWhereUniqueInput
    update: XOR<PaymentMethodUpdateWithoutCustomerInput, PaymentMethodUncheckedUpdateWithoutCustomerInput>
    create: XOR<PaymentMethodCreateWithoutCustomerInput, PaymentMethodUncheckedCreateWithoutCustomerInput>
  }

  export type PaymentMethodUpdateWithWhereUniqueWithoutCustomerInput = {
    where: PaymentMethodWhereUniqueInput
    data: XOR<PaymentMethodUpdateWithoutCustomerInput, PaymentMethodUncheckedUpdateWithoutCustomerInput>
  }

  export type PaymentMethodUpdateManyWithWhereWithoutCustomerInput = {
    where: PaymentMethodScalarWhereInput
    data: XOR<PaymentMethodUpdateManyMutationInput, PaymentMethodUncheckedUpdateManyWithoutCustomerInput>
  }

  export type PaymentMethodScalarWhereInput = {
    AND?: PaymentMethodScalarWhereInput | PaymentMethodScalarWhereInput[]
    OR?: PaymentMethodScalarWhereInput[]
    NOT?: PaymentMethodScalarWhereInput | PaymentMethodScalarWhereInput[]
    id?: StringFilter<"PaymentMethod"> | string
    customerId?: StringFilter<"PaymentMethod"> | string
    stripePaymentMethodId?: StringFilter<"PaymentMethod"> | string
    type?: StringFilter<"PaymentMethod"> | string
    last4?: StringFilter<"PaymentMethod"> | string
    brand?: StringNullableFilter<"PaymentMethod"> | string | null
    expiryMonth?: IntNullableFilter<"PaymentMethod"> | number | null
    expiryYear?: IntNullableFilter<"PaymentMethod"> | number | null
    isDefault?: BoolFilter<"PaymentMethod"> | boolean
    createdAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentMethod"> | Date | string
  }

  export type OrderUpsertWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
  }

  export type OrderUpdateManyWithWhereWithoutCustomerInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutCustomerInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: StringFilter<"Order"> | string
    orderNumber?: StringFilter<"Order"> | string
    customerId?: StringFilter<"Order"> | string
    status?: StringFilter<"Order"> | string
    subtotal?: FloatFilter<"Order"> | number
    tax?: FloatFilter<"Order"> | number
    shipping?: FloatFilter<"Order"> | number
    total?: FloatFilter<"Order"> | number
    currency?: StringFilter<"Order"> | string
    shippingAddress?: JsonNullableFilter<"Order">
    shippingMethod?: StringNullableFilter<"Order"> | string | null
    trackingNumber?: StringNullableFilter<"Order"> | string | null
    shippedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    paymentStatus?: StringFilter<"Order"> | string
    paymentIntentId?: StringNullableFilter<"Order"> | string | null
    paidAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    customerNotes?: StringNullableFilter<"Order"> | string | null
    internalNotes?: StringNullableFilter<"Order"> | string | null
    invoiceId?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutCustomerInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutCustomerInput, SubscriptionUncheckedUpdateWithoutCustomerInput>
    create: XOR<SubscriptionCreateWithoutCustomerInput, SubscriptionUncheckedCreateWithoutCustomerInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutCustomerInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutCustomerInput, SubscriptionUncheckedUpdateWithoutCustomerInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutCustomerInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutCustomerInput>
  }

  export type SubscriptionScalarWhereInput = {
    AND?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    OR?: SubscriptionScalarWhereInput[]
    NOT?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    id?: StringFilter<"Subscription"> | string
    customerId?: StringFilter<"Subscription"> | string
    status?: StringFilter<"Subscription"> | string
    planId?: StringFilter<"Subscription"> | string
    billingCycle?: StringFilter<"Subscription"> | string
    currentPeriodStart?: DateTimeFilter<"Subscription"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"Subscription"> | Date | string
    nextBillingDate?: DateTimeFilter<"Subscription"> | Date | string
    stripeSubscriptionId?: StringNullableFilter<"Subscription"> | string | null
    metadata?: JsonNullableFilter<"Subscription">
    cancelledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    cancelReason?: StringNullableFilter<"Subscription"> | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
  }

  export type InvoiceUpsertWithWhereUniqueWithoutCustomerInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutCustomerInput, InvoiceUncheckedUpdateWithoutCustomerInput>
    create: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutCustomerInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutCustomerInput, InvoiceUncheckedUpdateWithoutCustomerInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutCustomerInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutCustomerInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: StringFilter<"Invoice"> | string
    invoiceNumber?: StringFilter<"Invoice"> | string
    customerId?: StringFilter<"Invoice"> | string
    type?: StringFilter<"Invoice"> | string
    subscriptionId?: StringNullableFilter<"Invoice"> | string | null
    subtotal?: FloatFilter<"Invoice"> | number
    tax?: FloatFilter<"Invoice"> | number
    total?: FloatFilter<"Invoice"> | number
    currency?: StringFilter<"Invoice"> | string
    status?: StringFilter<"Invoice"> | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    paidAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    paymentIntentId?: StringNullableFilter<"Invoice"> | string | null
    paymentMethod?: StringNullableFilter<"Invoice"> | string | null
    pdfUrl?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
  }

  export type ProjectUpsertWithWhereUniqueWithoutClientInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutClientInput, ProjectUncheckedUpdateWithoutClientInput>
    create: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutClientInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutClientInput, ProjectUncheckedUpdateWithoutClientInput>
  }

  export type ProjectUpdateManyWithWhereWithoutClientInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutClientInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: StringFilter<"Project"> | string
    projectRef?: StringFilter<"Project"> | string
    clientId?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    service?: StringFilter<"Project"> | string
    status?: StringFilter<"Project"> | string
    currentStage?: StringFilter<"Project"> | string
    stagesCompleted?: StringNullableListFilter<"Project">
    quotedAmount?: FloatNullableFilter<"Project"> | number | null
    actualCost?: FloatNullableFilter<"Project"> | number | null
    invoicedAmount?: FloatNullableFilter<"Project"> | number | null
    paidAmount?: FloatNullableFilter<"Project"> | number | null
    startDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    targetDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    completedDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    location?: StringNullableFilter<"Project"> | string | null
    notes?: StringNullableFilter<"Project"> | string | null
    priority?: StringFilter<"Project"> | string
    orderId?: StringNullableFilter<"Project"> | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    serviceId?: StringNullableFilter<"Project"> | string | null
  }

  export type QuoteUpsertWithWhereUniqueWithoutCustomerInput = {
    where: QuoteWhereUniqueInput
    update: XOR<QuoteUpdateWithoutCustomerInput, QuoteUncheckedUpdateWithoutCustomerInput>
    create: XOR<QuoteCreateWithoutCustomerInput, QuoteUncheckedCreateWithoutCustomerInput>
  }

  export type QuoteUpdateWithWhereUniqueWithoutCustomerInput = {
    where: QuoteWhereUniqueInput
    data: XOR<QuoteUpdateWithoutCustomerInput, QuoteUncheckedUpdateWithoutCustomerInput>
  }

  export type QuoteUpdateManyWithWhereWithoutCustomerInput = {
    where: QuoteScalarWhereInput
    data: XOR<QuoteUpdateManyMutationInput, QuoteUncheckedUpdateManyWithoutCustomerInput>
  }

  export type QuoteScalarWhereInput = {
    AND?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
    OR?: QuoteScalarWhereInput[]
    NOT?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
    id?: StringFilter<"Quote"> | string
    quoteNumber?: StringFilter<"Quote"> | string
    customerId?: StringFilter<"Quote"> | string
    title?: StringFilter<"Quote"> | string
    description?: StringNullableFilter<"Quote"> | string | null
    services?: JsonFilter<"Quote">
    subtotal?: FloatFilter<"Quote"> | number
    tax?: FloatFilter<"Quote"> | number
    total?: FloatFilter<"Quote"> | number
    currency?: StringFilter<"Quote"> | string
    validUntil?: DateTimeFilter<"Quote"> | Date | string
    status?: StringFilter<"Quote"> | string
    terms?: StringNullableFilter<"Quote"> | string | null
    notes?: StringNullableFilter<"Quote"> | string | null
    convertedToProjectId?: StringNullableFilter<"Quote"> | string | null
    createdAt?: DateTimeFilter<"Quote"> | Date | string
    updatedAt?: DateTimeFilter<"Quote"> | Date | string
    serviceId?: StringNullableFilter<"Quote"> | string | null
  }

  export type InventoryCreateWithoutProductInput = {
    id?: string
    location: string
    quantity?: number
    reservedQuantity?: number
    availableQuantity?: number
    reorderPoint?: number
    reorderQuantity?: number
    batchNumber?: string | null
    serialNumbers?: NullableJsonNullValueInput | InputJsonValue
    lastRestocked?: Date | string | null
    lastCounted?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryUncheckedCreateWithoutProductInput = {
    id?: string
    location: string
    quantity?: number
    reservedQuantity?: number
    availableQuantity?: number
    reorderPoint?: number
    reorderQuantity?: number
    batchNumber?: string | null
    serialNumbers?: NullableJsonNullValueInput | InputJsonValue
    lastRestocked?: Date | string | null
    lastCounted?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryCreateOrConnectWithoutProductInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput>
  }

  export type InventoryCreateManyProductInputEnvelope = {
    data: InventoryCreateManyProductInput | InventoryCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type OrderItemCreateWithoutProductInput = {
    id?: string
    quantity: number
    unitPrice: number
    totalPrice: number
    productSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    order: OrderCreateNestedOneWithoutItemsInput
  }

  export type OrderItemUncheckedCreateWithoutProductInput = {
    id?: string
    orderId: string
    quantity: number
    unitPrice: number
    totalPrice: number
    productSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type OrderItemCreateOrConnectWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemCreateManyProductInputEnvelope = {
    data: OrderItemCreateManyProductInput | OrderItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type CartItemCreateWithoutProductInput = {
    id?: string
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cart: CartCreateNestedOneWithoutItemsInput
  }

  export type CartItemUncheckedCreateWithoutProductInput = {
    id?: string
    cartId: string
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartItemCreateOrConnectWithoutProductInput = {
    where: CartItemWhereUniqueInput
    create: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput>
  }

  export type CartItemCreateManyProductInputEnvelope = {
    data: CartItemCreateManyProductInput | CartItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type PriceHistoryCreateWithoutProductInput = {
    id?: string
    price: number
    previousPrice?: number | null
    currency?: string
    reason?: string | null
    effectiveFrom: Date | string
    effectiveUntil?: Date | string | null
    createdAt?: Date | string
  }

  export type PriceHistoryUncheckedCreateWithoutProductInput = {
    id?: string
    price: number
    previousPrice?: number | null
    currency?: string
    reason?: string | null
    effectiveFrom: Date | string
    effectiveUntil?: Date | string | null
    createdAt?: Date | string
  }

  export type PriceHistoryCreateOrConnectWithoutProductInput = {
    where: PriceHistoryWhereUniqueInput
    create: XOR<PriceHistoryCreateWithoutProductInput, PriceHistoryUncheckedCreateWithoutProductInput>
  }

  export type PriceHistoryCreateManyProductInputEnvelope = {
    data: PriceHistoryCreateManyProductInput | PriceHistoryCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type InventoryUpsertWithWhereUniqueWithoutProductInput = {
    where: InventoryWhereUniqueInput
    update: XOR<InventoryUpdateWithoutProductInput, InventoryUncheckedUpdateWithoutProductInput>
    create: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput>
  }

  export type InventoryUpdateWithWhereUniqueWithoutProductInput = {
    where: InventoryWhereUniqueInput
    data: XOR<InventoryUpdateWithoutProductInput, InventoryUncheckedUpdateWithoutProductInput>
  }

  export type InventoryUpdateManyWithWhereWithoutProductInput = {
    where: InventoryScalarWhereInput
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyWithoutProductInput>
  }

  export type InventoryScalarWhereInput = {
    AND?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
    OR?: InventoryScalarWhereInput[]
    NOT?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
    id?: StringFilter<"Inventory"> | string
    productId?: StringFilter<"Inventory"> | string
    location?: StringFilter<"Inventory"> | string
    quantity?: IntFilter<"Inventory"> | number
    reservedQuantity?: IntFilter<"Inventory"> | number
    availableQuantity?: IntFilter<"Inventory"> | number
    reorderPoint?: IntFilter<"Inventory"> | number
    reorderQuantity?: IntFilter<"Inventory"> | number
    batchNumber?: StringNullableFilter<"Inventory"> | string | null
    serialNumbers?: JsonNullableFilter<"Inventory">
    lastRestocked?: DateTimeNullableFilter<"Inventory"> | Date | string | null
    lastCounted?: DateTimeNullableFilter<"Inventory"> | Date | string | null
    createdAt?: DateTimeFilter<"Inventory"> | Date | string
    updatedAt?: DateTimeFilter<"Inventory"> | Date | string
  }

  export type OrderItemUpsertWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutProductInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutProductInput>
  }

  export type OrderItemScalarWhereInput = {
    AND?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    OR?: OrderItemScalarWhereInput[]
    NOT?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    orderId?: StringFilter<"OrderItem"> | string
    productId?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
    unitPrice?: FloatFilter<"OrderItem"> | number
    totalPrice?: FloatFilter<"OrderItem"> | number
    productSnapshot?: JsonNullableFilter<"OrderItem">
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
  }

  export type CartItemUpsertWithWhereUniqueWithoutProductInput = {
    where: CartItemWhereUniqueInput
    update: XOR<CartItemUpdateWithoutProductInput, CartItemUncheckedUpdateWithoutProductInput>
    create: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput>
  }

  export type CartItemUpdateWithWhereUniqueWithoutProductInput = {
    where: CartItemWhereUniqueInput
    data: XOR<CartItemUpdateWithoutProductInput, CartItemUncheckedUpdateWithoutProductInput>
  }

  export type CartItemUpdateManyWithWhereWithoutProductInput = {
    where: CartItemScalarWhereInput
    data: XOR<CartItemUpdateManyMutationInput, CartItemUncheckedUpdateManyWithoutProductInput>
  }

  export type CartItemScalarWhereInput = {
    AND?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
    OR?: CartItemScalarWhereInput[]
    NOT?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
    id?: StringFilter<"CartItem"> | string
    cartId?: StringFilter<"CartItem"> | string
    productId?: StringFilter<"CartItem"> | string
    quantity?: IntFilter<"CartItem"> | number
    createdAt?: DateTimeFilter<"CartItem"> | Date | string
    updatedAt?: DateTimeFilter<"CartItem"> | Date | string
  }

  export type PriceHistoryUpsertWithWhereUniqueWithoutProductInput = {
    where: PriceHistoryWhereUniqueInput
    update: XOR<PriceHistoryUpdateWithoutProductInput, PriceHistoryUncheckedUpdateWithoutProductInput>
    create: XOR<PriceHistoryCreateWithoutProductInput, PriceHistoryUncheckedCreateWithoutProductInput>
  }

  export type PriceHistoryUpdateWithWhereUniqueWithoutProductInput = {
    where: PriceHistoryWhereUniqueInput
    data: XOR<PriceHistoryUpdateWithoutProductInput, PriceHistoryUncheckedUpdateWithoutProductInput>
  }

  export type PriceHistoryUpdateManyWithWhereWithoutProductInput = {
    where: PriceHistoryScalarWhereInput
    data: XOR<PriceHistoryUpdateManyMutationInput, PriceHistoryUncheckedUpdateManyWithoutProductInput>
  }

  export type PriceHistoryScalarWhereInput = {
    AND?: PriceHistoryScalarWhereInput | PriceHistoryScalarWhereInput[]
    OR?: PriceHistoryScalarWhereInput[]
    NOT?: PriceHistoryScalarWhereInput | PriceHistoryScalarWhereInput[]
    id?: StringFilter<"PriceHistory"> | string
    productId?: StringFilter<"PriceHistory"> | string
    price?: FloatFilter<"PriceHistory"> | number
    previousPrice?: FloatNullableFilter<"PriceHistory"> | number | null
    currency?: StringFilter<"PriceHistory"> | string
    reason?: StringNullableFilter<"PriceHistory"> | string | null
    effectiveFrom?: DateTimeFilter<"PriceHistory"> | Date | string
    effectiveUntil?: DateTimeNullableFilter<"PriceHistory"> | Date | string | null
    createdAt?: DateTimeFilter<"PriceHistory"> | Date | string
  }

  export type CustomerCreateWithoutOrdersInput = {
    id?: string
    companyName?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    taxId?: string | null
    phoneNumber?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCustomerInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutCustomerInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceCreateNestedManyWithoutCustomerInput
    projects?: ProjectCreateNestedManyWithoutClientInput
    quotes?: QuoteCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutOrdersInput = {
    id?: string
    userId: string
    companyName?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    taxId?: string | null
    phoneNumber?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutCustomerInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutOrdersInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
  }

  export type OrderItemCreateWithoutOrderInput = {
    id?: string
    quantity: number
    unitPrice: number
    totalPrice: number
    productSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutOrderInput = {
    id?: string
    productId: string
    quantity: number
    unitPrice: number
    totalPrice: number
    productSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type OrderItemCreateOrConnectWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemCreateManyOrderInputEnvelope = {
    data: OrderItemCreateManyOrderInput | OrderItemCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutOrderInput = {
    id?: string
    invoiceNumber: string
    type: string
    subtotal: number
    tax: number
    total: number
    currency?: string
    status?: string
    dueDate: Date | string
    paidAt?: Date | string | null
    paymentIntentId?: string | null
    paymentMethod?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutInvoicesInput
    subscription?: SubscriptionCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutOrderInput = {
    id?: string
    invoiceNumber: string
    customerId: string
    type: string
    subscriptionId?: string | null
    subtotal: number
    tax: number
    total: number
    currency?: string
    status?: string
    dueDate: Date | string
    paidAt?: Date | string | null
    paymentIntentId?: string | null
    paymentMethod?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateOrConnectWithoutOrderInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput>
  }

  export type ProjectCreateWithoutOrderInput = {
    id?: string
    projectRef: string
    name: string
    description?: string | null
    service: string
    status?: string
    currentStage?: string
    stagesCompleted?: ProjectCreatestagesCompletedInput | string[]
    quotedAmount?: number | null
    actualCost?: number | null
    invoicedAmount?: number | null
    paidAmount?: number | null
    startDate?: Date | string | null
    targetDate?: Date | string | null
    completedDate?: Date | string | null
    location?: string | null
    notes?: string | null
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    client: CustomerCreateNestedOneWithoutProjectsInput
    documents?: DocumentCreateNestedManyWithoutProjectInput
    stages?: ProjectStageCreateNestedManyWithoutProjectInput
    costs?: MaterialCostCreateNestedManyWithoutProjectInput
    Service?: ServiceCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutOrderInput = {
    id?: string
    projectRef: string
    clientId: string
    name: string
    description?: string | null
    service: string
    status?: string
    currentStage?: string
    stagesCompleted?: ProjectCreatestagesCompletedInput | string[]
    quotedAmount?: number | null
    actualCost?: number | null
    invoicedAmount?: number | null
    paidAmount?: number | null
    startDate?: Date | string | null
    targetDate?: Date | string | null
    completedDate?: Date | string | null
    location?: string | null
    notes?: string | null
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceId?: string | null
    documents?: DocumentUncheckedCreateNestedManyWithoutProjectInput
    stages?: ProjectStageUncheckedCreateNestedManyWithoutProjectInput
    costs?: MaterialCostUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutOrderInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutOrderInput, ProjectUncheckedCreateWithoutOrderInput>
  }

  export type CustomerUpsertWithoutOrdersInput = {
    update: XOR<CustomerUpdateWithoutOrdersInput, CustomerUncheckedUpdateWithoutOrdersInput>
    create: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutOrdersInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutOrdersInput, CustomerUncheckedUpdateWithoutOrdersInput>
  }

  export type CustomerUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCustomerNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutCustomerNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUpdateManyWithoutCustomerNestedInput
    projects?: ProjectUpdateManyWithoutClientNestedInput
    quotes?: QuoteUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutCustomerNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type InvoiceUpsertWithoutOrderInput = {
    update: XOR<InvoiceUpdateWithoutOrderInput, InvoiceUncheckedUpdateWithoutOrderInput>
    create: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutOrderInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutOrderInput, InvoiceUncheckedUpdateWithoutOrderInput>
  }

  export type InvoiceUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutInvoicesNestedInput
    subscription?: SubscriptionUpdateOneWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpsertWithoutOrderInput = {
    update: XOR<ProjectUpdateWithoutOrderInput, ProjectUncheckedUpdateWithoutOrderInput>
    create: XOR<ProjectCreateWithoutOrderInput, ProjectUncheckedCreateWithoutOrderInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutOrderInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutOrderInput, ProjectUncheckedUpdateWithoutOrderInput>
  }

  export type ProjectUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectRef?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentStage?: StringFieldUpdateOperationsInput | string
    stagesCompleted?: ProjectUpdatestagesCompletedInput | string[]
    quotedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    invoicedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: CustomerUpdateOneRequiredWithoutProjectsNestedInput
    documents?: DocumentUpdateManyWithoutProjectNestedInput
    stages?: ProjectStageUpdateManyWithoutProjectNestedInput
    costs?: MaterialCostUpdateManyWithoutProjectNestedInput
    Service?: ServiceUpdateOneWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectRef?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentStage?: StringFieldUpdateOperationsInput | string
    stagesCompleted?: ProjectUpdatestagesCompletedInput | string[]
    quotedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    invoicedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: DocumentUncheckedUpdateManyWithoutProjectNestedInput
    stages?: ProjectStageUncheckedUpdateManyWithoutProjectNestedInput
    costs?: MaterialCostUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type OrderCreateWithoutItemsInput = {
    id?: string
    orderNumber: string
    status?: string
    subtotal: number
    tax: number
    shipping: number
    total: number
    currency?: string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingMethod?: string | null
    trackingNumber?: string | null
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    paymentStatus?: string
    paymentIntentId?: string | null
    paidAt?: Date | string | null
    customerNotes?: string | null
    internalNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutOrdersInput
    invoice?: InvoiceCreateNestedOneWithoutOrderInput
    project?: ProjectCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutItemsInput = {
    id?: string
    orderNumber: string
    customerId: string
    status?: string
    subtotal: number
    tax: number
    shipping: number
    total: number
    currency?: string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingMethod?: string | null
    trackingNumber?: string | null
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    paymentStatus?: string
    paymentIntentId?: string | null
    paidAt?: Date | string | null
    customerNotes?: string | null
    internalNotes?: string | null
    invoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project?: ProjectUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutItemsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutOrderItemsInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    category: string
    basePrice: number
    currency?: string
    specifications?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    priceHistory?: PriceHistoryCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutOrderItemsInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    category: string
    basePrice: number
    currency?: string
    specifications?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    priceHistory?: PriceHistoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutOrderItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
  }

  export type OrderUpsertWithoutItemsInput = {
    update: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutItemsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type OrderUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    shipping?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    invoice?: InvoiceUpdateOneWithoutOrderNestedInput
    project?: ProjectUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    shipping?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type ProductUpsertWithoutOrderItemsInput = {
    update: XOR<ProductUpdateWithoutOrderItemsInput, ProductUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutOrderItemsInput, ProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ProductUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    specifications?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    priceHistory?: PriceHistoryUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    specifications?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    priceHistory?: PriceHistoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type CustomerCreateWithoutSubscriptionsInput = {
    id?: string
    companyName?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    taxId?: string | null
    phoneNumber?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCustomerInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceCreateNestedManyWithoutCustomerInput
    projects?: ProjectCreateNestedManyWithoutClientInput
    quotes?: QuoteCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    userId: string
    companyName?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    taxId?: string | null
    phoneNumber?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutSubscriptionsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutSubscriptionsInput, CustomerUncheckedCreateWithoutSubscriptionsInput>
  }

  export type SubscriptionPlanCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    currency?: string
    interval?: string
    features?: NullableJsonNullValueInput | InputJsonValue
    limits?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    currency?: string
    interval?: string
    features?: NullableJsonNullValueInput | InputJsonValue
    limits?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionPlanCreateOrConnectWithoutSubscriptionsInput = {
    where: SubscriptionPlanWhereUniqueInput
    create: XOR<SubscriptionPlanCreateWithoutSubscriptionsInput, SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput>
  }

  export type InvoiceCreateWithoutSubscriptionInput = {
    id?: string
    invoiceNumber: string
    type: string
    subtotal: number
    tax: number
    total: number
    currency?: string
    status?: string
    dueDate: Date | string
    paidAt?: Date | string | null
    paymentIntentId?: string | null
    paymentMethod?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutInvoicesInput
    order?: OrderCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    invoiceNumber: string
    customerId: string
    type: string
    subtotal: number
    tax: number
    total: number
    currency?: string
    status?: string
    dueDate: Date | string
    paidAt?: Date | string | null
    paymentIntentId?: string | null
    paymentMethod?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: OrderUncheckedCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutSubscriptionInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutSubscriptionInput, InvoiceUncheckedCreateWithoutSubscriptionInput>
  }

  export type InvoiceCreateManySubscriptionInputEnvelope = {
    data: InvoiceCreateManySubscriptionInput | InvoiceCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutSubscriptionsInput = {
    update: XOR<CustomerUpdateWithoutSubscriptionsInput, CustomerUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<CustomerCreateWithoutSubscriptionsInput, CustomerUncheckedCreateWithoutSubscriptionsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutSubscriptionsInput, CustomerUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type CustomerUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCustomerNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutCustomerNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUpdateManyWithoutCustomerNestedInput
    projects?: ProjectUpdateManyWithoutClientNestedInput
    quotes?: QuoteUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutCustomerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type SubscriptionPlanUpsertWithoutSubscriptionsInput = {
    update: XOR<SubscriptionPlanUpdateWithoutSubscriptionsInput, SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<SubscriptionPlanCreateWithoutSubscriptionsInput, SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput>
    where?: SubscriptionPlanWhereInput
  }

  export type SubscriptionPlanUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: SubscriptionPlanWhereInput
    data: XOR<SubscriptionPlanUpdateWithoutSubscriptionsInput, SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type SubscriptionPlanUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    features?: NullableJsonNullValueInput | InputJsonValue
    limits?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    features?: NullableJsonNullValueInput | InputJsonValue
    limits?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutSubscriptionInput, InvoiceUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<InvoiceCreateWithoutSubscriptionInput, InvoiceUncheckedCreateWithoutSubscriptionInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutSubscriptionInput, InvoiceUncheckedUpdateWithoutSubscriptionInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutSubscriptionInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type SubscriptionCreateWithoutPlanInput = {
    id?: string
    status?: string
    billingCycle?: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    nextBillingDate: Date | string
    stripeSubscriptionId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutSubscriptionsInput
    invoices?: InvoiceCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutPlanInput = {
    id?: string
    customerId: string
    status?: string
    billingCycle?: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    nextBillingDate: Date | string
    stripeSubscriptionId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type SubscriptionCreateManyPlanInputEnvelope = {
    data: SubscriptionCreateManyPlanInput | SubscriptionCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutPlanInput, SubscriptionUncheckedUpdateWithoutPlanInput>
    create: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutPlanInput, SubscriptionUncheckedUpdateWithoutPlanInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutPlanInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutPlanInput>
  }

  export type CustomerCreateWithoutInvoicesInput = {
    id?: string
    companyName?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    taxId?: string | null
    phoneNumber?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCustomerInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCustomerInput
    projects?: ProjectCreateNestedManyWithoutClientInput
    quotes?: QuoteCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutInvoicesInput = {
    id?: string
    userId: string
    companyName?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    taxId?: string | null
    phoneNumber?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCustomerInput
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutInvoicesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutInvoicesInput, CustomerUncheckedCreateWithoutInvoicesInput>
  }

  export type OrderCreateWithoutInvoiceInput = {
    id?: string
    orderNumber: string
    status?: string
    subtotal: number
    tax: number
    shipping: number
    total: number
    currency?: string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingMethod?: string | null
    trackingNumber?: string | null
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    paymentStatus?: string
    paymentIntentId?: string | null
    paidAt?: Date | string | null
    customerNotes?: string | null
    internalNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    project?: ProjectCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutInvoiceInput = {
    id?: string
    orderNumber: string
    customerId: string
    status?: string
    subtotal: number
    tax: number
    shipping: number
    total: number
    currency?: string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingMethod?: string | null
    trackingNumber?: string | null
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    paymentStatus?: string
    paymentIntentId?: string | null
    paidAt?: Date | string | null
    customerNotes?: string | null
    internalNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    project?: ProjectUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutInvoiceInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutInvoiceInput, OrderUncheckedCreateWithoutInvoiceInput>
  }

  export type SubscriptionCreateWithoutInvoicesInput = {
    id?: string
    status?: string
    billingCycle?: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    nextBillingDate: Date | string
    stripeSubscriptionId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutSubscriptionsInput
    plan: SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedCreateWithoutInvoicesInput = {
    id?: string
    customerId: string
    status?: string
    planId: string
    billingCycle?: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    nextBillingDate: Date | string
    stripeSubscriptionId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateOrConnectWithoutInvoicesInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutInvoicesInput, SubscriptionUncheckedCreateWithoutInvoicesInput>
  }

  export type CustomerUpsertWithoutInvoicesInput = {
    update: XOR<CustomerUpdateWithoutInvoicesInput, CustomerUncheckedUpdateWithoutInvoicesInput>
    create: XOR<CustomerCreateWithoutInvoicesInput, CustomerUncheckedCreateWithoutInvoicesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutInvoicesInput, CustomerUncheckedUpdateWithoutInvoicesInput>
  }

  export type CustomerUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCustomerNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutCustomerNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCustomerNestedInput
    projects?: ProjectUpdateManyWithoutClientNestedInput
    quotes?: QuoteUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutCustomerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCustomerNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type OrderUpsertWithoutInvoiceInput = {
    update: XOR<OrderUpdateWithoutInvoiceInput, OrderUncheckedUpdateWithoutInvoiceInput>
    create: XOR<OrderCreateWithoutInvoiceInput, OrderUncheckedCreateWithoutInvoiceInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutInvoiceInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutInvoiceInput, OrderUncheckedUpdateWithoutInvoiceInput>
  }

  export type OrderUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    shipping?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    project?: ProjectUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    shipping?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    project?: ProjectUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type SubscriptionUpsertWithoutInvoicesInput = {
    update: XOR<SubscriptionUpdateWithoutInvoicesInput, SubscriptionUncheckedUpdateWithoutInvoicesInput>
    create: XOR<SubscriptionCreateWithoutInvoicesInput, SubscriptionUncheckedCreateWithoutInvoicesInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutInvoicesInput, SubscriptionUncheckedUpdateWithoutInvoicesInput>
  }

  export type SubscriptionUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    billingCycle?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutSubscriptionsNestedInput
    plan?: SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    billingCycle?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateWithoutPaymentMethodsInput = {
    id?: string
    companyName?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    taxId?: string | null
    phoneNumber?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceCreateNestedManyWithoutCustomerInput
    projects?: ProjectCreateNestedManyWithoutClientInput
    quotes?: QuoteCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutPaymentMethodsInput = {
    id?: string
    userId: string
    companyName?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    taxId?: string | null
    phoneNumber?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutPaymentMethodsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutPaymentMethodsInput, CustomerUncheckedCreateWithoutPaymentMethodsInput>
  }

  export type CustomerUpsertWithoutPaymentMethodsInput = {
    update: XOR<CustomerUpdateWithoutPaymentMethodsInput, CustomerUncheckedUpdateWithoutPaymentMethodsInput>
    create: XOR<CustomerCreateWithoutPaymentMethodsInput, CustomerUncheckedCreateWithoutPaymentMethodsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutPaymentMethodsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutPaymentMethodsInput, CustomerUncheckedUpdateWithoutPaymentMethodsInput>
  }

  export type CustomerUpdateWithoutPaymentMethodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCustomerNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUpdateManyWithoutCustomerNestedInput
    projects?: ProjectUpdateManyWithoutClientNestedInput
    quotes?: QuoteUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutPaymentMethodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type ProductCreateWithoutInventoryItemsInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    category: string
    basePrice: number
    currency?: string
    specifications?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    priceHistory?: PriceHistoryCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutInventoryItemsInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    category: string
    basePrice: number
    currency?: string
    specifications?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    priceHistory?: PriceHistoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutInventoryItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutInventoryItemsInput, ProductUncheckedCreateWithoutInventoryItemsInput>
  }

  export type ProductUpsertWithoutInventoryItemsInput = {
    update: XOR<ProductUpdateWithoutInventoryItemsInput, ProductUncheckedUpdateWithoutInventoryItemsInput>
    create: XOR<ProductCreateWithoutInventoryItemsInput, ProductUncheckedCreateWithoutInventoryItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutInventoryItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutInventoryItemsInput, ProductUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type ProductUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    specifications?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    priceHistory?: PriceHistoryUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    specifications?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    priceHistory?: PriceHistoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type UserCreateWithoutCartInput = {
    id?: string
    email?: string | null
    name?: string | null
    password?: string | null
    role?: string
    externalId?: string | null
    mondayUserId?: string | null
    copilotUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: ChatSessionCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutUserInput
    customer?: CustomerCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCartInput = {
    id?: string
    email?: string | null
    name?: string | null
    password?: string | null
    role?: string
    externalId?: string | null
    mondayUserId?: string | null
    copilotUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: ChatSessionUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    customer?: CustomerUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCartInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCartInput, UserUncheckedCreateWithoutCartInput>
  }

  export type CartItemCreateWithoutCartInput = {
    id?: string
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutCartItemsInput
  }

  export type CartItemUncheckedCreateWithoutCartInput = {
    id?: string
    productId: string
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartItemCreateOrConnectWithoutCartInput = {
    where: CartItemWhereUniqueInput
    create: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput>
  }

  export type CartItemCreateManyCartInputEnvelope = {
    data: CartItemCreateManyCartInput | CartItemCreateManyCartInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCartInput = {
    update: XOR<UserUpdateWithoutCartInput, UserUncheckedUpdateWithoutCartInput>
    create: XOR<UserCreateWithoutCartInput, UserUncheckedCreateWithoutCartInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCartInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCartInput, UserUncheckedUpdateWithoutCartInput>
  }

  export type UserUpdateWithoutCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    mondayUserId?: NullableStringFieldUpdateOperationsInput | string | null
    copilotUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: ChatSessionUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    customer?: CustomerUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    mondayUserId?: NullableStringFieldUpdateOperationsInput | string | null
    copilotUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: ChatSessionUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    customer?: CustomerUncheckedUpdateOneWithoutUserNestedInput
  }

  export type CartItemUpsertWithWhereUniqueWithoutCartInput = {
    where: CartItemWhereUniqueInput
    update: XOR<CartItemUpdateWithoutCartInput, CartItemUncheckedUpdateWithoutCartInput>
    create: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput>
  }

  export type CartItemUpdateWithWhereUniqueWithoutCartInput = {
    where: CartItemWhereUniqueInput
    data: XOR<CartItemUpdateWithoutCartInput, CartItemUncheckedUpdateWithoutCartInput>
  }

  export type CartItemUpdateManyWithWhereWithoutCartInput = {
    where: CartItemScalarWhereInput
    data: XOR<CartItemUpdateManyMutationInput, CartItemUncheckedUpdateManyWithoutCartInput>
  }

  export type CartCreateWithoutItemsInput = {
    id?: string
    sessionId?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutCartInput
  }

  export type CartUncheckedCreateWithoutItemsInput = {
    id?: string
    sessionId?: string | null
    userId?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartCreateOrConnectWithoutItemsInput = {
    where: CartWhereUniqueInput
    create: XOR<CartCreateWithoutItemsInput, CartUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutCartItemsInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    category: string
    basePrice: number
    currency?: string
    specifications?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    priceHistory?: PriceHistoryCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCartItemsInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    category: string
    basePrice: number
    currency?: string
    specifications?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    priceHistory?: PriceHistoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCartItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCartItemsInput, ProductUncheckedCreateWithoutCartItemsInput>
  }

  export type CartUpsertWithoutItemsInput = {
    update: XOR<CartUpdateWithoutItemsInput, CartUncheckedUpdateWithoutItemsInput>
    create: XOR<CartCreateWithoutItemsInput, CartUncheckedCreateWithoutItemsInput>
    where?: CartWhereInput
  }

  export type CartUpdateToOneWithWhereWithoutItemsInput = {
    where?: CartWhereInput
    data: XOR<CartUpdateWithoutItemsInput, CartUncheckedUpdateWithoutItemsInput>
  }

  export type CartUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutCartNestedInput
  }

  export type CartUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpsertWithoutCartItemsInput = {
    update: XOR<ProductUpdateWithoutCartItemsInput, ProductUncheckedUpdateWithoutCartItemsInput>
    create: XOR<ProductCreateWithoutCartItemsInput, ProductUncheckedCreateWithoutCartItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutCartItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutCartItemsInput, ProductUncheckedUpdateWithoutCartItemsInput>
  }

  export type ProductUpdateWithoutCartItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    specifications?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    priceHistory?: PriceHistoryUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCartItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    specifications?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    priceHistory?: PriceHistoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateWithoutPriceHistoryInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    category: string
    basePrice: number
    currency?: string
    specifications?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutPriceHistoryInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    category: string
    basePrice: number
    currency?: string
    specifications?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutPriceHistoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutPriceHistoryInput, ProductUncheckedCreateWithoutPriceHistoryInput>
  }

  export type ProductUpsertWithoutPriceHistoryInput = {
    update: XOR<ProductUpdateWithoutPriceHistoryInput, ProductUncheckedUpdateWithoutPriceHistoryInput>
    create: XOR<ProductCreateWithoutPriceHistoryInput, ProductUncheckedCreateWithoutPriceHistoryInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutPriceHistoryInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutPriceHistoryInput, ProductUncheckedUpdateWithoutPriceHistoryInput>
  }

  export type ProductUpdateWithoutPriceHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    specifications?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutPriceHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    specifications?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type QuizResponseCreateWithoutSessionInput = {
    id?: string
    questionId: string
    questionType: string
    responseValue: JsonNullValueInput | InputJsonValue
    responseTime?: number | null
    createdAt?: Date | string
  }

  export type QuizResponseUncheckedCreateWithoutSessionInput = {
    id?: string
    questionId: string
    questionType: string
    responseValue: JsonNullValueInput | InputJsonValue
    responseTime?: number | null
    createdAt?: Date | string
  }

  export type QuizResponseCreateOrConnectWithoutSessionInput = {
    where: QuizResponseWhereUniqueInput
    create: XOR<QuizResponseCreateWithoutSessionInput, QuizResponseUncheckedCreateWithoutSessionInput>
  }

  export type QuizResponseCreateManySessionInputEnvelope = {
    data: QuizResponseCreateManySessionInput | QuizResponseCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type BehavioralInteractionCreateWithoutSessionInput = {
    id?: string
    interactionType: string
    element?: string | null
    position?: NullableJsonNullValueInput | InputJsonValue
    viewport?: NullableJsonNullValueInput | InputJsonValue
    duration?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type BehavioralInteractionUncheckedCreateWithoutSessionInput = {
    id?: string
    interactionType: string
    element?: string | null
    position?: NullableJsonNullValueInput | InputJsonValue
    viewport?: NullableJsonNullValueInput | InputJsonValue
    duration?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type BehavioralInteractionCreateOrConnectWithoutSessionInput = {
    where: BehavioralInteractionWhereUniqueInput
    create: XOR<BehavioralInteractionCreateWithoutSessionInput, BehavioralInteractionUncheckedCreateWithoutSessionInput>
  }

  export type BehavioralInteractionCreateManySessionInputEnvelope = {
    data: BehavioralInteractionCreateManySessionInput | BehavioralInteractionCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type QuizConversionCreateWithoutSessionInput = {
    id?: string
    conversionType: string
    conversionValue?: number | null
    orderId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type QuizConversionUncheckedCreateWithoutSessionInput = {
    id?: string
    conversionType: string
    conversionValue?: number | null
    orderId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type QuizConversionCreateOrConnectWithoutSessionInput = {
    where: QuizConversionWhereUniqueInput
    create: XOR<QuizConversionCreateWithoutSessionInput, QuizConversionUncheckedCreateWithoutSessionInput>
  }

  export type QuizConversionCreateManySessionInputEnvelope = {
    data: QuizConversionCreateManySessionInput | QuizConversionCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type QuizResponseUpsertWithWhereUniqueWithoutSessionInput = {
    where: QuizResponseWhereUniqueInput
    update: XOR<QuizResponseUpdateWithoutSessionInput, QuizResponseUncheckedUpdateWithoutSessionInput>
    create: XOR<QuizResponseCreateWithoutSessionInput, QuizResponseUncheckedCreateWithoutSessionInput>
  }

  export type QuizResponseUpdateWithWhereUniqueWithoutSessionInput = {
    where: QuizResponseWhereUniqueInput
    data: XOR<QuizResponseUpdateWithoutSessionInput, QuizResponseUncheckedUpdateWithoutSessionInput>
  }

  export type QuizResponseUpdateManyWithWhereWithoutSessionInput = {
    where: QuizResponseScalarWhereInput
    data: XOR<QuizResponseUpdateManyMutationInput, QuizResponseUncheckedUpdateManyWithoutSessionInput>
  }

  export type QuizResponseScalarWhereInput = {
    AND?: QuizResponseScalarWhereInput | QuizResponseScalarWhereInput[]
    OR?: QuizResponseScalarWhereInput[]
    NOT?: QuizResponseScalarWhereInput | QuizResponseScalarWhereInput[]
    id?: StringFilter<"QuizResponse"> | string
    sessionId?: StringFilter<"QuizResponse"> | string
    questionId?: StringFilter<"QuizResponse"> | string
    questionType?: StringFilter<"QuizResponse"> | string
    responseValue?: JsonFilter<"QuizResponse">
    responseTime?: IntNullableFilter<"QuizResponse"> | number | null
    createdAt?: DateTimeFilter<"QuizResponse"> | Date | string
  }

  export type BehavioralInteractionUpsertWithWhereUniqueWithoutSessionInput = {
    where: BehavioralInteractionWhereUniqueInput
    update: XOR<BehavioralInteractionUpdateWithoutSessionInput, BehavioralInteractionUncheckedUpdateWithoutSessionInput>
    create: XOR<BehavioralInteractionCreateWithoutSessionInput, BehavioralInteractionUncheckedCreateWithoutSessionInput>
  }

  export type BehavioralInteractionUpdateWithWhereUniqueWithoutSessionInput = {
    where: BehavioralInteractionWhereUniqueInput
    data: XOR<BehavioralInteractionUpdateWithoutSessionInput, BehavioralInteractionUncheckedUpdateWithoutSessionInput>
  }

  export type BehavioralInteractionUpdateManyWithWhereWithoutSessionInput = {
    where: BehavioralInteractionScalarWhereInput
    data: XOR<BehavioralInteractionUpdateManyMutationInput, BehavioralInteractionUncheckedUpdateManyWithoutSessionInput>
  }

  export type BehavioralInteractionScalarWhereInput = {
    AND?: BehavioralInteractionScalarWhereInput | BehavioralInteractionScalarWhereInput[]
    OR?: BehavioralInteractionScalarWhereInput[]
    NOT?: BehavioralInteractionScalarWhereInput | BehavioralInteractionScalarWhereInput[]
    id?: StringFilter<"BehavioralInteraction"> | string
    sessionId?: StringFilter<"BehavioralInteraction"> | string
    interactionType?: StringFilter<"BehavioralInteraction"> | string
    element?: StringNullableFilter<"BehavioralInteraction"> | string | null
    position?: JsonNullableFilter<"BehavioralInteraction">
    viewport?: JsonNullableFilter<"BehavioralInteraction">
    duration?: IntNullableFilter<"BehavioralInteraction"> | number | null
    metadata?: JsonNullableFilter<"BehavioralInteraction">
    timestamp?: DateTimeFilter<"BehavioralInteraction"> | Date | string
  }

  export type QuizConversionUpsertWithWhereUniqueWithoutSessionInput = {
    where: QuizConversionWhereUniqueInput
    update: XOR<QuizConversionUpdateWithoutSessionInput, QuizConversionUncheckedUpdateWithoutSessionInput>
    create: XOR<QuizConversionCreateWithoutSessionInput, QuizConversionUncheckedCreateWithoutSessionInput>
  }

  export type QuizConversionUpdateWithWhereUniqueWithoutSessionInput = {
    where: QuizConversionWhereUniqueInput
    data: XOR<QuizConversionUpdateWithoutSessionInput, QuizConversionUncheckedUpdateWithoutSessionInput>
  }

  export type QuizConversionUpdateManyWithWhereWithoutSessionInput = {
    where: QuizConversionScalarWhereInput
    data: XOR<QuizConversionUpdateManyMutationInput, QuizConversionUncheckedUpdateManyWithoutSessionInput>
  }

  export type QuizConversionScalarWhereInput = {
    AND?: QuizConversionScalarWhereInput | QuizConversionScalarWhereInput[]
    OR?: QuizConversionScalarWhereInput[]
    NOT?: QuizConversionScalarWhereInput | QuizConversionScalarWhereInput[]
    id?: StringFilter<"QuizConversion"> | string
    sessionId?: StringFilter<"QuizConversion"> | string
    conversionType?: StringFilter<"QuizConversion"> | string
    conversionValue?: FloatNullableFilter<"QuizConversion"> | number | null
    orderId?: StringNullableFilter<"QuizConversion"> | string | null
    metadata?: JsonNullableFilter<"QuizConversion">
    createdAt?: DateTimeFilter<"QuizConversion"> | Date | string
  }

  export type QuizSessionCreateWithoutResponsesInput = {
    id?: string
    sessionId: string
    quizId: string
    source?: string | null
    utmSource?: string | null
    utmMedium?: string | null
    utmCampaign?: string | null
    utmContent?: string | null
    contentId?: string | null
    campaignId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    landingPage?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    status?: string
    createdAt?: Date | string
    startTime?: Date | string
    endTime?: Date | string | null
    completionRate?: number | null
    userName?: string | null
    email?: string | null
    phoneNumber?: string | null
    companyName?: string | null
    userType?: string | null
    selectedBrand?: string | null
    userSegment?: string | null
    crewSize?: number | null
    leadQualityScore?: number | null
    version?: string | null
    interactions?: BehavioralInteractionCreateNestedManyWithoutSessionInput
    conversions?: QuizConversionCreateNestedManyWithoutSessionInput
  }

  export type QuizSessionUncheckedCreateWithoutResponsesInput = {
    id?: string
    sessionId: string
    quizId: string
    source?: string | null
    utmSource?: string | null
    utmMedium?: string | null
    utmCampaign?: string | null
    utmContent?: string | null
    contentId?: string | null
    campaignId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    landingPage?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    status?: string
    createdAt?: Date | string
    startTime?: Date | string
    endTime?: Date | string | null
    completionRate?: number | null
    userName?: string | null
    email?: string | null
    phoneNumber?: string | null
    companyName?: string | null
    userType?: string | null
    selectedBrand?: string | null
    userSegment?: string | null
    crewSize?: number | null
    leadQualityScore?: number | null
    version?: string | null
    interactions?: BehavioralInteractionUncheckedCreateNestedManyWithoutSessionInput
    conversions?: QuizConversionUncheckedCreateNestedManyWithoutSessionInput
  }

  export type QuizSessionCreateOrConnectWithoutResponsesInput = {
    where: QuizSessionWhereUniqueInput
    create: XOR<QuizSessionCreateWithoutResponsesInput, QuizSessionUncheckedCreateWithoutResponsesInput>
  }

  export type QuizSessionUpsertWithoutResponsesInput = {
    update: XOR<QuizSessionUpdateWithoutResponsesInput, QuizSessionUncheckedUpdateWithoutResponsesInput>
    create: XOR<QuizSessionCreateWithoutResponsesInput, QuizSessionUncheckedCreateWithoutResponsesInput>
    where?: QuizSessionWhereInput
  }

  export type QuizSessionUpdateToOneWithWhereWithoutResponsesInput = {
    where?: QuizSessionWhereInput
    data: XOR<QuizSessionUpdateWithoutResponsesInput, QuizSessionUncheckedUpdateWithoutResponsesInput>
  }

  export type QuizSessionUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    utmSource?: NullableStringFieldUpdateOperationsInput | string | null
    utmMedium?: NullableStringFieldUpdateOperationsInput | string | null
    utmCampaign?: NullableStringFieldUpdateOperationsInput | string | null
    utmContent?: NullableStringFieldUpdateOperationsInput | string | null
    contentId?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    landingPage?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: NullableStringFieldUpdateOperationsInput | string | null
    selectedBrand?: NullableStringFieldUpdateOperationsInput | string | null
    userSegment?: NullableStringFieldUpdateOperationsInput | string | null
    crewSize?: NullableIntFieldUpdateOperationsInput | number | null
    leadQualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    interactions?: BehavioralInteractionUpdateManyWithoutSessionNestedInput
    conversions?: QuizConversionUpdateManyWithoutSessionNestedInput
  }

  export type QuizSessionUncheckedUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    utmSource?: NullableStringFieldUpdateOperationsInput | string | null
    utmMedium?: NullableStringFieldUpdateOperationsInput | string | null
    utmCampaign?: NullableStringFieldUpdateOperationsInput | string | null
    utmContent?: NullableStringFieldUpdateOperationsInput | string | null
    contentId?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    landingPage?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: NullableStringFieldUpdateOperationsInput | string | null
    selectedBrand?: NullableStringFieldUpdateOperationsInput | string | null
    userSegment?: NullableStringFieldUpdateOperationsInput | string | null
    crewSize?: NullableIntFieldUpdateOperationsInput | number | null
    leadQualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    interactions?: BehavioralInteractionUncheckedUpdateManyWithoutSessionNestedInput
    conversions?: QuizConversionUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type QuizSessionCreateWithoutInteractionsInput = {
    id?: string
    sessionId: string
    quizId: string
    source?: string | null
    utmSource?: string | null
    utmMedium?: string | null
    utmCampaign?: string | null
    utmContent?: string | null
    contentId?: string | null
    campaignId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    landingPage?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    status?: string
    createdAt?: Date | string
    startTime?: Date | string
    endTime?: Date | string | null
    completionRate?: number | null
    userName?: string | null
    email?: string | null
    phoneNumber?: string | null
    companyName?: string | null
    userType?: string | null
    selectedBrand?: string | null
    userSegment?: string | null
    crewSize?: number | null
    leadQualityScore?: number | null
    version?: string | null
    responses?: QuizResponseCreateNestedManyWithoutSessionInput
    conversions?: QuizConversionCreateNestedManyWithoutSessionInput
  }

  export type QuizSessionUncheckedCreateWithoutInteractionsInput = {
    id?: string
    sessionId: string
    quizId: string
    source?: string | null
    utmSource?: string | null
    utmMedium?: string | null
    utmCampaign?: string | null
    utmContent?: string | null
    contentId?: string | null
    campaignId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    landingPage?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    status?: string
    createdAt?: Date | string
    startTime?: Date | string
    endTime?: Date | string | null
    completionRate?: number | null
    userName?: string | null
    email?: string | null
    phoneNumber?: string | null
    companyName?: string | null
    userType?: string | null
    selectedBrand?: string | null
    userSegment?: string | null
    crewSize?: number | null
    leadQualityScore?: number | null
    version?: string | null
    responses?: QuizResponseUncheckedCreateNestedManyWithoutSessionInput
    conversions?: QuizConversionUncheckedCreateNestedManyWithoutSessionInput
  }

  export type QuizSessionCreateOrConnectWithoutInteractionsInput = {
    where: QuizSessionWhereUniqueInput
    create: XOR<QuizSessionCreateWithoutInteractionsInput, QuizSessionUncheckedCreateWithoutInteractionsInput>
  }

  export type QuizSessionUpsertWithoutInteractionsInput = {
    update: XOR<QuizSessionUpdateWithoutInteractionsInput, QuizSessionUncheckedUpdateWithoutInteractionsInput>
    create: XOR<QuizSessionCreateWithoutInteractionsInput, QuizSessionUncheckedCreateWithoutInteractionsInput>
    where?: QuizSessionWhereInput
  }

  export type QuizSessionUpdateToOneWithWhereWithoutInteractionsInput = {
    where?: QuizSessionWhereInput
    data: XOR<QuizSessionUpdateWithoutInteractionsInput, QuizSessionUncheckedUpdateWithoutInteractionsInput>
  }

  export type QuizSessionUpdateWithoutInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    utmSource?: NullableStringFieldUpdateOperationsInput | string | null
    utmMedium?: NullableStringFieldUpdateOperationsInput | string | null
    utmCampaign?: NullableStringFieldUpdateOperationsInput | string | null
    utmContent?: NullableStringFieldUpdateOperationsInput | string | null
    contentId?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    landingPage?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: NullableStringFieldUpdateOperationsInput | string | null
    selectedBrand?: NullableStringFieldUpdateOperationsInput | string | null
    userSegment?: NullableStringFieldUpdateOperationsInput | string | null
    crewSize?: NullableIntFieldUpdateOperationsInput | number | null
    leadQualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    responses?: QuizResponseUpdateManyWithoutSessionNestedInput
    conversions?: QuizConversionUpdateManyWithoutSessionNestedInput
  }

  export type QuizSessionUncheckedUpdateWithoutInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    utmSource?: NullableStringFieldUpdateOperationsInput | string | null
    utmMedium?: NullableStringFieldUpdateOperationsInput | string | null
    utmCampaign?: NullableStringFieldUpdateOperationsInput | string | null
    utmContent?: NullableStringFieldUpdateOperationsInput | string | null
    contentId?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    landingPage?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: NullableStringFieldUpdateOperationsInput | string | null
    selectedBrand?: NullableStringFieldUpdateOperationsInput | string | null
    userSegment?: NullableStringFieldUpdateOperationsInput | string | null
    crewSize?: NullableIntFieldUpdateOperationsInput | number | null
    leadQualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    responses?: QuizResponseUncheckedUpdateManyWithoutSessionNestedInput
    conversions?: QuizConversionUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type QuizSessionCreateWithoutConversionsInput = {
    id?: string
    sessionId: string
    quizId: string
    source?: string | null
    utmSource?: string | null
    utmMedium?: string | null
    utmCampaign?: string | null
    utmContent?: string | null
    contentId?: string | null
    campaignId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    landingPage?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    status?: string
    createdAt?: Date | string
    startTime?: Date | string
    endTime?: Date | string | null
    completionRate?: number | null
    userName?: string | null
    email?: string | null
    phoneNumber?: string | null
    companyName?: string | null
    userType?: string | null
    selectedBrand?: string | null
    userSegment?: string | null
    crewSize?: number | null
    leadQualityScore?: number | null
    version?: string | null
    responses?: QuizResponseCreateNestedManyWithoutSessionInput
    interactions?: BehavioralInteractionCreateNestedManyWithoutSessionInput
  }

  export type QuizSessionUncheckedCreateWithoutConversionsInput = {
    id?: string
    sessionId: string
    quizId: string
    source?: string | null
    utmSource?: string | null
    utmMedium?: string | null
    utmCampaign?: string | null
    utmContent?: string | null
    contentId?: string | null
    campaignId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    landingPage?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    status?: string
    createdAt?: Date | string
    startTime?: Date | string
    endTime?: Date | string | null
    completionRate?: number | null
    userName?: string | null
    email?: string | null
    phoneNumber?: string | null
    companyName?: string | null
    userType?: string | null
    selectedBrand?: string | null
    userSegment?: string | null
    crewSize?: number | null
    leadQualityScore?: number | null
    version?: string | null
    responses?: QuizResponseUncheckedCreateNestedManyWithoutSessionInput
    interactions?: BehavioralInteractionUncheckedCreateNestedManyWithoutSessionInput
  }

  export type QuizSessionCreateOrConnectWithoutConversionsInput = {
    where: QuizSessionWhereUniqueInput
    create: XOR<QuizSessionCreateWithoutConversionsInput, QuizSessionUncheckedCreateWithoutConversionsInput>
  }

  export type QuizSessionUpsertWithoutConversionsInput = {
    update: XOR<QuizSessionUpdateWithoutConversionsInput, QuizSessionUncheckedUpdateWithoutConversionsInput>
    create: XOR<QuizSessionCreateWithoutConversionsInput, QuizSessionUncheckedCreateWithoutConversionsInput>
    where?: QuizSessionWhereInput
  }

  export type QuizSessionUpdateToOneWithWhereWithoutConversionsInput = {
    where?: QuizSessionWhereInput
    data: XOR<QuizSessionUpdateWithoutConversionsInput, QuizSessionUncheckedUpdateWithoutConversionsInput>
  }

  export type QuizSessionUpdateWithoutConversionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    utmSource?: NullableStringFieldUpdateOperationsInput | string | null
    utmMedium?: NullableStringFieldUpdateOperationsInput | string | null
    utmCampaign?: NullableStringFieldUpdateOperationsInput | string | null
    utmContent?: NullableStringFieldUpdateOperationsInput | string | null
    contentId?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    landingPage?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: NullableStringFieldUpdateOperationsInput | string | null
    selectedBrand?: NullableStringFieldUpdateOperationsInput | string | null
    userSegment?: NullableStringFieldUpdateOperationsInput | string | null
    crewSize?: NullableIntFieldUpdateOperationsInput | number | null
    leadQualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    responses?: QuizResponseUpdateManyWithoutSessionNestedInput
    interactions?: BehavioralInteractionUpdateManyWithoutSessionNestedInput
  }

  export type QuizSessionUncheckedUpdateWithoutConversionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    utmSource?: NullableStringFieldUpdateOperationsInput | string | null
    utmMedium?: NullableStringFieldUpdateOperationsInput | string | null
    utmCampaign?: NullableStringFieldUpdateOperationsInput | string | null
    utmContent?: NullableStringFieldUpdateOperationsInput | string | null
    contentId?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    landingPage?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: NullableStringFieldUpdateOperationsInput | string | null
    selectedBrand?: NullableStringFieldUpdateOperationsInput | string | null
    userSegment?: NullableStringFieldUpdateOperationsInput | string | null
    crewSize?: NullableIntFieldUpdateOperationsInput | number | null
    leadQualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    responses?: QuizResponseUncheckedUpdateManyWithoutSessionNestedInput
    interactions?: BehavioralInteractionUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type ProjectCreateWithoutServiceInput = {
    id?: string
    projectRef: string
    name: string
    description?: string | null
    service: string
    status?: string
    currentStage?: string
    stagesCompleted?: ProjectCreatestagesCompletedInput | string[]
    quotedAmount?: number | null
    actualCost?: number | null
    invoicedAmount?: number | null
    paidAmount?: number | null
    startDate?: Date | string | null
    targetDate?: Date | string | null
    completedDate?: Date | string | null
    location?: string | null
    notes?: string | null
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    client: CustomerCreateNestedOneWithoutProjectsInput
    documents?: DocumentCreateNestedManyWithoutProjectInput
    stages?: ProjectStageCreateNestedManyWithoutProjectInput
    costs?: MaterialCostCreateNestedManyWithoutProjectInput
    order?: OrderCreateNestedOneWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutServiceInput = {
    id?: string
    projectRef: string
    clientId: string
    name: string
    description?: string | null
    service: string
    status?: string
    currentStage?: string
    stagesCompleted?: ProjectCreatestagesCompletedInput | string[]
    quotedAmount?: number | null
    actualCost?: number | null
    invoicedAmount?: number | null
    paidAmount?: number | null
    startDate?: Date | string | null
    targetDate?: Date | string | null
    completedDate?: Date | string | null
    location?: string | null
    notes?: string | null
    priority?: string
    orderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutProjectInput
    stages?: ProjectStageUncheckedCreateNestedManyWithoutProjectInput
    costs?: MaterialCostUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutServiceInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutServiceInput, ProjectUncheckedCreateWithoutServiceInput>
  }

  export type ProjectCreateManyServiceInputEnvelope = {
    data: ProjectCreateManyServiceInput | ProjectCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type QuoteCreateWithoutServiceInput = {
    id?: string
    quoteNumber: string
    title: string
    description?: string | null
    services: JsonNullValueInput | InputJsonValue
    subtotal: number
    tax: number
    total: number
    currency?: string
    validUntil: Date | string
    status?: string
    terms?: string | null
    notes?: string | null
    convertedToProjectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutQuotesInput
  }

  export type QuoteUncheckedCreateWithoutServiceInput = {
    id?: string
    quoteNumber: string
    customerId: string
    title: string
    description?: string | null
    services: JsonNullValueInput | InputJsonValue
    subtotal: number
    tax: number
    total: number
    currency?: string
    validUntil: Date | string
    status?: string
    terms?: string | null
    notes?: string | null
    convertedToProjectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuoteCreateOrConnectWithoutServiceInput = {
    where: QuoteWhereUniqueInput
    create: XOR<QuoteCreateWithoutServiceInput, QuoteUncheckedCreateWithoutServiceInput>
  }

  export type QuoteCreateManyServiceInputEnvelope = {
    data: QuoteCreateManyServiceInput | QuoteCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithWhereUniqueWithoutServiceInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutServiceInput, ProjectUncheckedUpdateWithoutServiceInput>
    create: XOR<ProjectCreateWithoutServiceInput, ProjectUncheckedCreateWithoutServiceInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutServiceInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutServiceInput, ProjectUncheckedUpdateWithoutServiceInput>
  }

  export type ProjectUpdateManyWithWhereWithoutServiceInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutServiceInput>
  }

  export type QuoteUpsertWithWhereUniqueWithoutServiceInput = {
    where: QuoteWhereUniqueInput
    update: XOR<QuoteUpdateWithoutServiceInput, QuoteUncheckedUpdateWithoutServiceInput>
    create: XOR<QuoteCreateWithoutServiceInput, QuoteUncheckedCreateWithoutServiceInput>
  }

  export type QuoteUpdateWithWhereUniqueWithoutServiceInput = {
    where: QuoteWhereUniqueInput
    data: XOR<QuoteUpdateWithoutServiceInput, QuoteUncheckedUpdateWithoutServiceInput>
  }

  export type QuoteUpdateManyWithWhereWithoutServiceInput = {
    where: QuoteScalarWhereInput
    data: XOR<QuoteUpdateManyMutationInput, QuoteUncheckedUpdateManyWithoutServiceInput>
  }

  export type CustomerCreateWithoutProjectsInput = {
    id?: string
    companyName?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    taxId?: string | null
    phoneNumber?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCustomerInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceCreateNestedManyWithoutCustomerInput
    quotes?: QuoteCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutProjectsInput = {
    id?: string
    userId: string
    companyName?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    taxId?: string | null
    phoneNumber?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
    quotes?: QuoteUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutProjectsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutProjectsInput, CustomerUncheckedCreateWithoutProjectsInput>
  }

  export type DocumentCreateWithoutProjectInput = {
    id?: string
    filename: string
    originalName: string
    fileType: string
    fileSize?: number | null
    fileUrl?: string | null
    uploadedAt?: Date | string
    generations?: DocumentGenerationCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutProjectInput = {
    id?: string
    filename: string
    originalName: string
    fileType: string
    fileSize?: number | null
    fileUrl?: string | null
    uploadedAt?: Date | string
    generations?: DocumentGenerationUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutProjectInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutProjectInput, DocumentUncheckedCreateWithoutProjectInput>
  }

  export type DocumentCreateManyProjectInputEnvelope = {
    data: DocumentCreateManyProjectInput | DocumentCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectStageCreateWithoutProjectInput = {
    id?: string
    stageName: string
    status?: string
    notes?: string | null
    completedAt?: Date | string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectStageUncheckedCreateWithoutProjectInput = {
    id?: string
    stageName: string
    status?: string
    notes?: string | null
    completedAt?: Date | string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectStageCreateOrConnectWithoutProjectInput = {
    where: ProjectStageWhereUniqueInput
    create: XOR<ProjectStageCreateWithoutProjectInput, ProjectStageUncheckedCreateWithoutProjectInput>
  }

  export type ProjectStageCreateManyProjectInputEnvelope = {
    data: ProjectStageCreateManyProjectInput | ProjectStageCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type MaterialCostCreateWithoutProjectInput = {
    id?: string
    supplier: string
    material: string
    quantity: number
    unitCost: number
    totalCost: number
    invoiceRef?: string | null
    date: Date | string
    category?: string | null
    createdAt?: Date | string
  }

  export type MaterialCostUncheckedCreateWithoutProjectInput = {
    id?: string
    supplier: string
    material: string
    quantity: number
    unitCost: number
    totalCost: number
    invoiceRef?: string | null
    date: Date | string
    category?: string | null
    createdAt?: Date | string
  }

  export type MaterialCostCreateOrConnectWithoutProjectInput = {
    where: MaterialCostWhereUniqueInput
    create: XOR<MaterialCostCreateWithoutProjectInput, MaterialCostUncheckedCreateWithoutProjectInput>
  }

  export type MaterialCostCreateManyProjectInputEnvelope = {
    data: MaterialCostCreateManyProjectInput | MaterialCostCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutProjectInput = {
    id?: string
    orderNumber: string
    status?: string
    subtotal: number
    tax: number
    shipping: number
    total: number
    currency?: string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingMethod?: string | null
    trackingNumber?: string | null
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    paymentStatus?: string
    paymentIntentId?: string | null
    paidAt?: Date | string | null
    customerNotes?: string | null
    internalNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    invoice?: InvoiceCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutProjectInput = {
    id?: string
    orderNumber: string
    customerId: string
    status?: string
    subtotal: number
    tax: number
    shipping: number
    total: number
    currency?: string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingMethod?: string | null
    trackingNumber?: string | null
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    paymentStatus?: string
    paymentIntentId?: string | null
    paidAt?: Date | string | null
    customerNotes?: string | null
    internalNotes?: string | null
    invoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutProjectInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutProjectInput, OrderUncheckedCreateWithoutProjectInput>
  }

  export type ServiceCreateWithoutProjectsInput = {
    id?: string
    serviceCode: string
    name: string
    description?: string | null
    category: string
    basePrice?: number | null
    pricingModel?: string
    currency?: string
    specifications?: NullableJsonNullValueInput | InputJsonValue
    portfolio?: NullableJsonNullValueInput | InputJsonValue
    leadTime?: number | null
    capacity?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    quotes?: QuoteCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutProjectsInput = {
    id?: string
    serviceCode: string
    name: string
    description?: string | null
    category: string
    basePrice?: number | null
    pricingModel?: string
    currency?: string
    specifications?: NullableJsonNullValueInput | InputJsonValue
    portfolio?: NullableJsonNullValueInput | InputJsonValue
    leadTime?: number | null
    capacity?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    quotes?: QuoteUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutProjectsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutProjectsInput, ServiceUncheckedCreateWithoutProjectsInput>
  }

  export type CustomerUpsertWithoutProjectsInput = {
    update: XOR<CustomerUpdateWithoutProjectsInput, CustomerUncheckedUpdateWithoutProjectsInput>
    create: XOR<CustomerCreateWithoutProjectsInput, CustomerUncheckedCreateWithoutProjectsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutProjectsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutProjectsInput, CustomerUncheckedUpdateWithoutProjectsInput>
  }

  export type CustomerUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCustomerNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutCustomerNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUpdateManyWithoutCustomerNestedInput
    quotes?: QuoteUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutCustomerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    quotes?: QuoteUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type DocumentUpsertWithWhereUniqueWithoutProjectInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutProjectInput, DocumentUncheckedUpdateWithoutProjectInput>
    create: XOR<DocumentCreateWithoutProjectInput, DocumentUncheckedCreateWithoutProjectInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutProjectInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutProjectInput, DocumentUncheckedUpdateWithoutProjectInput>
  }

  export type DocumentUpdateManyWithWhereWithoutProjectInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutProjectInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: StringFilter<"Document"> | string
    projectId?: StringFilter<"Document"> | string
    filename?: StringFilter<"Document"> | string
    originalName?: StringFilter<"Document"> | string
    fileType?: StringFilter<"Document"> | string
    fileSize?: IntNullableFilter<"Document"> | number | null
    fileUrl?: StringNullableFilter<"Document"> | string | null
    uploadedAt?: DateTimeFilter<"Document"> | Date | string
  }

  export type ProjectStageUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectStageWhereUniqueInput
    update: XOR<ProjectStageUpdateWithoutProjectInput, ProjectStageUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectStageCreateWithoutProjectInput, ProjectStageUncheckedCreateWithoutProjectInput>
  }

  export type ProjectStageUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectStageWhereUniqueInput
    data: XOR<ProjectStageUpdateWithoutProjectInput, ProjectStageUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectStageUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectStageScalarWhereInput
    data: XOR<ProjectStageUpdateManyMutationInput, ProjectStageUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectStageScalarWhereInput = {
    AND?: ProjectStageScalarWhereInput | ProjectStageScalarWhereInput[]
    OR?: ProjectStageScalarWhereInput[]
    NOT?: ProjectStageScalarWhereInput | ProjectStageScalarWhereInput[]
    id?: StringFilter<"ProjectStage"> | string
    projectId?: StringFilter<"ProjectStage"> | string
    stageName?: StringFilter<"ProjectStage"> | string
    status?: StringFilter<"ProjectStage"> | string
    notes?: StringNullableFilter<"ProjectStage"> | string | null
    completedAt?: DateTimeNullableFilter<"ProjectStage"> | Date | string | null
    order?: IntFilter<"ProjectStage"> | number
    createdAt?: DateTimeFilter<"ProjectStage"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectStage"> | Date | string
  }

  export type MaterialCostUpsertWithWhereUniqueWithoutProjectInput = {
    where: MaterialCostWhereUniqueInput
    update: XOR<MaterialCostUpdateWithoutProjectInput, MaterialCostUncheckedUpdateWithoutProjectInput>
    create: XOR<MaterialCostCreateWithoutProjectInput, MaterialCostUncheckedCreateWithoutProjectInput>
  }

  export type MaterialCostUpdateWithWhereUniqueWithoutProjectInput = {
    where: MaterialCostWhereUniqueInput
    data: XOR<MaterialCostUpdateWithoutProjectInput, MaterialCostUncheckedUpdateWithoutProjectInput>
  }

  export type MaterialCostUpdateManyWithWhereWithoutProjectInput = {
    where: MaterialCostScalarWhereInput
    data: XOR<MaterialCostUpdateManyMutationInput, MaterialCostUncheckedUpdateManyWithoutProjectInput>
  }

  export type MaterialCostScalarWhereInput = {
    AND?: MaterialCostScalarWhereInput | MaterialCostScalarWhereInput[]
    OR?: MaterialCostScalarWhereInput[]
    NOT?: MaterialCostScalarWhereInput | MaterialCostScalarWhereInput[]
    id?: StringFilter<"MaterialCost"> | string
    projectId?: StringNullableFilter<"MaterialCost"> | string | null
    supplier?: StringFilter<"MaterialCost"> | string
    material?: StringFilter<"MaterialCost"> | string
    quantity?: FloatFilter<"MaterialCost"> | number
    unitCost?: FloatFilter<"MaterialCost"> | number
    totalCost?: FloatFilter<"MaterialCost"> | number
    invoiceRef?: StringNullableFilter<"MaterialCost"> | string | null
    date?: DateTimeFilter<"MaterialCost"> | Date | string
    category?: StringNullableFilter<"MaterialCost"> | string | null
    createdAt?: DateTimeFilter<"MaterialCost"> | Date | string
  }

  export type OrderUpsertWithoutProjectInput = {
    update: XOR<OrderUpdateWithoutProjectInput, OrderUncheckedUpdateWithoutProjectInput>
    create: XOR<OrderCreateWithoutProjectInput, OrderUncheckedCreateWithoutProjectInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutProjectInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutProjectInput, OrderUncheckedUpdateWithoutProjectInput>
  }

  export type OrderUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    shipping?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    invoice?: InvoiceUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    shipping?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type ServiceUpsertWithoutProjectsInput = {
    update: XOR<ServiceUpdateWithoutProjectsInput, ServiceUncheckedUpdateWithoutProjectsInput>
    create: XOR<ServiceCreateWithoutProjectsInput, ServiceUncheckedCreateWithoutProjectsInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutProjectsInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutProjectsInput, ServiceUncheckedUpdateWithoutProjectsInput>
  }

  export type ServiceUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    basePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    pricingModel?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    specifications?: NullableJsonNullValueInput | InputJsonValue
    portfolio?: NullableJsonNullValueInput | InputJsonValue
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    capacity?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotes?: QuoteUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    basePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    pricingModel?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    specifications?: NullableJsonNullValueInput | InputJsonValue
    portfolio?: NullableJsonNullValueInput | InputJsonValue
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    capacity?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotes?: QuoteUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ProjectCreateWithoutStagesInput = {
    id?: string
    projectRef: string
    name: string
    description?: string | null
    service: string
    status?: string
    currentStage?: string
    stagesCompleted?: ProjectCreatestagesCompletedInput | string[]
    quotedAmount?: number | null
    actualCost?: number | null
    invoicedAmount?: number | null
    paidAmount?: number | null
    startDate?: Date | string | null
    targetDate?: Date | string | null
    completedDate?: Date | string | null
    location?: string | null
    notes?: string | null
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    client: CustomerCreateNestedOneWithoutProjectsInput
    documents?: DocumentCreateNestedManyWithoutProjectInput
    costs?: MaterialCostCreateNestedManyWithoutProjectInput
    order?: OrderCreateNestedOneWithoutProjectInput
    Service?: ServiceCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutStagesInput = {
    id?: string
    projectRef: string
    clientId: string
    name: string
    description?: string | null
    service: string
    status?: string
    currentStage?: string
    stagesCompleted?: ProjectCreatestagesCompletedInput | string[]
    quotedAmount?: number | null
    actualCost?: number | null
    invoicedAmount?: number | null
    paidAmount?: number | null
    startDate?: Date | string | null
    targetDate?: Date | string | null
    completedDate?: Date | string | null
    location?: string | null
    notes?: string | null
    priority?: string
    orderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceId?: string | null
    documents?: DocumentUncheckedCreateNestedManyWithoutProjectInput
    costs?: MaterialCostUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutStagesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutStagesInput, ProjectUncheckedCreateWithoutStagesInput>
  }

  export type ProjectUpsertWithoutStagesInput = {
    update: XOR<ProjectUpdateWithoutStagesInput, ProjectUncheckedUpdateWithoutStagesInput>
    create: XOR<ProjectCreateWithoutStagesInput, ProjectUncheckedCreateWithoutStagesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutStagesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutStagesInput, ProjectUncheckedUpdateWithoutStagesInput>
  }

  export type ProjectUpdateWithoutStagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectRef?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentStage?: StringFieldUpdateOperationsInput | string
    stagesCompleted?: ProjectUpdatestagesCompletedInput | string[]
    quotedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    invoicedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: CustomerUpdateOneRequiredWithoutProjectsNestedInput
    documents?: DocumentUpdateManyWithoutProjectNestedInput
    costs?: MaterialCostUpdateManyWithoutProjectNestedInput
    order?: OrderUpdateOneWithoutProjectNestedInput
    Service?: ServiceUpdateOneWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutStagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectRef?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentStage?: StringFieldUpdateOperationsInput | string
    stagesCompleted?: ProjectUpdatestagesCompletedInput | string[]
    quotedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    invoicedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: DocumentUncheckedUpdateManyWithoutProjectNestedInput
    costs?: MaterialCostUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutDocumentsInput = {
    id?: string
    projectRef: string
    name: string
    description?: string | null
    service: string
    status?: string
    currentStage?: string
    stagesCompleted?: ProjectCreatestagesCompletedInput | string[]
    quotedAmount?: number | null
    actualCost?: number | null
    invoicedAmount?: number | null
    paidAmount?: number | null
    startDate?: Date | string | null
    targetDate?: Date | string | null
    completedDate?: Date | string | null
    location?: string | null
    notes?: string | null
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    client: CustomerCreateNestedOneWithoutProjectsInput
    stages?: ProjectStageCreateNestedManyWithoutProjectInput
    costs?: MaterialCostCreateNestedManyWithoutProjectInput
    order?: OrderCreateNestedOneWithoutProjectInput
    Service?: ServiceCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutDocumentsInput = {
    id?: string
    projectRef: string
    clientId: string
    name: string
    description?: string | null
    service: string
    status?: string
    currentStage?: string
    stagesCompleted?: ProjectCreatestagesCompletedInput | string[]
    quotedAmount?: number | null
    actualCost?: number | null
    invoicedAmount?: number | null
    paidAmount?: number | null
    startDate?: Date | string | null
    targetDate?: Date | string | null
    completedDate?: Date | string | null
    location?: string | null
    notes?: string | null
    priority?: string
    orderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceId?: string | null
    stages?: ProjectStageUncheckedCreateNestedManyWithoutProjectInput
    costs?: MaterialCostUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutDocumentsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutDocumentsInput, ProjectUncheckedCreateWithoutDocumentsInput>
  }

  export type DocumentGenerationCreateWithoutDocumentInput = {
    id?: string
    documentType: string
    documentNumber: string
    templateData: string
    status?: string
    generatedBy?: string | null
    generatedAt?: Date | string | null
    autoSend?: boolean
    emailSent?: boolean
    emailSentAt?: Date | string | null
    recipientEmail?: string | null
    fileUrl?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentGenerationUncheckedCreateWithoutDocumentInput = {
    id?: string
    documentType: string
    documentNumber: string
    templateData: string
    status?: string
    generatedBy?: string | null
    generatedAt?: Date | string | null
    autoSend?: boolean
    emailSent?: boolean
    emailSentAt?: Date | string | null
    recipientEmail?: string | null
    fileUrl?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentGenerationCreateOrConnectWithoutDocumentInput = {
    where: DocumentGenerationWhereUniqueInput
    create: XOR<DocumentGenerationCreateWithoutDocumentInput, DocumentGenerationUncheckedCreateWithoutDocumentInput>
  }

  export type DocumentGenerationCreateManyDocumentInputEnvelope = {
    data: DocumentGenerationCreateManyDocumentInput | DocumentGenerationCreateManyDocumentInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutDocumentsInput = {
    update: XOR<ProjectUpdateWithoutDocumentsInput, ProjectUncheckedUpdateWithoutDocumentsInput>
    create: XOR<ProjectCreateWithoutDocumentsInput, ProjectUncheckedCreateWithoutDocumentsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutDocumentsInput, ProjectUncheckedUpdateWithoutDocumentsInput>
  }

  export type ProjectUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectRef?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentStage?: StringFieldUpdateOperationsInput | string
    stagesCompleted?: ProjectUpdatestagesCompletedInput | string[]
    quotedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    invoicedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: CustomerUpdateOneRequiredWithoutProjectsNestedInput
    stages?: ProjectStageUpdateManyWithoutProjectNestedInput
    costs?: MaterialCostUpdateManyWithoutProjectNestedInput
    order?: OrderUpdateOneWithoutProjectNestedInput
    Service?: ServiceUpdateOneWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectRef?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentStage?: StringFieldUpdateOperationsInput | string
    stagesCompleted?: ProjectUpdatestagesCompletedInput | string[]
    quotedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    invoicedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    stages?: ProjectStageUncheckedUpdateManyWithoutProjectNestedInput
    costs?: MaterialCostUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type DocumentGenerationUpsertWithWhereUniqueWithoutDocumentInput = {
    where: DocumentGenerationWhereUniqueInput
    update: XOR<DocumentGenerationUpdateWithoutDocumentInput, DocumentGenerationUncheckedUpdateWithoutDocumentInput>
    create: XOR<DocumentGenerationCreateWithoutDocumentInput, DocumentGenerationUncheckedCreateWithoutDocumentInput>
  }

  export type DocumentGenerationUpdateWithWhereUniqueWithoutDocumentInput = {
    where: DocumentGenerationWhereUniqueInput
    data: XOR<DocumentGenerationUpdateWithoutDocumentInput, DocumentGenerationUncheckedUpdateWithoutDocumentInput>
  }

  export type DocumentGenerationUpdateManyWithWhereWithoutDocumentInput = {
    where: DocumentGenerationScalarWhereInput
    data: XOR<DocumentGenerationUpdateManyMutationInput, DocumentGenerationUncheckedUpdateManyWithoutDocumentInput>
  }

  export type DocumentGenerationScalarWhereInput = {
    AND?: DocumentGenerationScalarWhereInput | DocumentGenerationScalarWhereInput[]
    OR?: DocumentGenerationScalarWhereInput[]
    NOT?: DocumentGenerationScalarWhereInput | DocumentGenerationScalarWhereInput[]
    id?: StringFilter<"DocumentGeneration"> | string
    documentId?: StringFilter<"DocumentGeneration"> | string
    documentType?: StringFilter<"DocumentGeneration"> | string
    documentNumber?: StringFilter<"DocumentGeneration"> | string
    templateData?: StringFilter<"DocumentGeneration"> | string
    status?: StringFilter<"DocumentGeneration"> | string
    generatedBy?: StringNullableFilter<"DocumentGeneration"> | string | null
    generatedAt?: DateTimeNullableFilter<"DocumentGeneration"> | Date | string | null
    autoSend?: BoolFilter<"DocumentGeneration"> | boolean
    emailSent?: BoolFilter<"DocumentGeneration"> | boolean
    emailSentAt?: DateTimeNullableFilter<"DocumentGeneration"> | Date | string | null
    recipientEmail?: StringNullableFilter<"DocumentGeneration"> | string | null
    fileUrl?: StringNullableFilter<"DocumentGeneration"> | string | null
    errorMessage?: StringNullableFilter<"DocumentGeneration"> | string | null
    createdAt?: DateTimeFilter<"DocumentGeneration"> | Date | string
    updatedAt?: DateTimeFilter<"DocumentGeneration"> | Date | string
  }

  export type DocumentCreateWithoutGenerationsInput = {
    id?: string
    filename: string
    originalName: string
    fileType: string
    fileSize?: number | null
    fileUrl?: string | null
    uploadedAt?: Date | string
    project: ProjectCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutGenerationsInput = {
    id?: string
    projectId: string
    filename: string
    originalName: string
    fileType: string
    fileSize?: number | null
    fileUrl?: string | null
    uploadedAt?: Date | string
  }

  export type DocumentCreateOrConnectWithoutGenerationsInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutGenerationsInput, DocumentUncheckedCreateWithoutGenerationsInput>
  }

  export type DocumentUpsertWithoutGenerationsInput = {
    update: XOR<DocumentUpdateWithoutGenerationsInput, DocumentUncheckedUpdateWithoutGenerationsInput>
    create: XOR<DocumentCreateWithoutGenerationsInput, DocumentUncheckedCreateWithoutGenerationsInput>
    where?: DocumentWhereInput
  }

  export type DocumentUpdateToOneWithWhereWithoutGenerationsInput = {
    where?: DocumentWhereInput
    data: XOR<DocumentUpdateWithoutGenerationsInput, DocumentUncheckedUpdateWithoutGenerationsInput>
  }

  export type DocumentUpdateWithoutGenerationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutGenerationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateWithoutQuotesInput = {
    id?: string
    companyName?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    taxId?: string | null
    phoneNumber?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCustomerInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceCreateNestedManyWithoutCustomerInput
    projects?: ProjectCreateNestedManyWithoutClientInput
  }

  export type CustomerUncheckedCreateWithoutQuotesInput = {
    id?: string
    userId: string
    companyName?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    taxId?: string | null
    phoneNumber?: string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
  }

  export type CustomerCreateOrConnectWithoutQuotesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutQuotesInput, CustomerUncheckedCreateWithoutQuotesInput>
  }

  export type ServiceCreateWithoutQuotesInput = {
    id?: string
    serviceCode: string
    name: string
    description?: string | null
    category: string
    basePrice?: number | null
    pricingModel?: string
    currency?: string
    specifications?: NullableJsonNullValueInput | InputJsonValue
    portfolio?: NullableJsonNullValueInput | InputJsonValue
    leadTime?: number | null
    capacity?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutQuotesInput = {
    id?: string
    serviceCode: string
    name: string
    description?: string | null
    category: string
    basePrice?: number | null
    pricingModel?: string
    currency?: string
    specifications?: NullableJsonNullValueInput | InputJsonValue
    portfolio?: NullableJsonNullValueInput | InputJsonValue
    leadTime?: number | null
    capacity?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutQuotesInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutQuotesInput, ServiceUncheckedCreateWithoutQuotesInput>
  }

  export type CustomerUpsertWithoutQuotesInput = {
    update: XOR<CustomerUpdateWithoutQuotesInput, CustomerUncheckedUpdateWithoutQuotesInput>
    create: XOR<CustomerCreateWithoutQuotesInput, CustomerUncheckedCreateWithoutQuotesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutQuotesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutQuotesInput, CustomerUncheckedUpdateWithoutQuotesInput>
  }

  export type CustomerUpdateWithoutQuotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCustomerNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutCustomerNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUpdateManyWithoutCustomerNestedInput
    projects?: ProjectUpdateManyWithoutClientNestedInput
  }

  export type CustomerUncheckedUpdateWithoutQuotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutCustomerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ServiceUpsertWithoutQuotesInput = {
    update: XOR<ServiceUpdateWithoutQuotesInput, ServiceUncheckedUpdateWithoutQuotesInput>
    create: XOR<ServiceCreateWithoutQuotesInput, ServiceUncheckedCreateWithoutQuotesInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutQuotesInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutQuotesInput, ServiceUncheckedUpdateWithoutQuotesInput>
  }

  export type ServiceUpdateWithoutQuotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    basePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    pricingModel?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    specifications?: NullableJsonNullValueInput | InputJsonValue
    portfolio?: NullableJsonNullValueInput | InputJsonValue
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    capacity?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutQuotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    basePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    pricingModel?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    specifications?: NullableJsonNullValueInput | InputJsonValue
    portfolio?: NullableJsonNullValueInput | InputJsonValue
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    capacity?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ProjectCreateWithoutCostsInput = {
    id?: string
    projectRef: string
    name: string
    description?: string | null
    service: string
    status?: string
    currentStage?: string
    stagesCompleted?: ProjectCreatestagesCompletedInput | string[]
    quotedAmount?: number | null
    actualCost?: number | null
    invoicedAmount?: number | null
    paidAmount?: number | null
    startDate?: Date | string | null
    targetDate?: Date | string | null
    completedDate?: Date | string | null
    location?: string | null
    notes?: string | null
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    client: CustomerCreateNestedOneWithoutProjectsInput
    documents?: DocumentCreateNestedManyWithoutProjectInput
    stages?: ProjectStageCreateNestedManyWithoutProjectInput
    order?: OrderCreateNestedOneWithoutProjectInput
    Service?: ServiceCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutCostsInput = {
    id?: string
    projectRef: string
    clientId: string
    name: string
    description?: string | null
    service: string
    status?: string
    currentStage?: string
    stagesCompleted?: ProjectCreatestagesCompletedInput | string[]
    quotedAmount?: number | null
    actualCost?: number | null
    invoicedAmount?: number | null
    paidAmount?: number | null
    startDate?: Date | string | null
    targetDate?: Date | string | null
    completedDate?: Date | string | null
    location?: string | null
    notes?: string | null
    priority?: string
    orderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceId?: string | null
    documents?: DocumentUncheckedCreateNestedManyWithoutProjectInput
    stages?: ProjectStageUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutCostsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutCostsInput, ProjectUncheckedCreateWithoutCostsInput>
  }

  export type ProjectUpsertWithoutCostsInput = {
    update: XOR<ProjectUpdateWithoutCostsInput, ProjectUncheckedUpdateWithoutCostsInput>
    create: XOR<ProjectCreateWithoutCostsInput, ProjectUncheckedCreateWithoutCostsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutCostsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutCostsInput, ProjectUncheckedUpdateWithoutCostsInput>
  }

  export type ProjectUpdateWithoutCostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectRef?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentStage?: StringFieldUpdateOperationsInput | string
    stagesCompleted?: ProjectUpdatestagesCompletedInput | string[]
    quotedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    invoicedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: CustomerUpdateOneRequiredWithoutProjectsNestedInput
    documents?: DocumentUpdateManyWithoutProjectNestedInput
    stages?: ProjectStageUpdateManyWithoutProjectNestedInput
    order?: OrderUpdateOneWithoutProjectNestedInput
    Service?: ServiceUpdateOneWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutCostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectRef?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentStage?: StringFieldUpdateOperationsInput | string
    stagesCompleted?: ProjectUpdatestagesCompletedInput | string[]
    quotedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    invoicedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: DocumentUncheckedUpdateManyWithoutProjectNestedInput
    stages?: ProjectStageUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ChatSessionCreateManyUserInput = {
    id: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    systemPrompt?: string | null
    isActive?: boolean
    userName?: string | null
    userEmail?: string | null
    ipAddress?: string | null
    location?: string | null
    source?: string | null
    category?: string | null
    mondayItemId?: string | null
    mondaySynced?: boolean
    copilotSynced?: boolean
    databaseSynced?: boolean
    lastMondaySync?: Date | string | null
    lastCopilotSync?: Date | string | null
  }

  export type MessageCreateManyUserInput = {
    id: string
    sessionId: string
    role: string
    content: string
    timestamp?: Date | string
    isError?: boolean | null
    functionName?: string | null
    functionArgs?: string | null
  }

  export type ChatSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    systemPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    mondayItemId?: NullableStringFieldUpdateOperationsInput | string | null
    mondaySynced?: BoolFieldUpdateOperationsInput | boolean
    copilotSynced?: BoolFieldUpdateOperationsInput | boolean
    databaseSynced?: BoolFieldUpdateOperationsInput | boolean
    lastMondaySync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastCopilotSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUpdateManyWithoutSessionNestedInput
    tags?: SessionTagUpdateManyWithoutSessionNestedInput
  }

  export type ChatSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    systemPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    mondayItemId?: NullableStringFieldUpdateOperationsInput | string | null
    mondaySynced?: BoolFieldUpdateOperationsInput | boolean
    copilotSynced?: BoolFieldUpdateOperationsInput | boolean
    databaseSynced?: BoolFieldUpdateOperationsInput | boolean
    lastMondaySync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastCopilotSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutSessionNestedInput
    tags?: SessionTagUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type ChatSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    systemPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    mondayItemId?: NullableStringFieldUpdateOperationsInput | string | null
    mondaySynced?: BoolFieldUpdateOperationsInput | boolean
    copilotSynced?: BoolFieldUpdateOperationsInput | boolean
    databaseSynced?: BoolFieldUpdateOperationsInput | boolean
    lastMondaySync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastCopilotSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isError?: NullableBoolFieldUpdateOperationsInput | boolean | null
    functionName?: NullableStringFieldUpdateOperationsInput | string | null
    functionArgs?: NullableStringFieldUpdateOperationsInput | string | null
    session?: ChatSessionUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isError?: NullableBoolFieldUpdateOperationsInput | boolean | null
    functionName?: NullableStringFieldUpdateOperationsInput | string | null
    functionArgs?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isError?: NullableBoolFieldUpdateOperationsInput | boolean | null
    functionName?: NullableStringFieldUpdateOperationsInput | string | null
    functionArgs?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageCreateManySessionInput = {
    id: string
    role: string
    content: string
    timestamp?: Date | string
    isError?: boolean | null
    userId?: string | null
    functionName?: string | null
    functionArgs?: string | null
  }

  export type SessionTagCreateManySessionInput = {
    id?: string
    name: string
  }

  export type MessageUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isError?: NullableBoolFieldUpdateOperationsInput | boolean | null
    functionName?: NullableStringFieldUpdateOperationsInput | string | null
    functionArgs?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isError?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    functionName?: NullableStringFieldUpdateOperationsInput | string | null
    functionArgs?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isError?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    functionName?: NullableStringFieldUpdateOperationsInput | string | null
    functionArgs?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionTagUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SessionTagUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SessionTagUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentMethodCreateManyCustomerInput = {
    id?: string
    stripePaymentMethodId: string
    type: string
    last4: string
    brand?: string | null
    expiryMonth?: number | null
    expiryYear?: number | null
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateManyCustomerInput = {
    id?: string
    orderNumber: string
    status?: string
    subtotal: number
    tax: number
    shipping: number
    total: number
    currency?: string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingMethod?: string | null
    trackingNumber?: string | null
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    paymentStatus?: string
    paymentIntentId?: string | null
    paidAt?: Date | string | null
    customerNotes?: string | null
    internalNotes?: string | null
    invoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateManyCustomerInput = {
    id?: string
    status?: string
    planId: string
    billingCycle?: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    nextBillingDate: Date | string
    stripeSubscriptionId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateManyCustomerInput = {
    id?: string
    invoiceNumber: string
    type: string
    subscriptionId?: string | null
    subtotal: number
    tax: number
    total: number
    currency?: string
    status?: string
    dueDate: Date | string
    paidAt?: Date | string | null
    paymentIntentId?: string | null
    paymentMethod?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectCreateManyClientInput = {
    id?: string
    projectRef: string
    name: string
    description?: string | null
    service: string
    status?: string
    currentStage?: string
    stagesCompleted?: ProjectCreatestagesCompletedInput | string[]
    quotedAmount?: number | null
    actualCost?: number | null
    invoicedAmount?: number | null
    paidAmount?: number | null
    startDate?: Date | string | null
    targetDate?: Date | string | null
    completedDate?: Date | string | null
    location?: string | null
    notes?: string | null
    priority?: string
    orderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceId?: string | null
  }

  export type QuoteCreateManyCustomerInput = {
    id?: string
    quoteNumber: string
    title: string
    description?: string | null
    services: JsonNullValueInput | InputJsonValue
    subtotal: number
    tax: number
    total: number
    currency?: string
    validUntil: Date | string
    status?: string
    terms?: string | null
    notes?: string | null
    convertedToProjectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceId?: string | null
  }

  export type PaymentMethodUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentMethodId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    last4?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    expiryMonth?: NullableIntFieldUpdateOperationsInput | number | null
    expiryYear?: NullableIntFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentMethodId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    last4?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    expiryMonth?: NullableIntFieldUpdateOperationsInput | number | null
    expiryYear?: NullableIntFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentMethodId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    last4?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    expiryMonth?: NullableIntFieldUpdateOperationsInput | number | null
    expiryYear?: NullableIntFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    shipping?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    invoice?: InvoiceUpdateOneWithoutOrderNestedInput
    project?: ProjectUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    shipping?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    project?: ProjectUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    shipping?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    billingCycle?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    invoices?: InvoiceUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    billingCycle?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    billingCycle?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneWithoutInvoiceNestedInput
    subscription?: SubscriptionUpdateOneWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUncheckedUpdateOneWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectRef?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentStage?: StringFieldUpdateOperationsInput | string
    stagesCompleted?: ProjectUpdatestagesCompletedInput | string[]
    quotedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    invoicedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUpdateManyWithoutProjectNestedInput
    stages?: ProjectStageUpdateManyWithoutProjectNestedInput
    costs?: MaterialCostUpdateManyWithoutProjectNestedInput
    order?: OrderUpdateOneWithoutProjectNestedInput
    Service?: ServiceUpdateOneWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectRef?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentStage?: StringFieldUpdateOperationsInput | string
    stagesCompleted?: ProjectUpdatestagesCompletedInput | string[]
    quotedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    invoicedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: DocumentUncheckedUpdateManyWithoutProjectNestedInput
    stages?: ProjectStageUncheckedUpdateManyWithoutProjectNestedInput
    costs?: MaterialCostUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectRef?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentStage?: StringFieldUpdateOperationsInput | string
    stagesCompleted?: ProjectUpdatestagesCompletedInput | string[]
    quotedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    invoicedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuoteUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    services?: JsonNullValueInput | InputJsonValue
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    convertedToProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Service?: ServiceUpdateOneWithoutQuotesNestedInput
  }

  export type QuoteUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    services?: JsonNullValueInput | InputJsonValue
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    convertedToProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuoteUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    services?: JsonNullValueInput | InputJsonValue
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    convertedToProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryCreateManyProductInput = {
    id?: string
    location: string
    quantity?: number
    reservedQuantity?: number
    availableQuantity?: number
    reorderPoint?: number
    reorderQuantity?: number
    batchNumber?: string | null
    serialNumbers?: NullableJsonNullValueInput | InputJsonValue
    lastRestocked?: Date | string | null
    lastCounted?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemCreateManyProductInput = {
    id?: string
    orderId: string
    quantity: number
    unitPrice: number
    totalPrice: number
    productSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CartItemCreateManyProductInput = {
    id?: string
    cartId: string
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PriceHistoryCreateManyProductInput = {
    id?: string
    price: number
    previousPrice?: number | null
    currency?: string
    reason?: string | null
    effectiveFrom: Date | string
    effectiveUntil?: Date | string | null
    createdAt?: Date | string
  }

  export type InventoryUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    availableQuantity?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    reorderQuantity?: IntFieldUpdateOperationsInput | number
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumbers?: NullableJsonNullValueInput | InputJsonValue
    lastRestocked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastCounted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    availableQuantity?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    reorderQuantity?: IntFieldUpdateOperationsInput | number
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumbers?: NullableJsonNullValueInput | InputJsonValue
    lastRestocked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastCounted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    availableQuantity?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    reorderQuantity?: IntFieldUpdateOperationsInput | number
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumbers?: NullableJsonNullValueInput | InputJsonValue
    lastRestocked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastCounted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    productSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    productSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    productSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cart?: CartUpdateOneRequiredWithoutItemsNestedInput
  }

  export type CartItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceHistoryUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    previousPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceHistoryUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    previousPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceHistoryUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    previousPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateManyOrderInput = {
    id?: string
    productId: string
    quantity: number
    unitPrice: number
    totalPrice: number
    productSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type OrderItemUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    productSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    productSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    productSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateManySubscriptionInput = {
    id?: string
    invoiceNumber: string
    customerId: string
    type: string
    subtotal: number
    tax: number
    total: number
    currency?: string
    status?: string
    dueDate: Date | string
    paidAt?: Date | string | null
    paymentIntentId?: string | null
    paymentMethod?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutInvoicesNestedInput
    order?: OrderUpdateOneWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUncheckedUpdateOneWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateManyPlanInput = {
    id?: string
    customerId: string
    status?: string
    billingCycle?: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    nextBillingDate: Date | string
    stripeSubscriptionId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    cancelledAt?: Date | string | null
    cancelReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    billingCycle?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutSubscriptionsNestedInput
    invoices?: InvoiceUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    billingCycle?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    billingCycle?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemCreateManyCartInput = {
    id?: string
    productId: string
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartItemUpdateWithoutCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutCartItemsNestedInput
  }

  export type CartItemUncheckedUpdateWithoutCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemUncheckedUpdateManyWithoutCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizResponseCreateManySessionInput = {
    id?: string
    questionId: string
    questionType: string
    responseValue: JsonNullValueInput | InputJsonValue
    responseTime?: number | null
    createdAt?: Date | string
  }

  export type BehavioralInteractionCreateManySessionInput = {
    id?: string
    interactionType: string
    element?: string | null
    position?: NullableJsonNullValueInput | InputJsonValue
    viewport?: NullableJsonNullValueInput | InputJsonValue
    duration?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type QuizConversionCreateManySessionInput = {
    id?: string
    conversionType: string
    conversionValue?: number | null
    orderId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type QuizResponseUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    questionType?: StringFieldUpdateOperationsInput | string
    responseValue?: JsonNullValueInput | InputJsonValue
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizResponseUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    questionType?: StringFieldUpdateOperationsInput | string
    responseValue?: JsonNullValueInput | InputJsonValue
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizResponseUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    questionType?: StringFieldUpdateOperationsInput | string
    responseValue?: JsonNullValueInput | InputJsonValue
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BehavioralInteractionUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    interactionType?: StringFieldUpdateOperationsInput | string
    element?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableJsonNullValueInput | InputJsonValue
    viewport?: NullableJsonNullValueInput | InputJsonValue
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BehavioralInteractionUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    interactionType?: StringFieldUpdateOperationsInput | string
    element?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableJsonNullValueInput | InputJsonValue
    viewport?: NullableJsonNullValueInput | InputJsonValue
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BehavioralInteractionUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    interactionType?: StringFieldUpdateOperationsInput | string
    element?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableJsonNullValueInput | InputJsonValue
    viewport?: NullableJsonNullValueInput | InputJsonValue
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizConversionUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversionType?: StringFieldUpdateOperationsInput | string
    conversionValue?: NullableFloatFieldUpdateOperationsInput | number | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizConversionUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversionType?: StringFieldUpdateOperationsInput | string
    conversionValue?: NullableFloatFieldUpdateOperationsInput | number | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizConversionUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversionType?: StringFieldUpdateOperationsInput | string
    conversionValue?: NullableFloatFieldUpdateOperationsInput | number | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateManyServiceInput = {
    id?: string
    projectRef: string
    clientId: string
    name: string
    description?: string | null
    service: string
    status?: string
    currentStage?: string
    stagesCompleted?: ProjectCreatestagesCompletedInput | string[]
    quotedAmount?: number | null
    actualCost?: number | null
    invoicedAmount?: number | null
    paidAmount?: number | null
    startDate?: Date | string | null
    targetDate?: Date | string | null
    completedDate?: Date | string | null
    location?: string | null
    notes?: string | null
    priority?: string
    orderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuoteCreateManyServiceInput = {
    id?: string
    quoteNumber: string
    customerId: string
    title: string
    description?: string | null
    services: JsonNullValueInput | InputJsonValue
    subtotal: number
    tax: number
    total: number
    currency?: string
    validUntil: Date | string
    status?: string
    terms?: string | null
    notes?: string | null
    convertedToProjectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectRef?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentStage?: StringFieldUpdateOperationsInput | string
    stagesCompleted?: ProjectUpdatestagesCompletedInput | string[]
    quotedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    invoicedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: CustomerUpdateOneRequiredWithoutProjectsNestedInput
    documents?: DocumentUpdateManyWithoutProjectNestedInput
    stages?: ProjectStageUpdateManyWithoutProjectNestedInput
    costs?: MaterialCostUpdateManyWithoutProjectNestedInput
    order?: OrderUpdateOneWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectRef?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentStage?: StringFieldUpdateOperationsInput | string
    stagesCompleted?: ProjectUpdatestagesCompletedInput | string[]
    quotedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    invoicedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutProjectNestedInput
    stages?: ProjectStageUncheckedUpdateManyWithoutProjectNestedInput
    costs?: MaterialCostUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectRef?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentStage?: StringFieldUpdateOperationsInput | string
    stagesCompleted?: ProjectUpdatestagesCompletedInput | string[]
    quotedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    invoicedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    services?: JsonNullValueInput | InputJsonValue
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    convertedToProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutQuotesNestedInput
  }

  export type QuoteUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    services?: JsonNullValueInput | InputJsonValue
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    convertedToProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    services?: JsonNullValueInput | InputJsonValue
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    convertedToProjectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateManyProjectInput = {
    id?: string
    filename: string
    originalName: string
    fileType: string
    fileSize?: number | null
    fileUrl?: string | null
    uploadedAt?: Date | string
  }

  export type ProjectStageCreateManyProjectInput = {
    id?: string
    stageName: string
    status?: string
    notes?: string | null
    completedAt?: Date | string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialCostCreateManyProjectInput = {
    id?: string
    supplier: string
    material: string
    quantity: number
    unitCost: number
    totalCost: number
    invoiceRef?: string | null
    date: Date | string
    category?: string | null
    createdAt?: Date | string
  }

  export type DocumentUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generations?: DocumentGenerationUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generations?: DocumentGenerationUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectStageUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    stageName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectStageUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    stageName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectStageUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    stageName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialCostUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplier?: StringFieldUpdateOperationsInput | string
    material?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    invoiceRef?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialCostUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplier?: StringFieldUpdateOperationsInput | string
    material?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    invoiceRef?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialCostUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplier?: StringFieldUpdateOperationsInput | string
    material?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    invoiceRef?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentGenerationCreateManyDocumentInput = {
    id?: string
    documentType: string
    documentNumber: string
    templateData: string
    status?: string
    generatedBy?: string | null
    generatedAt?: Date | string | null
    autoSend?: boolean
    emailSent?: boolean
    emailSentAt?: Date | string | null
    recipientEmail?: string | null
    fileUrl?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentGenerationUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    documentNumber?: StringFieldUpdateOperationsInput | string
    templateData?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    generatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoSend?: BoolFieldUpdateOperationsInput | boolean
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentGenerationUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    documentNumber?: StringFieldUpdateOperationsInput | string
    templateData?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    generatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoSend?: BoolFieldUpdateOperationsInput | boolean
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentGenerationUncheckedUpdateManyWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    documentNumber?: StringFieldUpdateOperationsInput | string
    templateData?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    generatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoSend?: BoolFieldUpdateOperationsInput | boolean
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}